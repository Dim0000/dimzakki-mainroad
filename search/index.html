<!doctype html><html class=no-js lang=ja><head><meta charset=UTF-8><meta name=robots content="noindex"><meta name=viewport content="width=device-width,initial-scale=1"><title>サイト内全文検索 - Dim雑記</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta itemprop=name content="サイト内全文検索"><meta itemprop=description content="ITエンジニアが運営する雑記ブログです"><meta itemprop=dateModified content="2025-07-18T23:20:39+09:00"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/dimzakki-mainroad/css/style.css><link rel=stylesheet href=/dimzakki-mainroad/css/custom.css><link rel="shortcut icon" href=/dimzakki-mainroad/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/dimzakki-mainroad/ title=Dim雑記 rel=home><div class="logo__item logo__text"><div class=logo__title>Dim雑記</div><div class=logo__tagline>ITエンジニアが運営する雑記ブログです</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>メニュー</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/dimzakki-mainroad/about><span class=menu__text>当サイトについて</span></a></li><li class=menu__item><a class=menu__link href=/dimzakki-mainroad/profile><span class=menu__text>プロフィール</span></a></li><li class=menu__item><a class=menu__link href=/dimzakki-mainroad/it-qualification><span class=menu__text>IT資格一覧</span></a></li><li class=menu__item><a class=menu__link href=/dimzakki-mainroad/search><span class=menu__text>サイト内全文検索</span></a></li><li class=menu__item><a class=menu__link href=/dimzakki-mainroad/contact><span class=menu__text>お問い合わせ</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><title>サイト内全文検索 | Dim雑記</title><h1>サイト内全文検索</h1><hr><p>このページでは、サイト内の記事を全文検索できます。</p><p>検索ボックスにキーワードを入力してください。</p><hr><input onkeyup=search(this.value) size=15 autocomplete=off autofocus placeholder=検索ワード>
<span id=inputWord></span> <span id=resultCount></span><div id=result></div><script src=\js\search.js></script><script>const data=[{url:"/dimzakki-mainroad/kintone-api-action-hidden/",title:"【kintone API】アクションボタンを非表示にする方法",date:"2025-07-05T00:00:00Z",body:"【kintone API】アクションボタンを非表示にする方法 kintone APIで、アクションボタンを非表示にするカスタマイズについて紹介します。 アクションボタンの要素取得 レコード詳細画面の表示時に、ステータスバーのアクションボタンを非表示します。今回はボタン名が「アクション」のものを非表示とします。 まず、レコード詳細画面の表示時のイベントで、ステータスアクションのDOMをgetElementsByClassName('gaia-app-statusbar-action-label')で取得します。ここで、注意点としては、'app.record.detail.show'のイベント直後だと、ステータスアクションのDOMが取得できません。 そこで、setTimeoutで遅延させることでDOMを取得できるようにします。また、レコードのプロセス管理を行っている場合は、ステータスを変更されるDOMも一緒に取得されるので、その場合はボタンの表示名で条件に追加する必要があります。 サンプルとして、下記のコードでボタンを非表示にできます。 1(function () { 2 &#34;use strict&#34;; 3 4 kintone.events.on(&#39;app.record.detail.show&#39;, function (event) { 5 setTimeout(function () { 6 const statusBarActions = document.getElementsByClassName(&#39;gaia-app-statusbar-action-label&#39;); 7 8 for (let i = 0; i &lt; statusBarActions.length; i++) { 9 const actionLabel = statusBarActions[i]; 10 if (actionLabel.title === &#34;アクション&#34;) { 11 actionLabel.parentNode.style.display = &#39;none&#39;; 12 } 13 } 14 }, 100); 15 16 return event; 17 }); 18})();\r適宜、レコードの条件などを追加することで、より実践的な活性制御が実現できます。 今回はkintone APIでのアクションボタンの制御についてまとめました。以上で記事を終わりにします。 参考文献 アクションボタン表示・非表示切り替え - kintone カスタマイズ | cybozu developer community Window: setTimeout() メソッド - Web API | MDN"},{url:"/dimzakki-mainroad/",title:"Dim雑記",date:"2025-07-05T00:00:00Z",body:"Dim雑記"},{url:"/dimzakki-mainroad/post/",title:"Posts",date:"2025-07-05T00:00:00Z",body:"Posts"},{url:"/dimzakki-mainroad/assembly-getexecutingassembly/",title:"【Visual Studio】ファイルを埋め込みリソースとして読み込む際の注意点",date:"2025-06-01T00:00:00Z",body:"【Visual Studio】ファイルを埋め込みリソースとして読み込む際の注意点 Visual Studioでファイルを埋め込みリソースとして読み込む際の注意点についての備忘録です。 埋め込みリソースについて 画像やテキストファイルを実行ファイルに埋め込んでビルドする手法があります。 具体的には、Assembly.GetExecutingAssembly()を使ってアセンブリの情報を取得します。メソッドは以下の様に使うことができます。 Program.cs\r1var assembly = Assembly.GetExecutingAssembly(); 2var resourceName = &#34;MyNamespace.folder.filename.txt&#34;; 3 4using (Stream stream = assembly.GetManifestResourceStream(resourceName)) 5using (StreamReader reader = new StreamReader(stream)) 6{ 7 string content = reader.ReadToEnd(); 8}\r上記のコードではテキストファイルを読み込みこんでいます。 注意点 ここで、注意点として、Visual Studioではリソースファイルの「ビルドアクション」を「埋め込みリソース（Embedded Resource）」に設定しておく必要があります。 この設定ができていない（「コンテンツ」や「なし」になっている）とリソースを読み込みしてくれないので気をつけましょう。 今回はVisual Studioでファイルを埋め込みリソースとして読み込む方法について紹介しました。以上で記事を終わりにします。 参考文献 Assembly.GetExecutingAssembly メソッド | Microsoft Learn"},{url:"/dimzakki-mainroad/android-getlaunchintentforpackage/",title:"【Android】インストール済みの起動可能なアプリを取得する",date:"2025-05-31T00:00:00Z",body:"【Android】インストール済みの起動可能なアプリを取得する KotlinでのAndroid開発でPackageManagerクラスを使い、インストール済みの起動可能なアプリを取得する方法を紹介します。 getLaunchIntentForPackageメソッドについて PackageManagerクラスにあるgetLaunchIntentForPackageメソッドを使うことで、指定したアプリ（パッケージ）の起動用インテントを取得することができます。ここで、起動用インテントとは、アプリを起動するために必要なオブジェクトになります。 メソッドの書式は以下になります。 1val intent = packageManager.getLaunchIntentForPackage(&#34;com.example.app&#34;)\rメソッドでは、指定したパッケージ名（アプリ）に対して、アプリがユーザーによって起動可能な場合は起動用インテントを返し、起動できない場合はnullを返します。 インストール済みの起動可能なアプリを取得する 例えば、起動可能なアプリ一覧を取得したい場合、以下のようにメソッドを活用することができます。 1val pm = context.packageManager 2val apps = pm.getInstalledApplications(PackageManager.GET_META_DATA) 3 4val launchableApps = apps.filter { 5 pm.getLaunchIntentForPackage(it.packageName) != null 6} 7 8launchableApps.forEach { 9 val appName = pm.getApplicationLabel(it) 10 val packageName = it.packageName 11 Log.d(&#34;LaunchableApp&#34;, &#34;$appName ($packageName)&#34;) 12}\r上のようにすることで、起動可能なアプリ一覧を出力することができます。 今回はインストール済みの起動可能なアプリを取得する方法について紹介しました。以上で記事を終わりにします。 参考文献 PackageManager | Android Developers"},{url:"/dimzakki-mainroad/kintone-api-get-set-record/",title:"【kintone API】レコードの値の取得・変更時の注意点",date:"2025-04-12T00:00:00Z",body:"【kintone API】レコードの値の取得・変更時の注意点 kintone APIで、kintone.app.record.get()とkintone.app.record.set()を使用する時の注意点について書いていきます。 レコードの値の取得・変更 kintone APIには、レコードの値を取得するkintone.app.record.get()と、レコードの値を変更するkintone.app.record.set()があります。 主に、イベント外でレコード情報を取得・変更したいときに使用する関数になります。 関数を使う時の注意点 関数を使う時の注意点として、これらの関数は、kintone.events.onのイベントハンドラ内では実行することができません。イベントハンドラ内では、ハンドラに渡される引数のイベントオブジェクトを使用する必要があります。 以下の様に書いた場合、正常に動作しません。 1kintone.events.on(&#39;app.record.create.show&#39;, function(event) { 2 const record = kintone.app.record.get(); // 使えない 3 // ... 4});\rkintone.events.onのイベントハンドラ内では、以下の様に引数のeventオブジェクトでレコード情報を取得し、オブジェクトをreturnすることで更新ができます。 1kintone.events.on(&#39;app.record.create.show&#39;, function(event) { 2 const record = event.record; 3 // ... 4 return event; 5});\r関数の使いどころとしては、以下のように、ボタンを押下した時の処理に使用することができます。 1// ボタンを押したときにレコード情報を取得 2document.getElementById(&#39;my-button&#39;).addEventListener(&#39;click&#39;, function() { 3 const record = kintone.app.record.get(); 4 // ... 5});\r今回はkintone APIのkintone.app.record.get()とkintone.app.record.set()についてまとめました。以上で記事を終わりにします。 参考文献 レコードの値を取得する | cybozu developer network レコードに値をセットする | cybozu developer network"},{url:"/dimzakki-mainroad/android-room-primary-key/",title:"【Android】Roomの主キーを複数設定する方法",date:"2025-03-01T00:00:00Z",body:"【Android】Roomの主キーを複数設定する方法 KotlinでのAndroid開発でRoomの主キーを複数設定する方法について紹介します。 Roomで複合主キーを設定する RoomはAndroid Jetpackの一部であり、SQLiteを簡単に扱うためのライブラリです。 データベースのテーブルはEntityで定義します。 ここで、複合主キーを設定したい場合、@Entityアノテーションの引数で、primaryKeys = []に設定します。 Entity.㏏\r1import androidx.room.ColumnInfo 2import androidx.room.Entity 3 4@Entity(tableName = &#34;table&#34;, primaryKeys = [&#34;main_id&#34;, &#34;sub_id&#34;]) 5data class Entity( 6 @ColumnInfo(name = &#34;main_id&#34;) 7 val mainId: Int, 8 @ColumnInfo(name = &#34;sub_id&#34;) 9 val subId: Int, 10 val name: String 11)\r上のようにすることで、main_idとsub_idを主キーに設定できます。 今回はRoomの主キーを複数設定する方法について紹介しました。以上で記事を終わりにします。 参考文献 Entity | Android Developers"},{url:"/dimzakki-mainroad/android-translucent/",title:"【Android】背景が透明なアプリを作成する方法",date:"2025-02-27T00:00:00Z",body:"【Android】背景が透明なアプリを作成する方法 Androidアプリの開発時に、背景を透明にする方法について紹介します。 背景を透明にする方法 アプリの背景を透明にするには、アプリのテーマを定義するXMLファイルに、android:windowIsTranslucentとandroid:windowBackgroundを設定します。 themes.xml\r1&lt;item name=&#34;android:windowIsTranslucent&#34;&gt;true&lt;/item&gt; 2&lt;item name=&#34;android:windowBackground&#34;&gt;@android:color/transparent&lt;/item&gt;\randroid:windowIsTranslucentをtrueにすると背後が透けるUIになります。また、android:windowBackgroundに@android:color/transparentを設定することで、ウィンドウの背景色を透明にすることができます。 今回はAndroidアプリの背景を透明にする方法について紹介しました。以上で記事を終わりにします。 参考文献 windowIsTranslucent | Android Developers windowBackground | Android Developers"},{url:"/dimzakki-mainroad/qualification-db/",title:"【データベーススペシャリスト試験】合格体験記【約1か月で合格】",date:"2025-01-05T00:00:00Z",body:"【データベーススペシャリスト試験】合格体験記【約1か月で合格】 データベーススペシャリスト試験を2024年10月（令和6年度秋期試験）に受け合格しましたので、試験の対策・結果・感想などを合格体験記としてまとめたいと思います。 試験の概要 データベーススペシャリスト試験はIPA試験の中で最高難易度のレベル4に位置付けられる試験で、アルファベットでは「DB」とも略されます。出題範囲はデータベース分野に特化しています。 試験の内、午前Ⅰ試験は「応用情報に合格」「高度試験に合格」「高度試験の午前Ⅰで6割以上」のいずれかを満たしていると、2年間試験の免除が可能になります（受験申し込み時に試験免除も申請しないといけないので注意）。 その他、試験の細かい形式については、公式のページもご覧ください。 プロフィール・受験理由 具体的な試験対策に入る前に、簡単なプロフィールや、受験した理由などを紹介します。 プロフィール\r2021年からITエンジニアとして、主に業務系のシステム開発などに従事 基本的なSQL構文は扱えるレベル 高度区分は2022年に情報処理安全確保支援士試験に合格したことがあったので、さらに高度区分に挑戦してみたいというのが受験のきっかけです。 また、普段仕事でSQLを扱う事は多いのですが、DB設計についてはあまり経験が無く、知見を深められるかなと思いました。 試験の対策 次に、実際に行った試験対策についてです。 今試験では、支援士試験に合格した時の午前Ⅰ試験免除の権利はなくなってしまうので、まず下準備として、春に別の試験の午前Ⅰ試験だけを受験しておきました。 午前Ⅱ以降の対策に掛けた時間はトータルでは約1か月で40時間くらいだと思います。午前が10時間、午後が約30時間といった具合です。特に午後試験は時間が足りず難しい試験のため重点的に勉強しました。 午前試験の対策 午前Ⅰ試験は免除しているので午前Ⅱ試験の対策のみ行いました。午前Ⅱは4択の選択問題形式で、データベースに関する知識が求められます。 iパス～応用情報までの午前試験対策と同様、「過去問道場」で直近の過去5年分の過去問を勉強しました。午前対策はこれのみで多分大丈夫かなと思います。不安な人は10年分やってもいいかもしれません。 午後試験の対策 まず、午後試験の問題選択で、大きく論理設計と物理設計の2つがありますが、あらかじめどちらを選択するか決めておくと対策がしやすいです。私は論理設計をメインとして対策しました。個人的には論理設計がおすすめです。 理由としては、論理設計は出題パターンが大体決まっていて、過去問演習での対策がしやすいことです。他にも、後で詳しく記載しますが、論理設計特有の試験本番で使えるテクニックがあります。 午後試験の対策は、基本的には過去問演習になります。私は実際に直近の過去5年分の過去問を解きました。また、参考書の「情報処理教科書 データベーススペシャリスト」の過去問解説を利用しました。この参考書はかなり詳細に解説されているので。とてもおすすめな一冊です。 情報処理教科書 データベーススペシャリスト 2024年版\r3,278円～ amazon.co.jp また、午後は時間勝負な所もあるので、本番と同じ時間を測って解くのもおすすめです。論理設計は問題文に印をつけながら解く人が多いと思うので、印刷した方が良いでしょう。 試験当日 試験当日での注意としては、会場には早めに着く、昼食を用意しておく（会場付近は混むので）、受験票と筆記用具と時計は忘れないくらいでしょうか。 試験会場は、支援士試験を受けたときと同じ会場でした。受験者層は20～30代がボリュームゾーンかなと思いました。 午後試験で使えるテクニックとして、解答用紙に目を通しておくことが有用です。論理設計だと、解答用紙に概念データモデルが印刷されているので、解答用紙が配られてから試験が開始する前までの時間で確認しておけば、なんとなく問題の概要を掴むことができます。問題冊子を開くのはダメですが、解答用紙を見るのは問題ありません。 試験の手応えとしては、午前Ⅱは結構難しく感じました。勉強時間が若干足らなかったかもしれません。午後Ⅰはおそらく合格点はいったかなといった感じでした。午後Ⅱの出来は微妙で、合格は五分五分かな？といった感じでした。 午後Ⅱはの解答は一応埋められたのですが、時間に押されていて属性名の略称ルール（番号→#、単価→@など）の記載をちゃんと読めてませんでした。そのため解答の略語の書き換えがあまりできておらず、その部分で減点があるのかも不安要素でした。 試験結果 午後試験は時間が足りず解答をメモれなかったので、自己採点は午前Ⅱのみ行い午後はしませんでした。 合格発表日は2か月後と長いですが、発表日はそわそわしてしまいますね。試験結果は以下になります。 データベーススペシャリスト試験の結果 午前Ⅱ試験が64点、午後Ⅰ試験が90点、午後Ⅱ試験が72点で合格でした。受かってて良かったです。 午後Ⅰが思ったより良かったですね。午後Ⅱでは略語にできてなくても減点なしか-1点程度だったようです。 試験を受けた感想 感想としてましては、午後は論理設計をしっかり対策できていればそんなに難しい試験ではないかなと感じました。毎年の出題傾向もほぼ似たようなものなので、純粋にやった分だけ点数に繋がりやすいと思います。 本番では問題との相性の良し悪しやプレッシャーで力を発揮できない等もあるでしょうが、しっかり勉強して落ちても何回か受ければ合格できるような試験だと思います。 ただ、問題文も長くてしんどい試験なので、もう受けたくはありません…。 受験する方の参考になれば幸いです。以上で記事を終わりにします。 参考文献 データベーススペシャリスト試験 | IPA 独立行政法人 情報処理推進機構"},{url:"/dimzakki-mainroad/windows-forms-scale/",title:"【Visual Studio】Windowsフォームで画面スケールがおかしくなった時の対応",date:"2024-12-27T00:00:00Z",body:"【Visual Studio】Windowsフォームで画面スケールがおかしくなった時の対応 Visual Studioでの、Windowsフォームのスケールについての記事になります。 Windowsフォームのスケーリング Visual StudioでWindowsフォームを作成中に、「メインディスプレイのスケールは X% に設定されています。」といったメッセージがVisual Studio上部に表示されることがあります。 原因としては、高DPIのディスプレイでWindowsフォームデザイナーの画面を開くと出てくるようです。 その状態で「100% のスケールで Visual Studio を再起動します」を押下してしまうと、フォームのサイズが変わってしまうので気を付けましょう。自動でソースも書き換えられてしまうので、元に戻したい場合、変更前のソースから元に戻す必要があります。 以前、ソースを元に戻してもWindowsフォームデザイナーの画面が戻らない場合がありましたが、Windowsフォームデザイナーのプロパティの「AutoScaleMode」を「Dpi」にしてビルドすると元に戻りました。 今回はVisual StudioでのWindowsフォームのスケールついて紹介しました。以上で記事を終わりにします。 参考文献 メイン ディスプレイのスケーリングは X% に設定されています | Microsoft Learn"},{url:"/dimzakki-mainroad/java-mismatch-method/",title:"【Java】mismatchメソッドで2つの配列の違いを探す方法",date:"2024-12-13T00:00:00Z",body:"【Java】mismatchメソッドで2つの配列の違いを探す方法 JavaのArraysクラスのmismatchメソッドで2つの配列の違いを探す方法を紹介します。 mismatchメソッドの書式 mismatchメソッドは以下の様に記述します。 mismatchメソッドの書式例\r1Arrays.mismatch(Array a, Array b);\r配列aと配列bを比較して、最初に一致しなかった要素の添え字を戻します。一致した場合は‐1を返します。また、配列の添え字はint型なので、返り値の型もint型になります。 また、mismatchメソッドはequalsメソッドとは違い、違っている最初の箇所を戻してくれます。 引数がNULLの時はNullPointerExceptionの例外が発生します。 メソッドの使用例 使用例をサンプルコードによって紹介します。 MismatchTest1.java\r1import java.util.Arrays; 2 3public class MismatchTest1 { 4 5 public static void main(String[] args) { 6 7 int[] num1 = { 1, 2, 3, 4, 5, 6 }; 8 int[] num2 = { 1, 2, 3, 5, 4, 6 }; 9 int[] num3 = { 1, 2, 3, 4, 5, 6 }; 10 11 // num1,num2を比較する。添え字3の要素が違うので3が返される 12 System.out.println(Arrays.mismatch(num1, num2)); 13 14 // num1,num2を比較する。一致しているので-1が返される 15 System.out.println(Arrays.mismatch(num1, num3)); 16 } 17}\r実行結果が以下になります。 出力結果\r13 // { 1, 2, 3, 4, 5, 6 }と{ 1, 2, 3, 5, 4, 6 }の比較 2-1　// 同じ配列の比較\r配列の全ての要素を検索する このメソッドを普通に使うと最初に出てきた文字の位置しか返ってきません。そこでfor文を使って全ての文字を検索する方法を作ってみます。以下にサンプルコードを示します。 MismatchTest2.java\r1import java.util.Arrays; 2 3public class MismatchTest2 { 4 5 public static void main(String[] args) { 6 int[] num1 = { 1, 2, 3, 4, 5, 6 }; 7 int[] num2 = { 1, 2, 3, 5, 4, 6 }; 8 int[] num3 = Arrays.copyOf(num1, num1.length); 9 int[] num4 = Arrays.copyOf(num2, num2.length); 10 int index, sum = 0; 11 System.out.println(Arrays.toString(num3)); 12 System.out.println(Arrays.toString(num4)); 13 14 for (int i = 0; i &lt; num1.length; i++) { 15 index = Arrays.mismatch(num1, num2); 16 if (index != -1) { 17 System.out.println(sum + 1 + &#34;個目:&#34; + (index + 1)); 18 i = index; 19 sum++; 20 num1[i] = 0; 21 num2[i] = 0; 22 } 23 } 24 System.out.println(&#34;該当個数:&#34; + sum); 25 } 26}\r実行結果が以下になります。 出力結果\r1[1, 2, 3, 4, 5, 6] // 元の配列1 2[1, 2, 3, 5, 4, 6] // 元の配列2 31個目:4 42個目:5 5該当個数:2\r一応全ての要素を検索できるようになっていますが、元の配列の要素を変更しているため、出力後の配列num1とnum2の中身は最初と異なってしまいます。 よって、Arrays.copyOfメソッドを使って配列の要素をnum3とnum4にコピーしています。 今回はmismatchメソッドの使い方を紹介しました。以上で記事を終わりにします。 参考文献 Arrays (Java SE 9 &amp; JDK 9 )"},{url:"/dimzakki-mainroad/closedxml-image-property/",title:"【C#・VB】ClosedXMLでExcelに画像プロパティを指定する",date:"2024-11-30T00:00:00Z",body:"【C#・VB】ClosedXMLでExcelに画像プロパティを指定する C#・VBのライブラリであるClosedXMLで、Excelの画像のプロパティを指定する方法を紹介します。 関連記事\r【C#・VB】ClosedXMLでExcelに画像を埋め込む方法【余白・縮尺】 ClosedXMLでの画像の指定 Excelでは、画像（図形）の動作をセルに関連付けるプロパティで、画像がセルの移動やサイズ変更にどう反応するかを指定することができます。 ClosedXMLでは、そのプロパティをXLPicturePlacementで指定することができます。 C#でのサンプルコードは以下になります。 Program.cs\r1// 画像を貼り付ける 2IXLPicture image = ws.AddPicture(@&#34;C:\\test\\image.jpg&#34;); 3 4// 画像のプロパティを「セルに合わせて移動やサイズ変更をする」に指定する 5image.Placement = XLPicturePlacement.MoveAndSize; 6 7// 画像のプロパティを「セルに合わせて移動するがサイズ変更はしない」に指定する 8image.Placement = XLPicturePlacement.Move; 9 10// 画像のプロパティを「セルに合わせて移動やサイズ変更をしない」に指定する 11image.Placement = XLPicturePlacement.FreeFloating;\r「セルに合わせて移動やサイズ変更をする」を指定すれば、セルの動作に画像が連動し、フィルター使用時も画像を連動させることができます。 MoveAndSizeを指定する場合の注意点 MoveAndSize（セルに合わせて移動やサイズ変更をする）を指定する際、moveメソッドは以下の形式で指定する必要があります。以下はC#の例になります。 1image.MoveTo(IXLCell fromCell, Point fromOffset, IXLCell toCell, Point toOffset)\r異なる形式を使うと、エクセルの画像がおかしくなることがあるようです。 今回はClosedXMLでのExcelの画像のプロパティを指定する方法について紹介しました。以上で記事を終わりにします。 参考文献 Enum XLPicturePlacement | SlapKit.Excel Documentation ClosedXML .Placement property. | GitHub"},{url:"/dimzakki-mainroad/java-cbrt-method/",title:"【Java】cbrtメソッドで立方根を求める",date:"2024-10-31T00:00:00Z",body:"【Java】cbrtメソッドで立方根を求める JavaのMathクラスのcbrtメソッドで立方根を求める方法を紹介します。 なお、立方根とは数 \\(a\\) があるとき、3乗して \\(a\\) になるような数のことを指します。つまり \\(x^{3}=a\\) を満たす数 \\(x\\) が \\(a\\) の立方根になります。 cbrtメソッドの書式 メソッドの書式は以下になります。 cbrtメソッドの書式\r1Math.cbrt(double a); 2Math.cbrt(8); // 2が返る\r引数の立方根が返ってきます。戻り値の型はdouble型になります。 正の無限大の時は正の無限大がそのまま返されます。また、引数が負の数値である場合はNaN（Not a Number/非数）を返します（NaNが引数の時も同様です）。 似た機能を持つメソッドに、平方根を計算するsqrtメソッドがあるので注意しましょう。 関連記事\r【Java】sqrtメソッドで平方根（ルート√）を求める方法 メソッドの使用例 メソッドの使用例をサンプルコードで示します。 CbrtTest.java\r1public class CbrtTest { 2 public static void main(String[] args) { 3 System.out.println(&#34;8の立方根:&#34; + Math.cbrt(8)); 4 System.out.println(&#34;27.0の立方根:&#34; + Math.cbrt(27.0)); 5 System.out.println(&#34;10の立方根:&#34; + Math.cbrt(10)); 6 System.out.println(&#34;-1の立方根:&#34; + Math.cbrt(-1)); 7 System.out.println(&#34;0の立方根:&#34; + Math.cbrt(0)); 8 System.out.println(&#34;正の無限大の立方根:&#34; + Math.cbrt(Double.POSITIVE_INFINITY)); 9 System.out.println(&#34;NaNの立方根:&#34; + Math.cbrt(Double.NaN)); 10 } 11}\r実行結果が以下になります。 出力結果\r18の立方根:1.5874010519681996 227.0の立方根:3.0 310の立方根:2.154434690031884 4-1の立方根:-1.0 50の立方根:0.0 6正の無限大の立方根:Infinity 7NaNの立方根:NaN\rそれぞれの数字の立方根が、double型で出力されていることが分かります。 今回はcbrtメソッドの使い方を紹介してました。以上で記事を終わりにします。 参考文献 Math (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/java-join/",title:"【Java】joinメソッドで文字列を配列に分割する",date:"2024-09-28T00:00:00Z",body:"【Java】joinメソッドで文字列を配列に分割する Javaのjoinメソッドを使って、文字列を結合する方法をまとめます。 joinメソッドの書式 メソッドは以下のように記述します。 joinメソッドの書式例\r1String.join(デリミタ, 文字列1, 文字列2);\r第1引数をデリミタになり、第2引数以降をデリミタで結合します。デリミタとは、要素と要素の区切りとなる文字のことです。 引数がNULLの時はNullPointerExceptionの例外が発生します。 toCharArrayメソッドの使用例 メソッドの使用例をサンプルコードで示します。 JoinTest.java\r1public class JoinTest { 2 public static void main(String[] args) { 3 String str = String.join(&#34;,&#34;, &#34;a&#34;, &#34;b&#34;, &#34;c&#34;); 4 System.out.println(str); 5 } 6}\r出力結果\r1a,b,c\r,をデリミタとして、a・b・cが結合されていることが分かります。 今回はJavaのjoinメソッドについて紹介しました。以上で記事を終わりにします。 参考文献 String (Java Platform SE 8 )"},{url:"/dimzakki-mainroad/qualification-oraclemastersilverdba/",title:"【Oracle Silver DBA】合格体験記【約2か月で合格した勉強方法】",date:"2024-08-23T00:00:00Z",body:"【Oracle Silver DBA】合格体験記【約2か月で合格した勉強方法】 Oracle MASTER Silver DBA（1Z0-082-JPN）を2024年8月に受け合格しましたので、試験の対策・結果・感想などを合格体験記としてまとめたいと思います。 試験概要 「Oracle MASTER Silver DBA」はOracleの資格の1つであり、OracleとSQLの知識が問われる試験です。 項目 詳細 出題形式 選択問題・CBT方式 出題数 72問 試験時間 120分 合格点 正答率60%以上 受験料 税込37,730円（2024/08/23時点）\rベンダー資格特有ですが、受験料は35,000円以上と高額です。また、受験に必要な前提資格はありませんので、下位区分のBronzeを持っていなくても受験することが可能です。 試験申し込み・試験対策 実際に受験することを決めてから試験本番までの流れを書いていきます。 プロフィール\r開発系のITエンジニア（3年目） Oracleの使用経験有り（1年程度） 「Oracle MASTER Silver SQL」に合格済み（2023年3月） 受験のきっかけ・申し込み 受験のきっかけとしては、「Oracle Gold DBA」を受験してみたいと思ったことになります。Goldの受験には「Oracle Silver DBA」の合格が必要になります。 「Oracle Silver SQL」の方は、1年以上前とはいえ合格していたので、気楽に受験してみようかと思い立ちました。 関連記事\r【Oracle Silver SQL】合格体験記【約3か月で合格した方法】 試験の申し込みについては、始めて受ける人はアカウント登録等が少し複雑ですが、別の記事で申し込み方法も簡単にまとめていますので、参考にしてみてください。 テストセンターのキャパにもよりますが、予約は1ヶ月くらい前だと土日が空いていましたので、早めにやっておくといいと思います。 受験料支払いは、楽天でチケットを買うと試験代が浮くので、結構ありがたいです。 【ピアソンVUE専用】OracleピアソンVUE配信監督付き試験用受験チケット(電子チケット)\r38,995円～ rakuten.co.jp 試験の申し込みについてはこちらの記事にまとめてあります。 関連記事\r【ORACLE MASTER】試験の申し込みを格安で行う方法【OCJ-P】 また、Oracleの再受験無料キャンペーンが毎年行われているので、それを利用するのも手ですね。 試験勉強 試験勉強は、主に黒本と呼ばれる参考書「オラクルマスター教科書 Silver DBA Oracle Database Administration I」を使って勉強しました。 オラクルマスター教科書 Silver DBA Oracle Database Administration I\r5,500円～ amazon.co.jp 黒本は試験問題に近い形式の問題とその解説がテーマごとにまとまっている問題集になっています。大きく分けてDBA編とSQL編で構成されています。 SQL編の内容に関しては大体理解していましたので、DBA編の内容を重点的に学習しました。特に、DBA編ではOracleに関する知識の暗記がメインになります。私は暗記が苦手なので、結構キツい勉強になりました…。 掛けた勉強時間は、1日あたり1時間くらいで、トータルで約2か月で60時間くらいだと思います。 試験本番 実際の試験は、地元のテストセンターで受験しました。受付の際は身分証明書が2点必要なので、忘れないよう注意しましょう。 試験会場には予定時間の10時より30分以上早く着いたのですが、受付後すぐに受験させてもらいました。 試験は黒本で勉強した内容が大体聞かれました。DBAの出来があまり良くないかなとは思いましたが、試験時間も見直しを含め1時間程度余らして退出しました。 試験結果 試験結果（スコアレポート）は試験終了のボタンを押してすぐPCの画面に出ます。終了時に紙でも貰いました。 また、CertViewのサイトでも同じ物をダウンロードすることができます。スコアレポートは以下になります。 Oracle MASTER Silver DBAの試験結果 正解率70%で合格でした。まあ可もなく不可もなくといった感じでした。やはり、DBAの正答率が良くなかったようです。 試験を受けた感想 試験を受けた感想として、やはりDBA部分の暗記が大事だなと感じました。 SQLについては業務で触っていればなんとなく知っている知識でなんとかなる印象ですが、DBAはOracleの管理者としての知識が必要で、余り経験がないこともあり、暗記も中々捗りませんでした。 試験の難易度としては、未経験者でも暗記が得意な人にとってはそれ程難しい試験ではないかと思います。 黒本の内容をしっかりインプットできれば、受かることができる試験ですので、これから受験予定の方は参考にしてみてください。 以上で記事を終わりにします。 参考文献 Oracle Database DBA | Oracle University"},{url:"/dimzakki-mainroad/dbms-debug-vc2coll/",title:"【SQL】DBMS_DEBUG_VC2COLLの使い方【Oracle】",date:"2024-07-19T00:00:00Z",body:"【SQL】DBMS_DEBUG_VC2COLLの使い方【Oracle】 Oracle SQLでDBMS_DEBUG_VC2COLLの使い方を紹介します。 DBMS_DEBUG_VC2COLLとは DBMS_DEBUG_VC2COLLは、Oracleで使用されるPL/SQLパッケージの1つになります。 DBMS_DEBUG_VC2COLLでVARCHAR2型のデータのコレクションを管理でき、データの表示や処理を行うことができます。 DBMS_DEBUG_VC2COLLの使用例 例として、「a」「b」の文字列をDBMS_DEBUG_VC2COLLに格納し、TABLE関数でコレクションを行形式で表示してみます。 test1.sql\r1SELECT COLUMN_VALUE FROM TABLE(SYS.DBMS_DEBUG_VC2COLL(&#39;a&#39;, &#39;b&#39;))\r実行結果\r1COLUMN_VALUE 2a 3b\r「a」「b」が行形式で表示されました。ここで、COLUMN_VALUEはコレクションの各要素を表示するための疑似列です。 また、COLUMN_VALUEの取得結果にファンクションを使用することができます。一例で、REPLACE関数で「b」を「a」を変換してみます。 test2.sql\r1SELECT REPLACE(COLUMN_VALUE, &#39;b&#39;, &#39;a&#39;) FROM TABLE(SYS.DBMS_DEBUG_VC2COLL(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))\r実行結果\r1COLUMN_VALUE 2a 3a 4c\r「b」が「a」に変換されているのが分かります。 今回はDBMS_DEBUG_VC2COLLの使い方について紹介しました。以上で記事を終わりにします。 参考文献 58 DBMS_DEBUG | Oracle"},{url:"/dimzakki-mainroad/product-review-logicool-k380/",title:"【無線キーボード】Logicool K380をレビュー【マルチデバイス対応】",date:"2024-06-24T00:00:00Z",body:"【無線キーボード】Logicool K380をレビュー【マルチデバイス対応】 無線キーボードのLogicool K380の商品レビューを行っていきます。商品の特徴や、実際に使った感想についてまとめます。 また、スクリーンショットのショートカットが効かない問題の対処方法などについても記載しました。 購入したきっかけ 元々、私はノートパソコンを使っていて、ブログを書くときなどはノートパソコンで執筆していました。しかし、机の上があまり広くないので、パソコンを置いていると机上のスペースが占領されてしまうんですよね。そこで、ノートパソコンを閉じておいて、画面はモニターに出力して使おうと思いました（こういう使い方をクラムシェルモードと呼びます）。 ノートパソコンを閉じて使うために、別にキーボードを買う必要があります。選んだ基準は以下の通りでした。 選定基準\r無線接続（Bluetooth接続）が可能なもの 複数デバイスに接続可能なもの なるべくサイズがコンパクトなもの そんな中で購入した無線キーボードが「ロジクール ワイヤレスキーボード K380」でした。 ロジクール ワイヤレスキーボード 無線 キーボード 薄型 小型 K380BK Bluetoothワイヤレス Windows Mac iOS Android Chrome K380 国内正規品\ramazon.co.jp 複数デバイスに接続可能なものを選んだのは、テレワークを行う場合にも追加で接続できたら便利そうだと思ったからです。色はブラックを買いました。 基本的な仕様 主な仕様を以下に示します。 仕様 詳細 デザイン パンダグラフ サイズ（幅×奥行×高さ） 279mm × 124mm × 16 mm 重量（電池込） 423g キーピッチ 18mm キーストローク 1.5mm 使用電池 単4電池 × 2 （寿命:最大2年） 接続方式 Bluetooth 3.0 最大3台のデバイスに同時にBluetooth接続が可能です。F1～F3キーが切り替えボタンになっており、そちらで登録済みの接続先デバイスを切り替えることができます。 実際に使用した感想 項目 評価 総合得点 ★★★★☆ 打鍵感 ★★★★☆ 接続面 ★★★★☆ バッテリー ★★★★☆ 取り回し ★★★☆☆ 使っているK380をサイズ比較用のボールペンと一緒にした画像を下に載せます。もう一年以上使用しているため、ちょっと汚れてます…。 Logicool K380の外観画像 K380はコンパクトなサイズ、キーボードの形も丸くなっています。コンパクト化のためにテンキーはないです。重さは400g超と、とても軽いという訳では無いですが、持ち運びは十分可能です。500mlペットボトルよりは軽いくらい。薄さは一番厚いところで16mmになっており、少し傾斜がついています。 タイピング時の打鍵感は、丸いキー独特の癖を感じるかもしれませんが、慣れれば違和感は感じません。むしろノーパソのキーボードよりしっかり押している感があって使いやすいと感じていますね。電池の節電のためか使ってない時は自動でスリープモードに入るので、スリープ復帰時にちょっとラグが入るくらいでブログの執筆時は快適に使えています。 バッテリー面は電源スイッチを入れっぱなしでも1年以上持っています。 実際に2台接続して使った時の使用感 テレワークで仕事用PC・私用PCの2台を家で使ってみました。どちらも1つのモニターに接続して使ってます。実際にこのキーボードで2台を切り替えて使っている分には、特に問題もなく便利ですね。机の上の省スペースになりました。 最初に仕事用のPCにこのキーボードをペアリングする際に中々上手くいかなかったのですが、接続しない方のBluetoothを切っておくとペアリングしやすいです。 ファンクションキーを設定を変える方法 K380はデフォルト設定だとファンクションキーにホットキー・メディアキー（主に設定を切り替えるキー）が割り当てられています。ファンクションキー自体を使用したい場合、fnキーと同時押ししないといけなくて若干面倒です。 こちらは「Logicool Options」をインストールして設定を変えることで通常のファンクションキーを優先させることができます。 No image found 画像左下の部分にチェックを入れるとデフォルトがファンクションキー優先になります。 スクリーンショットのショートカットが効かない問題について ※2023年現在、下記の問題はいつの間にか治っていました…。 K380はサイズも小さめで使いやすく全体的には満足しているのですが、一つだけ問題がありました。スクリーンショットのショートカットが反応しないことです。 調べると公式サイトの「FAQ - K380 Multi-Device Bluetooth Keyboard | Logicool サポート」のショートカット一覧によるとfn + tabで撮れるらしいのですが、私の場合は何故か反応しませんでした。tabキー・fnキーは個別でちゃんと動作しているので、公式の通りなら撮れるはずなんですが…。 一応、Windowsショートカットのスタート + shift + Sでも撮影することが可能です。これでスクショは撮れますが、いちいち画像を保存する必要があるので少し面倒臭いです…。 「Logicool Options」でショートカットを設定する方法 もしかしたら同じ症状で困っている人がいるかもしれないので忘備録として。上でも紹介した「Logicool Options」からスクショのショートカットを追加することが可能です。 No image found F4～F7のキーの機能を設定できるので、どれか好きなキーで「プリントスクリーン」を選択しましょう。私はF4に設定しました。そうするとfn + F4がPrintScreenキーに設定されます。そうすることでWindowsキー + fn + F4によりスクリーンショットを撮れます。（Windowsキー +　PrintScreenキーがスクショのショートカットのため）とりあえず応急処置にはなります。 ここまで「Logicool K380」の商品レビューを行いました。スクショを撮りたい時にfn + tab効かないことで少し設定に手間取りました。コスパ含めその他の機能面は優秀なので、総合点は星4（★★★★☆）を付けたいと思います。 もう1年以上使っていて、基本的な性能には満足しているので、特段の理由が無ければ壊れて使えなくなるまで使い続けようと思います！複数デバイスでBluetooth接続したい方にはおすすめなキーボードでした。 また、新しいモデルの「K380s」も販売されていますので、そちらもチェックするといいかもしれません。 ロジクール ワイヤレスキーボード PEBBLE KEYS 2 K380sGR 薄型 軽量 415g 小型 Bluetooth Logi Bolt ワイヤレス 無線 キーボード Easy-Switch 日本語配列 電池寿命36ケ月 Windows Mac iPad iOS Android Chrome K380s グラファイト 国内正規品\r4,800円～ amazon.co.jp また、マウスについても、テレワーク用にマルチデバイス対応の以下の商品を使っています。切り替えがスイッチ式なので簡単です。 エレコム マウス ワイヤレスマウス Bluetooth EX-G 握りの極み 静音設計 5ボタン マルチペアリング Mサイズ ガンメタリック M-XGM15BBSGM/EC\r2,499円～ amazon.co.jp 参考にしていただければ幸いです。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/qualification-javagold-se11/",title:"【Java Gold】合格体験記【約3か月で合格した勉強方法】",date:"2024-06-08T00:00:00Z",body:"【Java Gold】合格体験記【約3か月で合格した勉強方法】 Oracle Certified Java Programmer Gold SE 11 認定資格（Java Gold）を2024年5月に受け合格しましたので、試験の対策・結果・感想などを合格体験記としてまとめたいと思います。 試験概要 まず、試験について軽く紹介します。 Java Gold試験はOracle社が提供しているベンダー資格「Oracle Certified Java Programmer」の１つであり、3段階のレベル（Bronze・Silver・Gold）の最上位の難易度の試験になっています。 公式によると、試験では「独力で実装が行える中上級者程度」のレベルの知識が求められます。ちなみに、合格率は公表されていません。 項目 詳細 出題形式 選択問題・CBT方式 出題数 80問 試験時間 180分 合格点 正答率63％以上 受験料 税込37,730円（2024/08/23時点）\r試験にはバージョンがあり、今回受験したのはSE11になります。なお、SE11の受験資格にはSilver試験の合格が必要です。 受験料については、若干の変動はありますが35,000円以上と中々の高額です。 受験のきっかけと申し込み 私のITエンジニアとしての開発の実務経験は2年半といったところで、Javaの経験は2年程あります。Java Silver SE11を2021年に取得しています。 関連記事\r【Java Silver】合格体験記【約100時間で合格した勉強方法】 Javaを勉強して間もない頃にJava Silverを取得した時から、いつかはGoldを取得したいと思っていました（Silver止まりはなんだか中途半端に思えたので）。それ以降、なんだかんだ手は付けていなかったのですが、そろそろ挑戦してみるかと決心を固め、会社の方で資格取得を今期の目標に設定することで半強制的に勉強を始めることにしました。 申し込みはテストセンターの土日が中々空いていないこともあり、1ヶ月以上前には予約していました。受験料は、楽天でチケットを買って申し込みしました。 【ピアソンVUE専用】OracleピアソンVUE配信監督付き試験用受験チケット(電子チケット)\r38,995円～ rakuten.co.jp 楽天のチケットは受験料が割引になるので助かります。試験の申し込みについてはこちらの記事にまとめてあります。 関連記事\r【ORACLE MASTER】試験の申し込みを格安で行う方法【OCJ-P】 試験勉強でやったこと 試験勉強は参考書のみで行いました。いわゆる「黒本」と言われる参考書を購入し、4～5周程ひたすら周回しました。 総勉強時間は3か月で計100～150時間前後と言ったとこでしょうか。Java Silverの時は勉強不足でギリギリの合格だったので、今回はより勉強量を増やしました。 また、対象バージョンがSE8と古いものの、公式のサンプル問題がありましたのでそちらも勉強しました。 1Z0_810_813_サンプル問題 | Oracle 1Z0-809 サンプル問題 | Oracle 受験した5月は、業務の関係で電車で1時間以上掛かる現場に出社していて、電車で座れたので行き帰りの時間で参考書を開いて勉強していました。 試験本番 実際の試験は、5月下旬の土曜日に地元のテストセンターで受験しました。テストセンターは他の試験で何回か訪れていた場所でした。受付の際は身分証明書が2点必要なので、最低それだけは持っていきましょう。 試験会場には30分くらい早く着いたのですが、受付後すぐに受験させてもらいました。 本番直前までは、運悪く仕事が遠い現場に出社と残業続きになってしまったこともあり、合格できるかどうか不安でした。しかし、試験内容は勉強した物と似たような問題が多かったので、自信を持って解答することができました。試験時間も見直しを含め1時間以上余りました。 そういえば、試験中に席の後ろの人がゴホゴホと大きな咳をずっとしていて、あまり集中できていなかったかもしれません…。 試験結果 試験結果（スコアレポート）は試験終了のボタンを押してすぐPCの画面に出ます。終了時に紙でも貰いました。 また、CertViewのサイトでも同じ物をダウンロードすることができます。スコアレポートは以下になります。 Java Goldの試験結果 正解率80%で合格でした。Java Silverの時とは違って、余裕を持って合格できたのでほっとしました。 試験の難易度と対策について まず、試験の難易度について、Java Silverレベルの知識があるのを前提として考えてみました。 恐らく、完全未経験の人だと若干ハードルが高いです。しかし、達成困難であるかと言われるとそうではなく、勉強量次第かなと思います。 経験者の場合は、Javaでの開発経験が1年くらいある人には挑戦して丁度いいレベルかなと感じました。普段業務で使っているレベルだと、難関資格だと身構え過ぎなくても良さそうです。 次に、試験対策についてです。Java Gold合格には参考書の問題演習が一番だと思います。有名どころな参考書は黒本・紫本等があります。 私は黒本と呼ばれる「徹底攻略Java SE 11 Gold問題集[1Z0-816]対応」と公式サンプル問題のみ勉強しました。黒本のコードを実機で動かしたりは特にしませんでした。 徹底攻略Java SE 11 Gold問題集[1Z0-816]対応\r4,400円～ amazon.co.jp 黒本は試験問題に近い形式の問題とその解説をテーマごとにまとめた問題集になっています。試験本番でも黒本で解いた問題が出題されていたので、黒本をやり込むことが合格への近道でしょう。 黒本の使い方ですが、基本的にはどんどん問題を解いていきましょう。解説もしっかり読んで理解することが重要です。第2章の「関数型インタフェースとラムダ式」と第4章の「ストリームAPI」の内容が試験では問われてきますので重点的に学習しましょう。黒本に出てくる関数型インターフェイスの仕様は暗記するレベルにやった方が良いと思います。 私の場合、最終的に黒本の正答率が9割くらいになっていたと思います。 公式のサンプル問題も、関数型インタフェースとラムダ式、ストリームAPIの問題については勉強しておいて損は無いでしょう。日付API関連の問題については、SE11の範囲対象外なので勉強する必要はありません。 その他の参考書については、使用していないので内容については分かりませんが、黒本のみでも十分合格できると思います。 今回はJava Goldの合格体験記をまとめました。基本的には黒本の内容を理解していれば合格することは難しくないでしょう。 Java Silverは重箱の隅をつつく様な意地悪な問題が多かった印象がありましたが、Java Goldはちゃんと仕組みを理解できているかといった感じで、個人的にはこちらの方がやりやすかったです。また、より実務に直結した内容も多く、勉強になりました。 試験を受ける方の参考になれば幸いです。以上で記事を終わりにします。 参考文献 Java SE 11 Programmer II (1Z0-816-JPN) 試験 | Oracle University"},{url:"/dimzakki-mainroad/subversion-checksum-mismatch/",title:"【SVN】更新時に「Checksum mismatch～」となるエラーを解決する",date:"2024-05-26T00:00:00Z",body:"【SVN】更新時に「Checksum mismatch～」となるエラーを解決する SVN（Subversion）で更新時にChecksum mismatch～のエラーが出る問題の対処方法をまとめます。 リポジトリ更新時に「Checksum mismatch～」のエラーが出る 使用クライアントは「TortoiseSVN」になります。 この前の話ですが、SVNで管理していたリポジトリを更新した時に、Checksum mismatch～とエラーになり更新ができませんでした。 しばらく触っておらず、久しぶりに更新したリポジトリだったのですが、クリーンアップしてから再度試してみてもダメ、ファイルやフォルダを削除して更新してもダメでした。 どうやら、リポジトリと作業フォルダとでチェックサムに差異があるとエラーになるようです。 エラーの解決方法 リポジトリの更新が失敗し、クリーンアップも失敗する場合は、.svnフォルダ自体を差し替えることで治る場合があります。 エラーになるリポジトリと同じものを、新しく別の場所にチェックアウトする チェックアウトしてきた.svnフォルダをエラーになるフォルダへ差し替える 再度、リポジトリの更新を行う 私は以上の手順でエラーが解消されました。チェックアウトし直したので、少し時間が掛かりましたが…。 単にクリーンアップだけだと上手くいかない場合は試してみてください。Stack Overflowだと上記以外の方法もいくつか出ていたので、参考として載せておきます。以上で記事を終わりにします。 参考文献 SVN - Checksum mismatch while updating | Stack Overflow"},{url:"/dimzakki-mainroad/googlecalendar-end-of-month/",title:"【Googleカレンダー】月末日の繰り返しタスクを追加する",date:"2024-04-13T00:00:00Z",body:"【Googleカレンダー】月末日の繰り返しタスクを追加する Googleカレンダーで月末の繰り返しタスクをGoogle ToDoリストを活用して追加する方法を紹介します。 月末のタスクを設定する方法 Googleカレンダーの予定の繰り返し設定では、毎週・毎月等の設定が可能で便利ですが、何故か月末日の繰り返しができない仕様となっています。Googleカレンダーで予定を「31日」に設定すると、31日が存在しない月はイベントを表示してくれません。 Googleカレンダーの予定の繰り返し設定 毎月の月末に予定を入れたい人にとっては、地味に面倒な問題ですね。ネットでは、この問題に対してはicsファイルを変更して対応するというやり方がよく紹介されています。 今回は異なるアプローチとして、Google ToDoリストからタスクを設定してみます。正確には予定ではなくタスクを設定しているので、カレンダーの予定とは若干異なるものではありますが、リマインダーとしては使えるかと思います。 Google ToDoリストとはタスクの作成・管理アプリで、Googleカレンダーと連携が可能です。マイカレンダーで「ToDoリスト」のチェックボックスをオンにする必要があります。 手順としては簡単で、「Google ToDoリスト」からタスクを作成し、以下の通りに設定すればOKです。 繰り返し設定：「カスタム」 繰り返す間隔：「1か月ごと」「末日」 月末にタスク設定1 月末にタスク設定2 Googleカレンダーを確認すると、毎月の月末にタスクが設定されていることが分かります。 月末にタスク設定3 月末にタスク設定4 ポイントとしましては、Googleカレンダーから直接タスクを追加するやり方だと末日を設定することができなかったので、Google ToDoリストのアプリからタスクを追加する必要がありそうです。 今回はGoogleカレンダーで月末の繰り返しのタスクを設定する方法について紹介しました。 参考になれば幸いです。以上で記事を終わりにします。 参考文献 Google ToDo リストと Google カレンダーで繰り返すタスクを管理する | Google カレンダー ヘルプ"},{url:"/dimzakki-mainroad/hugo-docker/",title:"【Hugo】Docker上でHugo環境を構築する【Compose Watch】",date:"2024-03-10T00:00:00Z",body:"【Hugo】Docker上でHugo環境を構築する【Compose Watch】 Hugo環境をDocker上で構築・実行する手順についてまとめます。 関連記事\r【Hugo】ローカルにサイト（Mainroadテーマ）を構築する【サイト構築①】 HugoにDockerを使うメリット HugoにDockerを使うメリットとしては、主に以下があります。 hugo.exeのダウンロードや環境変数の設定が不要 どこでも同じ環境（バージョン）を再現できる ただし、起動がやや重く、Dockerのイメージサイズも大きいため、個人のブログ執筆のような小規模でやる場合だとあまり恩恵は受けられないかなと思います。 構築手順 Docker自体の環境構築についてはここでは割愛します。 Hugoのフォルダ内でDockerfileとcompose.ymlを配置します。Dockerイメージは公式が出しているものがありませんので、今回はサードパーティー製の「hugomods」を使います。 それぞれファイルを以下の通りにします。Hugoのバージョンは最新にします。 Dockerfile\r1FROM hugomods/hugo:latest 2 3COPY . /src/ 4 5EXPOSE 1313 6 7ENTRYPOINT [&#34;hugo&#34;, &#34;server&#34;, &#34;--bind&#34;, &#34;0.0.0.0&#34;, &#34;--port&#34;, &#34;1313&#34;, &#34;-D&#34;, &#34;-F&#34;]``` 8 9```yml {lineNos=&#34;inline&#34;, name=&#34;compose.yml&#34;} 10services: 11 hugo: 12 build: . 13 ports: 14 - &#34;1313:1313&#34; 15 develop: 16 watch: 17 - action: sync 18 path: . 19 target: /src\rコンテナ起動時は、ターミナルで以下のコマンドを実行します。ホットリロード機能を実現するためにCompose Watchを利用しています。 ターミナル\r1$ docker compose up -d # コンテナ起動 2 3$ docker compose watch # ホットリロード\rローカルでの構築時と同様に、http://localhost:1313/を開くことでサイトプレビューを確認できます。 新規記事を作成する際は以下のコマンドを実行します。 ターミナル\r1$ docker compose exec hugo hugo new &lt;file名&gt; # コンテナ内に新規ファイル作成 2 3$ docker compose cp hugo:/src/content/&lt;file名&gt; . # コンテナからローカルにコピー\r今回は、Dockerでブログを構築する方法について紹介しました。ローカルにはブログのソースのみ置けば良いというのがDockerの利点ですね。以上で記事を終わりにします。 参考文献 Use Compose Watch | Docker Docs Rerender on file change in Docker setup - support - HUGO"},{url:"/dimzakki-mainroad/closedxml-image/",title:"【C#・VB】ClosedXMLでExcelに画像を埋め込む方法【余白・縮尺】",date:"2024-02-18T00:00:00Z",body:"【C#・VB】ClosedXMLでExcelに画像を埋め込む方法【余白・縮尺】 C#・VBのライブラリであるClosedXMLでExcelに画像を埋め込む方法と、画像の位置をセル内で調整する方法、画像の縮尺を調整する方法を紹介します。 関連記事\r【C#・VB】ClosedXMLでExcelに画像プロパティを指定する ClosedXMLでの画像の貼り付け ClosedXMLはExcelがインストールされていない環境でExcelファイルを操作できるライブラリです。まず、ClosedXMLを使うには、ClosedXMLライブラリの追加と、プログラム行頭のusingの記述が必要になります。 1using ClosedXML.Excel; 2using ClosedXML.Excel.Drawings;\rClosedXMLでの画像の貼り付けには、AddPictureメソッドを使います。例として、ExcelファイルのA2セルに画像を貼り付けるサンプルコードを紹介します。 C#でのサンプルコードは以下になります。 Program.cs\r1using ClosedXML.Excel; 2using ClosedXML.Excel.Drawings; 3 4class Program 5{ 6 static void Main(string[] args) 7 { 8 using (XLWorkbook wb = new XLWorkbook()){ 9 // ワークシートの設定 10 IXLWorksheet ws = wb.AddWorksheet(&#34;Sheet1&#34;); 11 12 // AddPictureメソッドで画像を貼り付け 13 IXLPicture image = ws.AddPicture(@&#34;test.png&#34;); 14 15 // 画像の位置をB2セルの左上に移動 16 image.MoveTo(ws.Cell(2, 2)); 17 18 // ワークブックを保存 19 wb.SaveAs(@&#34;excel.xlsx&#34;); 20 } 21 } 22} コードを実行し、作成したエクセルのスクリーンショットになります。 No image found 画像の位置をセル内で調整する方法 上記のサンプルコードではMoveToメソッドでセルを指定しており、セルの左上に合うように画像が移動されます。セル内で余白を持たせたい場合、引数を追加しxとyの余白をポイント単位で指定します。 C#でのサンプルコードは以下になります。 1IXLPicture image = ws.AddPicture(@&#34;C:\\test\\image.jpg&#34;); 2 3// 画像を右・下に10ポイントずつずらす 4image.MoveTo(ws.Cell(2, 2), 10, 10);\rNo image found 最初と比べ、画像の位置が微妙に変化したことが分かります。 画像の縮尺を調整する方法 画像の縮尺を調整したい場合は、Scaleメソッドを使います。引数に倍率を指定します。高さと幅を別々に調整したい場合は、それぞれScaleHeightメソッドとScaleWidthメソッドを使います。 C#でのサンプルコードは以下になります。 1IXLPicture image = ws.AddPicture(@&#34;C:\\test\\image.jpg&#34;); 2 3// 画像を等倍で0.5倍にする 4image.Scale(0.5); 5 6// 画像の高さを2倍にする 7image.ScaleHeight(2); 8 9// 画像の幅を2倍にする 10image.ScaleWidth(2);\rNo image found 等倍で0.5倍とすると、画像が小さくなったことが分かります。 VBの場合 VisualBasicの場合では、以下のようになります。 まず、画像の貼り付けのコードです。 Program.vb\r1Imports ClosedXML.Excel 2Imports ClosedXML.Excel.Drawings 3 4Class Program 5 Private Shared Sub Main(ByVal args As String()) 6 Using wb As XLWorkbook = New XLWorkbook() 7 &#39; ワークシートの設定 8 Dim ws As IXLWorksheet = wb.AddWorksheet(&#34;Sheet1&#34;) 9 &#39; AddPictureメソッドで画像を貼り付け 10 Dim image As IXLPicture = ws.AddPicture(&#34;test.png&#34;) 11 &#39; 画像の位置をB2セルの左上に移動 12 image.MoveTo(ws.Cell(2, 2)) 13 &#39; ワークブックを保存 14 wb.SaveAs(&#34;excel.xlsx&#34;) 15 End Using 16 End Sub 17End Class\r次に、画像の位置をセル内で調整するコードになります。 1Dim image As IXLPicture = ws.AddPicture(&#34;C:\\test\\image.jpg&#34;) 2 3&#39; 画像を右・下に10ポイントずつずらす 4image.MoveTo(ws.Cell(2, 2), 10, 10)\r次に、画像の縮尺を調整するコードになります。 1Dim image As IXLPicture = ws.AddPicture(&#34;C:\\test\\image.jpg&#34;) 2 3&#39; 画像を等倍で0.5倍にする 4image.Scale(0.5) 5 6&#39; 画像の高さを2倍にする 7image.ScaleHeight(2) 8 9&#39; 画像の幅を2倍にする 10image.ScaleWidth(2)\r今回はClosedXMLでのExcelの画像埋め込みについて紹介しました。以上で記事を終わりにします。 参考文献 ClosedXML.Excel.Drawings.XLPicture.MoveTo(IXLAddress, System.Drawing.Point) Example | CSharpCodi ClosedXML.Excel.Drawings.XLPicture.ScaleHeight(double, bool) Example | CSharpCodi ClosedXML.Excel.Drawings.XLPicture.ScaleHeight(double, bool) Example | CSharpCodi"},{url:"/dimzakki-mainroad/hugo-ranking/",title:"【Hugo】PV数の人気記事のランキングを取得する【Node.js】",date:"2024-01-03T00:00:00Z",body:"【Hugo】PV数の人気記事のランキングを取得する【Node.js】 HugoとGoogle Analyticsで各記事のPV数のランキングをNode.jsで取得する方法を紹介します。 なお、Node.jsはDockerで動かす想定です。 関連記事\r【Hugo】WordPressブログをHugo・AWSに移行した Google Analytics Data APIの設定 まず、各記事のPV数を取得するためにGoogle Analytics Data APIを設定していきます。GCPにログインし、APIライブラリからAPIを有効にします。 Google Analytics Data APIの設定1 Google Analytics Data APIの設定2 次に、サービスアカウントを作成していきます。 Google Analytics Data APIの設定3 Google Analytics Data APIの設定4 「サービスアカウント名」と「サービスアカウントID」を入力し、完了ボタンをクリックします。 Google Analytics Data APIの設定5 Google Analytics Data APIの設定6 サービスアカウントを作成後、秘密鍵のJSONファイルのダウンロードを行います。サービスアカウントの画面から鍵を追加していきます。 Google Analytics Data APIの設定7 Google Analytics Data APIの設定8 ダウンロードしたファイルはデータ取得で使用するので、ブログフォルダ内の.gcp内に配置します。 Gitで管理している場合は、間違って公開してしまわないよう.gitignoreに追記しておく必要があります。 .gitignore\r1.gcp\rGoogle Analyticsの設定 ここから、Google Analyticsでサービスアカウントの権限設定を行います。管理画面の「プロパティのアクセス管理」をクリックします。 Google Analyticsの設定1 右上の「+」ボタンからユーザーを追加をクリックします。 Google Analyticsの設定2 作成したサービスアカウントIDをメールアドレス欄に入力し、標準の役割は「閲覧者」に設定します。 Google Analyticsの設定3 PVランキングを取得するスクリプトの作成 ここからPVランキングを取得するスクリプトの作成していきます。今回はDockerを使用しますので、新たにcompose.create-ranking.ymlを作成します。 compose.create-ranking.yml\r1volumes: 2 node-modules: 3 4services: 5 node: 6 image: node:latest 7 working_dir: /node 8 tty: true 9 ports: 10 - &#39;3000:3000&#39; 11 volumes: 12 - .:/node 13 - node-modules:/node/node_modules 14 command: &gt; 15 bash -c &#34;npm install &amp;&amp; 16 npm install @google-analytics/data &amp;&amp; 17 node scripts/create-ranking.js&#34;\r実際にPVデータを取得するanalytics-api.jsと、表示用にjsonファイルを作成するcreate-ranking.jsをscriptsフォルダ内に配置します。 scripts/analytics-api.js\r1// Google Analytics 4 property ID 2propertyId = &#39;XXXXXXXXX&#39;; //プロパティID 3 4// Imports the Google Analytics Data API client library. 5const { BetaAnalyticsDataClient } = require(&#39;@google-analytics/data&#39;); 6process.env.GOOGLE_APPLICATION_CREDENTIALS = `.gcp/google-analytics_credentials.json`; 7 8// Using a default constructor instructs the client to use the credentials 9// specified in GOOGLE_APPLICATION_CREDENTIALS environment variable. 10const analyticsDataClient = new BetaAnalyticsDataClient(); 11 12exports.runReport = async function () { 13 const [response] = await analyticsDataClient.runReport({ 14 property: `properties/${propertyId}`, 15 dateRanges: [ 16 { 17 startDate: &#39;8daysAgo&#39;, 18 endDate: &#39;1daysAgo&#39;, 19 }, 20 ], 21 dimensions: [ 22 { 23 name: &#39;pagePath&#39;, 24 }, 25 ], 26 metrics: [ 27 { 28 name: &#39;screenPageViews&#39;, 29 }, 30 ], 31 }); 32 return response; 33}\rscripts/create-ranking.js\r1const { runReport } = require(&#39;./analytics-api.js&#39;); 2 3const fs = require(&#39;fs&#39;); 4const currentDate = new Date().toISOString(); 5 6async function main() { 7 try { 8 const response = await runReport(); 9 10 let rankings = [] 11 response.rows.forEach((row) =&gt; { 12 rankings.push({ 13 pagePath: row.dimensionValues[0].value, 14 pv: row.metricValues[0].value, 15 }) 16 }) 17 fs.writeFileSync( 18 &#39;data/ranking.json&#39;, 19 JSON.stringify( 20 { 21 items: rankings, 22 createdAt: currentDate 23 }, 24 null, 25 4 26 ) 27 ) 28 } catch (error) { 29 console.error(&#39;Error running report:&#39;, error); 30 } 31} 32 33main();\rPVデータの取得は以下のコマンドで実行できます。 ターミナル\r1$ docker compose -f compose.create-ranking.yml run --rm node # PVランキング取得\rHugoでランキングを表示 Hugo上では以下の様にしてPVデータを取得できます。参考として、当サイトのメニューバーに表示させているpartialファイルを紹介します。 ranking.html\r1{{ $ranking := slice }} 2{{ range $item := sort .Site.Data.ranking.items &#34;pv&#34; &#34;desc&#34; }} 3 {{ $ranking = $ranking | append (dict &#34;page&#34; $item.pagePath) }} 4{{ end }} 5 6&lt;div class=&#34;widget-recent widget&#34;&gt; 7 &lt;h4 class=&#34;widget__title&#34;&gt;人気記事&lt;/h4&gt; 8 &lt;div class=&#34;widget__content&#34;&gt; 9 &lt;ul class=&#34;widget__list&#34;&gt; 10 {{ range first 5 $ranking }} 11 {{ $url := replace .page &#34;/&#34; &#34;&#34;}} 12 {{ $page := $.Site.GetPage $url }} 13 &lt;li class=&#34;widget__item&#34;&gt;&lt;a class=&#34;widget__link&#34; href=&#34;{{ $page.Permalink }}&#34; target=&#34;_blank&#34;&gt;{{ $page.Title }}&lt;/a&gt;&lt;/li&gt; 14 {{ end }} 15 &lt;/ul&gt; 16 &lt;/div&gt; 17&lt;/div&gt;\rGithub Actionsの設定 1週間に一度、自動でランキング取得処理とリポジトリへのプッシュを行えるよう、.github/workflowsディレクトリにupdate-ranking.ymlを配置します。ついでに手動実行もできるようにしていおきます。 update-ranking.yml\r1name: update-ranking 2 3on: 4 schedule: 5 - cron: &#39;0 0 * * 0&#39; 6 workflow_dispatch: 7 8jobs: 9 update-ranking: 10 runs-on: ubuntu-latest 11 timeout-minutes: 5 12 permissions: 13 id-token: write 14 contents: write 15 steps: 16 - name: Checkout 17 uses: actions/checkout@v4 18 with: 19 submodules: true 20 fetch-depth: 0 # enableGitInfoでの取得用 21 - name: Setup npm 22 uses: actions/setup-node@v4 23 with: 24 node-version: 20 25 - name: Cache npm dependencies 26 uses: actions/cache@v4 27 with: 28 path: ~/.npm 29 key: ${{ runner.os }}-node-${{ hashFiles(&#39;package-lock.json&#39;) }} 30 restore-keys: ${{ runner.os }}-node- 31 - name: npm Install 32 run: npm ci 33 - name: Create Ranking 34 env: 35 GOOGLE_ANALYTICS_CREDENTIALS: ${{ secrets.GOOGLE_ANALYTICS_CREDENTIALS }} 36 run: | 37 mkdir .gcp 38 echo &#34;$GOOGLE_ANALYTICS_CREDENTIALS&#34; &gt; .gcp/google-analytics_credentials.json 39 node scripts/create-ranking.js 40 - name: Commit and Push 41 run: | 42 git branch 43 git config user.name &#34;github-actions[bot]&#34; 44 git config user.email &#34;41898282+github-actions[bot]@users.noreply.github.com&#34; 45 git commit -am &#34;Create Ranking&#34; 46 git push origin HEAD\rフローとしては、update-ranking.ymlでmainブランチに最新のランキングデータがプッシュされ、プッシュとトリガーとして、上の記事で設定した自動デプロイのフローが実行されるといった流れになります。以下の記事も参考にしてください。 関連記事\r【Hugo】Github ActionsでS3に自動でデプロイする【サイト構築③】 続いて、GitHubのSecrets設定で、GOOGLE_ANALYTICS_CREDENTIALSに先ほどダウンロードした鍵の内容を設定します。 GitHub ActionsのSecrets設定 また、自動デプロイ処理中でコミットとプッシュができるように、Actionsの設定の「Workflow permissions」を「Read and write permissions」に設定しておきましょう。 GitHub Actionsの書き込み設定 これで、GitHubへのプッシュ時にランキングを取得してからデプロイするようになります。 今回はHugoでPVランキングを取得する方法を紹介しました。やはり、人気記事の一覧はブログサイトとしてはあった方が見栄えが良い気がしますね。以上で記事を終わりにします。 参考文献 アナリティクス Reporting API v4を使ってGoogle Analyticsのデータを取得する | DevelopersIO Hugoで一週間のPV数順の人気記事を作る方法 | Hugoブログテーマ「Salt」"},{url:"/dimzakki-mainroad/vmware-monitor/",title:"【VMware Horizon】外部モニターでポインターがズレる時の解決策",date:"2023-12-26T00:00:00Z",body:"【VMware Horizon】外部モニターでポインターがズレる時の解決策 VMware Horizon Clientのマルチディスプレイでの使用時に、マウスのポインターの位置がズレる問題についての記事になります。 外部モニター接続時にポインターがズレる 最近、仕事で開発環境のVDIにアクセスする際にVMwareを使っていて、クライアントのノートPCを外部モニターに繋いで使用しようと思ったのですが、リモート画面のマウスのポインターがズレて使い物にならない症状が発生しました。クリックした際に、実際にクリックした位置の左上に判定がズレるような感じです。 当初はディスプレイの解像度の問題だろうか？とアプリの設定をいじってみたりしましたが、解決せず。色々試してみた結果、アプリの設定ではなく、exeファイルのプロパティの設定を変えることで解消しました。 実行ファイルであるvmware-view.exeのプロパティで「互換性」タブをクリック→設定の「高DPI設定では画面のスケーリングを無効にする」にチェックを入れればOKです。 外部モニターが使えないと何かと不便な為、解消できて良かったです。似た症状の人の参考になれば幸いです。以上で記事を終わりにします。 参考文献 Mouse problem on second display using WS 10 (regression?) | VMware Technology Network VMTN"},{url:"/dimzakki-mainroad/hugo-github/",title:"【Hugo】Github ActionsでS3に自動でデプロイする【サイト構築③】",date:"2023-11-24T00:00:00Z",body:"【Hugo】Github ActionsでS3に自動でデプロイする【サイト構築③】 HugoをGithubにプッシュした際に、自動でAWS S3にデプロイする方法を紹介します。 必要な手順としては、AWS IAMロールの設定およびGithub Actionsの設定のみになります。 関連記事\r【Hugo】WordPressブログをHugo・AWSに移行した 【AWS】Amazon Route 53に他サービスの独自ドメインを移管する 【Hugo】ローカルにサイト（Mainroadテーマ）を構築する【サイト構築①】 【AWS】HugoをS3・CloudFrontにデプロイする【サイト構築②】 IAMロールの設定 まずは、AWS IAMコンソールの「IDプロバイダ」から、OIDCプロバイダの設定を以下の様に行います。 OIDCプロバイダとは、AWSに信頼できる外部の認証元として登録するサービスのことです。AWSとGitHub Actionsを連携させるために設定するために必要になります。 IDプロバイダーの追加画面で、以下の通りに設定します。 プロバイダのタイプ：OpenID Connect プロバイダのURL：https://token.actions.githubusercontent.com 対象者：sts.amazonaws.com OIDCプロバイダの設定 続いてIAMロールを作成します。ロール名は分かれば何でも良いですが、今回はblog_github_action_roleとします。 作成したロールの信頼ポリシーの編集で、ポリシーを以下の通りに設定します。それぞれ、AWSアカウントIDとGitHubユーザー名・リポジトリ名を指定します。 信頼ポリシー\r1{ 2 &#34;Version&#34;: &#34;2012-10-17&#34;, 3 &#34;Statement&#34;: [ 4 { 5 &#34;Effect&#34;: &#34;Allow&#34;, 6 &#34;Principal&#34;: { 7 &#34;Federated&#34;: &#34;arn:aws:iam::&lt;AWSアカウントID&gt;:oidc-provider/token.actions.githubusercontent.com&#34; 8 }, 9 &#34;Action&#34;: &#34;sts:AssumeRoleWithWebIdentity&#34;, 10 &#34;Condition&#34;: { 11 &#34;StringLike&#34;: { 12 &#34;token.actions.githubusercontent.com:sub&#34;: &#34;repo:&lt;GitHubユーザー名&gt;/&lt;GitHubリポジトリ名&gt;:*&#34; 13 } 14 } 15 } 16 ] 17}\rここまででAWS側の設定は完了です。 Github Actionsの設定 続いて、ワークフローを定義するファイルの作成と、Github Actionsの設定になります。 GitHubリポジトリの.github/workflowsディレクトリにbuild-deploy.ymlを配置します。ファイルは以下の様にします。 build-deploy.yml\r1name: build-deploy 2 3on: 4 push: 5 branches: 6 - main 7 8jobs: 9 build-deploy: 10 runs-on: ubuntu-latest 11 timeout-minutes: 5 12 permissions: 13 id-token: write 14 contents: read 15 steps: 16 - name: Get Latest Hugo Version 17 id: hugo_version 18 run: | 19 latest=$(curl -s https://api.github.com/repos/gohugoio/hugo/releases/latest | jq -r &#39;.tag_name&#39;) 20 echo &#34;version=${latest#v}&#34; &gt;&gt; $GITHUB_OUTPUT 21 - name: Install Hugo CLI 22 run: | 23 wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${{ steps.hugo_version.outputs.version }}/hugo_extended_${{ steps.hugo_version.outputs.version }}_linux-amd64.deb \\ 24 &amp;&amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb 25 - name: Checkout 26 uses: actions/checkout@v4 27 with: 28 submodules: true 29 fetch-depth: 0 # enableGitInfoでの取得用 30 - name: Build Hugo 31 run: hugo --minify --buildFuture 32 - name: Configure AWS Credentials 33 uses: aws-actions/configure-aws-credentials@v4 34 with: 35 aws-region: ap-northeast-1 36 role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/blog_github_action_role # ロール名 37 role-session-name: GitHubActions-${{ github.run_id }} 38 role-duration-seconds: 900 39 - name: Upload files to the production website with the AWS CLI 40 run: | 41 echo &#34;uploding to s3 ...&#34; 42 aws s3 sync public s3://${{ secrets.S3_BUCKET }}/ --size-only --delete 43 aws cloudfront create-invalidation --region ap-northeast-1 --distribution-id ${{ secrets.DISTRIBUTION_ID }} --paths &#34;/*&#34;\rここで、36行目に今回作成したIAMのロール名を指定します。 ワークフローの内容としては、mainブランチにプッシュされた時に、HugoのビルドとAWS S3へのデプロイを行います。Hugoは最新バージョンを取得しビルドするようにしています。 また、36行目でfetch-depth: 0としているのは、記事の最終更新日を設定する際に、過去のコミットの日時も取得するためです。 次に、GitHubのリポジトリ設定で、「Secrets and variables（Actions）」の設定画面で、Repository secretsに変数を以下の通りに設定します。 AWS_ACCOUNT_IDにAWSのアカウントID、S3_BUCKETにS3バケット名、DISTRIBUTION_IDにはディストリビューションIDを設定します。 AWS_ACCOUNT_ID：AWSのアカウントID S3_BUCKET：AWS S3のバケット名 DISTRIBUTION_ID：Amazon CloudFrontのディストリビューションID GitHubのSecrets設定 ここまでで、必要な設定は完了になります。これでプッシュ時に自動でS3にデプロイできるようになりました。 実際にGitHubにプッシュし、GitHub Actionsの画面から処理が実行されること、処理実行後にサイトに更新が反映されていることが確認できたら成功です。 ここまででHugoブログの構築が完了となります。以上で記事を終わりにします。 参考文献 Host on GitHub Pages | Hugo.io GitHub ActionsにAWSクレデンシャルを直接設定したくないのでIAMロールを利用したい | DevelopersIO"},{url:"/dimzakki-mainroad/hugo-deploy/",title:"【AWS】HugoをS3・CloudFrontにデプロイする【サイト構築②】",date:"2023-10-15T00:00:00Z",body:"【AWS】HugoをS3・CloudFrontにデプロイする【サイト構築②】 ローカルで構築したHugoのブログサイトをAWS S3にデプロイし、Amazon CloudFrontで配信するまでの流れをまとめていきます。 なお、ローカルでのHugoサイトの作成と、Route 53での独自ドメイン取得が出来ている前提で話を進めていきます。 関連記事\r【Hugo】WordPressブログをHugo・AWSに移行した 【AWS】Amazon Route 53に他サービスの独自ドメインを移管する 【Hugo】ローカルにサイト（Mainroadテーマ）を構築する【サイト構築①】 【Hugo】Github ActionsでS3に自動でデプロイする【サイト構築③】 HugoをS3にデプロイする まずはS3のバケットを作成していきます。 バケットの作成1 サイトは独自ドメインで運用するので、最終的にはS3のパブリックアクセスはブロックしてホスティングします。その前にS3でホスティングしてサイトを確認したいので、一旦パブリックアクセスをすべてブロック」のチェックは外します。 バケットの作成2 その他の設定はいじらなくて良いので、そのままバケットを作成します。 続いて、ビルドしたファイルのアップロードを行っていきます。 バケットの作成3 Hugoのビルド時に生成されたファイルがpublicフォルダ内にあるので、それらを選択します。下にある「アップロード」をクリックすると選択されたファイルがバケットにアップロードされます。 バケットの作成4 続いて、プロパティからS3の「静的ウェブサイトホスティング」を有効にしていきます。 静的ウェブサイトホスティングの設定1 静的ウェブサイトホスティングの設定2 インデックスドキュメントにはindex.htmlを入力します。 静的ウェブサイトホスティングの設定3 次に、「アクセス許可」からバケットポリシーを設定します。ポリシーに以下を記述します。 バケットポリシー\r1{ 2 &#34;Version&#34;: &#34;2012-10-17&#34;, 3 &#34;Statement&#34;: [ 4 { 5 &#34;Sid&#34;: &#34;PublicReadGetObject&#34;, 6 &#34;Effect&#34;: &#34;Allow&#34;, 7 &#34;Principal&#34;: &#34;*&#34;, 8 &#34;Action&#34;: [ 9 &#34;s3:GetObject&#34; 10 ], 11 &#34;Resource&#34;: [ 12 &#34;arn:aws:s3:::バケット名/*&#34; 13 ] 14 } 15 ] 16}\rここまでで、静的ウェブサイトホスティングが完了するので、「プロパティ」で発行されたURLからアクセスし、サイトが表示されるかを確認しましょう。 静的ウェブサイトホスティングの設定4 ACMでSSL証明書を発行する S3へのデプロイが完了したので、S3へCloudFrontからでアクセスするように設定します。その前にACMでSSL証明書を発行していきます。CloudFrontにACMのSSL証明書を適用するにはリージョンを「米国東部 (バージニア北部)　us-east-1」にする必要があります。1 SSL証明書の発行1 「パブリック証明書をリクエスト」を選択します。 SSL証明書の発行2 ドメイン名に取得ドメインを入力します。当サイトの場合、併せて*.取得ドメインも追加しています。 SSL証明書の発行3 ここまでで証明書の発行手続きが完了するので、ドメインにCNAMEレコードを追加します。「Route53でのレコード作成」から作成を行います。 SSL証明書の発行4 SSL証明書の発行5 SSL証明書の発行6 証明書の「状況」ステータスが「発行済み」になれば成功です。 SSL証明書の発行7 CloudFrontからサイトにアクセスする 証明書の発行まで完了したので、S3へCloudFrontからでアクセスするように設定します。まずディストリビューションの作成から行っていきます。「オリジンドメイン」とOACの「名前」はS3のバケット名を入力します。 ディストリビューションの作成1 ディストリビューションの作成2 「カスタムSSL証明書」には先ほど作成した証明書を、「デフォルトルートオブジェクト」にはindex.htmlを入力し、ディストリビューションを作成します。 ディストリビューションの作成3 ディストリビューションの作成4 続いて、S3バケットのアクセス許可設定を変更します。作成したディストリビューションの「編集」をクリックし、ポリシーをコピーしてバケットポリシーを変更します。 ディストリビューションの作成5 ディストリビューションの作成6 バケットポリシーにはコピーしたものをそのまま差し替えればOKです。 ディストリビューションの作成7 ここまでで一旦ディストリビューションの設定は終わりです。しかし、このままだとルートオブジェクト以外へのリクエストにindex.htmlが付かないので、ルートオブジェクト以外にアクセスができない状態になってます。その為、CloudFrontの関数でリクエストを書き換える処理を設定します。 関数の作成1 関数の作成2 関数名を適当に設定し、以下のコードを貼り付けます。「発行」タブから「関数の発行」をクリックします。 関数\r1function handler(event) { 2 var request = event.request; 3 var uri = request.uri; 4 if (uri.endsWith(&#39;/&#39;)) { 5 request.uri += &#39;index.html&#39;; 6 } 7 else if (!uri.includes(&#39;.&#39;)) { 8 request.uri += &#39;/index.html&#39;; 9 } 10 return request; 11}\r関数の作成3 関数の作成4 関数の作成5 関数は作成しましたので、ディストリビューションの「ビヘイビア」から作成した関数を関連付けします。 関数の作成6 最後に、ドメインのAレコードをCloudFrontに変更します。 関数の作成7 これでCloudFrontでの配信の設定は終わりです。取得したドメインにアクセスし、サイトが表示されたら成功です。 ついでに、最初の方でパブリックアクセスのブロック設定をOFFにしていたので戻しておきましょう。 今回はHugoサイトをAWSにデプロイ・配信するまでをまとめました。以上で記事を終わりにします。 参考文献 チュートリアル: Amazon S3 での静的ウェブサイトの設定 | Amazon Simple Storage Service AWSでSSL証明書を発行する手順 | 株式会社カサレアル BSブログ index.html を追加してファイル名を含まない URL をリクエストする | Amazon CloudFront CloudFront で SSL/TLS 証明書を使用するための要件 | Amazon CloudFront&#160;&#x21a9;&#xfe0e;"},{url:"/dimzakki-mainroad/develop-hugo/",title:"【Hugo】ローカルにサイト（Mainroadテーマ）を構築する【サイト構築①】",date:"2023-10-10T00:00:00Z",body:"【Hugo】ローカルにサイト（Mainroadテーマ）を構築する【サイト構築①】 Hugoのブログサイトをローカルに構築し、WordPressからブログ記事を移行する手順について書いていきます。 関連記事\r【Hugo】WordPressブログをHugo・AWSに移行した 【AWS】Amazon Route 53に他サービスの独自ドメインを移管する 【AWS】HugoをS3・CloudFrontにデプロイする【サイト構築②】 【Hugo】Github ActionsでS3に自動でデプロイする【サイト構築③】 Hugoのセットアップ GitHubのHugo公式リポジトリのリリースページから、ZIPファイルをダウンロードします。Windowsの場合、windows-amd64.zipかwindows-arm64.zipの対応CPUのものを選択します。 Hugoのフォルダは今回はC:\\Hugo\\binとします。ZIPファイルを解凍し、hugo.exeをbinフォルダに配置します。 続いて、環境変数のパスを通します。Windowsの設定から、「システム」→左側一番下の「詳細情報」→右側の「システムの詳細設定」→一番下の「環境変数」を開きます。そこから、「ユーザーの環境変数」→「Path」を編集し、C:\\Hugo\\binを設定します。 Hugoの環境変数 コマンドプロンプトでhugo helpを実行し、ヘルプ一覧が表示されたらインストール完了です。 なお、Hugoのバージョンアップデートについては、新しいバージョンのZIPファイルをダウンロードし、C:\\Hugo\\binに配置したhugo.exeを新しい物へ差し替えればOKです。 ローカルに初期サイトを構築 C:\\Hugo内にブログ用のフォルダを作成して初期サイトを構築します。サイトはGitHubで管理するので、Gitリポジトリの初期化もしておきます。 ターミナル\r1$ cd C:\\Hugo\\ 2$ hugo new site &lt;サイト名&gt; 3$ cd C:\\Hugo\\&lt;サイト名&gt; 4$ git init\rサイト名を自分の好きな名前に変えて下さい。 続いてテーマを導入します。Hugoには豊富なテーマプラグインがありますが、当サイトではシンプルかつ今までのブログのスタイルに近かったMainroadを採用しました。 今回はGitのサブモジュールとして追加します。 ターミナル\r1$ git submodule add https://github.com/vimux/mainroad themes/mainroad\rhugo.tomlの設定ファイルの記述を追加してMainroadテーマを有効にします。 hugo.toml\r1theme = &#34;mainroad&#34;\rローカルでサイトを確認したい場合はserverコマンドを実行し、http://localhost:1313/でサイトプレビューを確認できます。 ターミナル\r1$ hugo server -D # draft:trueの下書き記事も表示する\rまた、新規記事の作成についてはnewコマンドで行います。 ターミナル\r1$ hugo new test.md # 新規記事を作成する\rHugoの設定 Hugoの設定はhugo.toml（古いバージョンだとconfig.toml）で設定します。参考までに、以下が基本的な設定項目になります。 hugo.toml\r1baseURL = &#34;&lt;サイトURL&gt;&#34; 2title = &#34;&lt;サイトタイトル&gt;&#34; 3DefaultContentLanguage = &#34;ja&#34; 4languageCode = &#34;ja-JP&#34; 5theme = &#34;mainroad&#34; 6hasCJKLanguage = true 7summarylength = 120 8enableGitInfo = &#34;true&#34; # 最終更新日をgitから取得 9timeout = &#34;60s&#34; 10 11[services.googleAnalytics] 12 ID = &#34;G-XXXXXXXXXX&#34; # アナリティクスのトラッキングID 13 14[permalinks] 15 post = &#34;/:contentbasename/&#34; 16 17[Params] 18 Subtitle = &#34;&lt;サイトサブタイトル&gt;&#34; 19 description = &#34;&lt;サイト説明文&gt;&#34; 20 post_meta = [&#34;date&#34;, &#34;categories&#34;] 21 highlightColor = &#34;#0095d9&#34; 22 dateformat = &#34;2006-01-02&#34; 23 customCSS = [&#34;/css/custom.css&#34;] 24 toc = true 25[Params.sidebar] 26 home = &#34;right&#34; 27 list = &#34;right&#34; 28 single = &#34;right&#34; 29 widgets = [&#34;categories&#34;, &#34;taglist&#34;, &#34;recent&#34;, &#34;archives&#34;, &#34;social&#34;] 30 31[Params.widgets] 32 recent_num = 5 33 categories_counter = true 34 tags_counter = true 35 36[taxonomies] 37 tag = &#34;tags&#34; 38 category = &#34;categories&#34; 39 archive = &#34;archives&#34; 40 41[related] 42 includeNewer = true 43[[related.indices]] 44 name = &#34;tags&#34; 45 weight = 80 46[[related.indices]] 47 name = &#34;categories&#34; 48 weight = 60 49 50[[Menus.main]] 51 Name = &#34;当サイトについて&#34; 52 URL = &#34;/about&#34; 53 weight = 10 54[[Menus.main]] 55 Name = &#34;プロフィール&#34; 56 URL = &#34;/profile&#34; 57 weight = 20 58[[Menus.footer]] 59 Name = &#34;プライバシーポリシー&#34; 60 URL = &#34;/privacy-policy&#34; 61 62[markup.goldmark.renderer] 63 unsafe = true\r記事のデータの移行 記事のデータ移行にはwordpress-to-hugo-exporterというWordPressプラグインがあるので、それが使えれば簡単に移行ができると思います。 GitHubの「Download ZIP」からダウンロードし、ZIPファイルをWordpressのプラグインページからアップロードすることで、WordPressのツールからエクスポートが可能になります。 当サイトの場合は「Export to Hugo」のエクスポートのZIPファイルが、何故かエラーで何回やってもダウンロード出来なかったので、手動でコピペして記事を移しました…。 移行作業としては記事内容のコピペが主で、それをマークダウン形式に書き換える作業が殆どでした。 今回は、ローカルでブログを構築する所まで紹介しました。また、Dockerで環境構築をする方法についても、別の記事にまとめていますので参考にしてみてください。 関連記事\r【Hugo】Docker上でHugo環境を構築する【Compose Watch】 以上で記事を終わりにします。 参考文献 Hugoの設定 | Go ＆ Hugo ドキュメント WordPressの記事をHugoに移行する | Qiita"},{url:"/dimzakki-mainroad/qualification-aws-saa/",title:"【AWS SAA】合格体験記【約1か月で合格した勉強方法】",date:"2023-09-02T00:00:00Z",body:"【AWS SAA】合格体験記【約1か月で合格した勉強方法】 AWS Solutions Architect Associate（ソリューションアーキテクトアソシエイト）試験（SAA-C03）を2023年8月に受け合格しましたので、試験の対策・結果・感想などを合格体験記としてまとめたいと思います。 関連記事\r【AWS SAA】試験対策用備忘録メモ 試験概要・難易度 AWS CLF試験はAWS認定資格の中で入門レベルの資格に位置しています。AWSクラウド・サービス・用語について基礎的な理解が求められます。 項目 詳細 出題形式 選択問題・CBT方式 出題数 65問 試験時間 130分 合格点 720点以上（1000点満点） 受験料 150ドル 合格点は1,000点満点中720点以上となっていますが、得点は100～1,000のスケールスコアで採点され配点が非公開のため、単に72%以上正解しないといけないという訳では無いことに注意しましょう。合格率は非公開になっています。 試験の難易度としては、暗記が中心となり、ある程度の分量の文章問題が出題されます。内容はCLF試験より深い知識が求められます。試験自体の難易度は、あまり単純な比較はできませんが基本情報よりは合格するのは難しいかなと感じました。体感で応用情報と同じくらいの難易度だと思います。 試験申し込み～試験勉強 実際に受験することを決めてから試験本番までの流れを書いていきます。 プロフィール\r開発系のITエンジニア（2年目） AWSを業務で使用することはほぼなし AWS CLFに合格済み AWS CLF（クラウドプラクティショナー）を持っていましたので、AWSに関しては基礎的な知識があるのみでした。 関連記事\r【AWS CLF】合格体験記【未経験で約1か月で合格】 受験のきっかけ・申し込み 受験しようと決めた理由は、会社の査定のためというのが大きかったです。CLFとSAAを取得することで査定評価でプラスされるので、そこまで取得しようと思っていました。CLFに合格して、その勢いでSAAの受験へと進みました。 申し込みは公式サイトからピアソンビューで行いました。 実際に行った試験勉強 ここから私が実際に行った試験対策について書いていきます。試験勉強では、参考書とWebの問題集を使いました。総勉強期間は1ヶ月ちょっとで、勉強時間は30時間くらいでした。 まず始めに、ざっとAWS全体の基本を抑えるため、参考書の「AWS認定資格試験テキスト AWS認定ソリューションアーキテクト - アソシエイト 改訂第3版」をざっと読みました。通称オレンジ本と呼ばれており、最初の取っ掛かりとしては良い参考書ですが、載っている練習問題の数は多くはありませんでした。新版が出ているので、そちらを紹介します。 AWS認定資格試験テキスト　AWS認定ソリューションアーキテクト - アソシエイト　改訂第3版 (ＡＷＳ認定資格試験テキスト)\r2,860円～ amazon.co.jp 参考書を読んだだけでは知識が定着しませんので、Ping-tが出しているWEB問題集の「AWS SAA-C03 最強WEB問題集 | Ping-t」を解いていました。無料かつ問題数・解説が豊富で高い品質であると言えます。 また、試験勉強と並行してポイントになりそうな所を「【AWS SAA】試験対策用備忘録メモ」にメモとしてまとめました。 試験本番・結果 試験は平日に休みを取り午前中に受けました。試験会場はCLFの試験で来たことのあるビルでしたので、スムーズに受付までできました。 受付の際は、本人確認に身分証明書が2点必要なので、事前にちゃんと確認しておきましょう。 試験では勉強した分野の問題以外の出題もあり、勘で答えた問題もそこそこありました。見直しも含めて、試験時間を30分残して終了しました。SAAはCLFと違いその場で結果は出ませんが、正直受かったかは五分五分というかあまり自信なしといった感じでした。 試験結果が以下になります。 AWS SAAの試験結果 結果は738点で合格でした。予想通りかなりギリギリな得点になってしまいましたが、合格なので良しとします。 おすすめの試験対策について 今回の受験を踏まえての、おすすめの試験対策についてまとめていきます。 まず始めに、試験範囲の確認として範囲を網羅している参考書で基礎を抑え、その後WEB問題集・Udemy等の問題集で問題を繰り返し解いていくことがおすすめです。 Ping-tの問題集は解説がしっかりとしていますが、実際に出題される問題に近い物はあまり収録されていませんので、不安な方はUdemyなども活用すると良いでしょう。 なお、AWS試験では、ブレインダンプサイトと呼ばれる流出した過去問を販売しているサイトもあります。これらは、そもそもの運営元自体が怪しいものだったり、問題が古いバージョンから更新されていなかったりするので、避けた方が無難です。 私は問題集はPing-tのみだったので、それだけでも合格することは可能です。ただ今回はギリギリな合格であり、落ちてもおかしくなかったため、確実性があるとは言えないですね。余裕を持って合格したい方はお金を惜しまずに色々な問題を解いていった方が良いでしょう。 加えて、CLF試験で得た知識は無駄では無かったので、自信がない場合はまずそちらから受験するのもアリだと思います。 今回はAWS SAAの合格体験記についてまとめました。以上で記事を終わりにします。 参考文献 AWS Certified Solutions Architect – Associate 認定 | AWS"},{url:"/dimzakki-mainroad/aws-saa-measures/",title:"【AWS SAA】試験対策用備忘録メモ",date:"2023-08-14T00:00:00Z",body:"【AWS SAA】試験対策用備忘録メモ AWS Certified Solutions Architect（ソリューションアーキテクトアソシエイト）試験（SAA-C03）の試験対策用の備忘録メモになります。 関連記事\r【AWS SAA】合格体験記【約1か月で合格した勉強方法】 AWSの概要 Well-Architected Frameworkの「一般的な設計原則」は以下の6つ 必要キャパシティーの推測が不要に 本稼働スケールでシステムをテストする 自動化によってアーキテクチャでの実験を容易にする 発展するアーキテクチャが可能に データに基づいてアーキテクチャを進化させる ゲームデーを利用して改善する SaaS （Software as a Service）はアプリケーションを含むすべての機能を提供するサービス EC2 AMI（Amazon マシンイメージ）はEC2インスタンスを起動するためのOS・ミドルウェアなどのテンプレート EC2インスタンスはユーザーが選択したAMIから選択される AMIに含まれないOSの設定や、ミドルウェアの導入は個別に実施する必要あり OS・ミドルウェアのセキュリティパッチはユーザーで管理・適用する必要あり EC2の購入オプション スポットインスタンスではスポットフリートのオプションで必要なインスタンス数を指定できる ハードウェア専有インスタンスは他のAWSアカウントとは分離された専用ハードウェアでEC2インスタンスを利用できる購入オプション Dedicated Hosts（専有ホスト）は他のEC2インスタンスとは分離された専用ハードウェアで利用できる購入オプションで購入価格が一番高い プレイスメントグループは、複数のEC2インスタンスをグループ化し、インスタンス間の低遅延通信やハードウェア障害の影響を軽減できる機能 クラスタープレイスメントグループは、グループ内のEC2インスタンスを単一AZ内の物理的に近い距離に配置し、通信遅延を減らす パーティションプレイスメントグループでは、グループをパーティションとよばれる論理グループに分割し、各パーティション（1つのラックが対応）に1つ以上のEC2インスタンスを配置し、ハードウェア障害による影響を減らす スプレッドプレイスメントグループは、グループ内のEC2インスタンスを異なるラックに配置し、ハードウェア障害による影響を減らす インスタンスストアは、EC2インスタンスの稼働中にだけ利用できるブロックストレージ 一時的なストレージとして利用でき、EBSよりも高いパフォーマンスを持つ EC2インスタンスの停止・終了・削除時・障害発生時にはデータは消える 利用料金はEC2に含まれておりインスタンスストア自体は無料 キーペアは、EC2インスタンスに安全に接続するための暗号鍵のペア（SSHキー） AWS上に保管されるパブリックキーとユーザー環境上に保管するプライベートキーの2つで構成される S3 バケットはS3のオブジェクトが保存される領域 バケットにはオブジェクト数が無制限で保存できる バケット名はグローバルで一意にする必要あり 作成したバケットのバケット名は変更できない S3バケットに一度にアップロードできる最大サイズは5GB 5GB以上の時はマルチパートアップロードでファイルを複数に分割しS3バケットにアップロードする S3のアクセス制御 ユーザー（IAM）ポリシーは、自分のAWSアカウントのIAMユーザー・グループ・ロールに対してアクセスと、アクセス元のIPアドレス・ドメイン名によるアクセス制御ができる バケットポリシーはバケット単位でアクセス権限を設定でき、他のAWSアカウントに対してもアクセス制御ができる（アクセス元のIPアドレス・ドメイン名のアクセス制御も可能） ACLは、他のAWSアカウントからの読み取り・書き込みを許可できるが、アクセス元のIPアドレスやドメイン単位でのアクセス制御はできない S3のオブジェクトロックは、S3バケットに保存したオブジェクトに対して更新・削除を制限する オブジェクトロックはS3バケット作成時にのみ設定可能 オブジェクトロックには保持期間が無期限のリーガルホールドと、期限付きのリテンションモードがある リーガルホールドは、権限を持たないユーザーに対し、リーガルホールドが解除されるまでオブジェクトを読み取り専用にする リテンションモードはガバナンスモードとコンプライアンスモードのどちらかを選ぶ ガバナンスモードでは権限を持たないユーザーに対し、指定の保持期間中オブジェクトを読み取り専用にする コンプライアンスモードではルートユーザーを含む全てのユーザーに対して、指定した保持期間中オブジェクトを読み取り専用にする S3 Glacierにはボールトロックという機能があり、ボールト内のアーカイブに制限をかけることが可能 ボールトロックを有効にすると、指定した期間中は設定内容を変更できない SSE（Server-Side Encryption）は、データをS3に保存する時にサーバーで暗号化する方法 SSE-S3ではS3が管理している鍵を使用する SSE-KMSではAWS KMSに保存されているKMSキーを使用する SSE-Cではユーザーが管理している鍵を使用する MFA Deleteは、S3のバージョニング機能を使用して管理されているオブジェクトを削除する際に、MFAデバイスの認証が必要となる機能 MFA Deleteを利用すると、ルートユーザーのみが世代管理されたデータの削除権限を持つようになる Transfer Accelerationは、S3上のデータをAWSネットワーク内から最速で通信できるルートを経由して転送させる機能 VPC ENI（Elastic Network Interface）はAWSリソースのネットワークインターフェイス VPC内のEC2インスタンスやNATゲートウェイなどに割り当てて利用する VPCフローログは、VPC内のENIで通信するネットワークトラフィック情報をキャプチャする機能 AWS Transit Gatewayは、複数のVPCや複数のオンプレミスネットワークを相互に接続するハブ機能を持つ VPC以外にDirect ConnectやAWS VPNで接続されたオンプレミスネットワークとも接続可能 サブネットのルートテーブルはデータをどこに転送するかを定義する機能 インターネットゲートウェイをターゲットにすることでVPCからインターネットへ接続できる ルートテーブルがないサブネットはVPC全体に適用されるメインルートテーブルに従ってルーティングする インターネットゲートウェイは、インターネットとVPC内のAWSリソースを接続する機能 インターネットゲートウェイへのルーティングが設定されたサブネットはパブリックサブネットになる NATゲートウェイ・NATインスタンスは、プライベートサブネットからインターネットへの通信を可能にするIPv4専用の機能 NATゲートウェイはAWSによってAZ内で冗長化されている NATインスタンスはEC2インスタンスから作成し、ユーザーが管理を行う NATインスタンスはNATゲートウェイでは利用できないポート転送機能を設定できる NATインスタンスはVPC外からプライベートサブネット内へ接続する際の踏み台サーバーとして利用可能 Egress-Onlyインターネットゲートウェイは、VPCからインターネットへの接続開始要求を通すIPv6専用のインターネットゲートウェイ VPCエンドポイントはプライベートサブネット内のAWSリソースから、インターネットゲートウェイを経由せずにVPC外のAWSサービスへアクセスする機能 VPCエンドポイントポリシーでVPCエンドポイントからの接続先を制限する VPCエンドポイントにはゲートウェイ型とPrivateLinkがある ゲートウェイ型はS3とDynamoDBで利用でき、PrivateLinkは多数のサービスで利用できる IPアドレスの種類 プライベートIPアドレスは、VPC内のリソース間の通信に使用し、AWSリソースを停止・起動しても同一のIPアドレスが使われ、AWSリソースの削除時にIPアドレスが解放される パブリックIPアドレスは、インターネットと通信可能なIPアドレスでAWSリソースが停止する時にIPアドレスが解放され、AWSリソースが起動する時に新規のIPアドレスが割り当てられる Elastic IPアドレスは、インターネットと通信可能な固定のパブリックIPアドレスでAWSリソースが削除されても同一のIPアドレスが保有される IAM IAMポリシーはAWSリソースに対する権限を定義する IAMポリシーにはアイデンティティ（ユーザー）ベースとリソースベースのポリシーがある アイデンティティベースのポリシーはIAMユーザー・IAMグループ・IAMロールにアタッチする リソースベースのポリシーは、S3バケットなどのAWSリソースに対してアタッチするポリシー ELB ELB経由のクライアントからWebサーバーまでの通信の暗号化 ALB・CLBでELBとターゲットにサーバー証明書を導入する（クライアントとWebサーバー間の暗号化通信はHTTPS） NLB・CLBでターゲットにサーバー証明書を導入する（クライアントとWebサーバー間の暗号化通信にHTTPSを利用、経由するELBはTCPを利用する） ELB経由でクライアントからWebサーバーまでのインターネット通信を暗号化 ELBにサーバー証明書を導入する（クライアントからELBまでの通信が暗号化される） ALBでHTTPのリクエストをHTTPSに変換するには、HTTPリスナーを作成しHTTPSへリダイレクトするルールを設定する SNI（Server Name Indication）は、サーバー証明書をパブリックIPアドレスではなくドメイン名によって判断する昨日 アクセスログを有効にするとクライアントの接続情報が記録される Auto Scaling Auto Scalingグループはスケーリングの管理単位で、グループ内でのリソースの最小・最大数やスケールアウト・インの実行条件などを指定する グループのスケールイン時にリソースを削除する優先順位を終了ポリシーにて設定する（デフォルトは最も作成時刻が古い起動テンプレートを利用して起動されたリソース） グループでスケールアウトが発生した時に起動するリソースは、起動テンプレートで指定する ライフサイクルフックは、スケーリングの起動・終了時に任意の処理を実行する機能 動的スケーリングは、CPUやネットワークなどのパフォーマンスの負荷状況に応じてスケーリングを実施する Lambda Lambda関数はLambda専用のVPCに配置される Lambda専用のVPCからプライベートサブネット内のAWSリソースへはアクセスできない VPCアクセスを設定したLambda関数は、ENIを作成したサブネットへアクセスできるようになるがインターネットへアクセスできなくなる ECS ECSにはクラスター・タスク・サービスがある クラスターは1つ以上のタスク・サービスで構成される クラスターではコンテナが動作するVPC・サブネットなどを設定する タスクはECSで管理するコンテナの実行単位 サービスでは起動するタスクのタスク定義、クラスター内で必要なタスク数などを設定する タスク定義は実行コンテナイメージ・CPUやメモリのスペック・タスクロールなどを定義する ECSで実行・管理するコンテナは、AWS FargateとEC2起動タイプがある AWS Fargateはコンテナ実行環境のCPUやメモリのスペック・アクセス権限などを設定すれば、サーバーの環境構築や管理をすることなくコンテナを実行できる EC2起動タイプはユーザーが管理するEC2インスタンス上でコンテナを実行する Amazon ECR（Elastic Container Registry）はコンテナイメージを登録・管理するサービス EBS Amazon EBS（Elastic Block Store）はEC2インスタンスに割り当てられる可用性・堅牢性に優れたブロックストレージ インスタンスを終了してもデータを永続的に保持することができる スナップショット機能・暗号化機能がある 暗号化する際はAWS KMSを利用する HDDのボリュームタイプ（st1、sc1）はEC2インスタンスの起動ボリュームには指定できない DeleteOnTerminationの値をfalseにするとEC2インスタンス終了時にデータが削除されない EBSで扱えるデータ量の上限は16TiB アタッチしているEC2インスタンスのOSの機能を利用してEBSボリュームのRAID構成を組むことができる EFS EFS（Elastic File System）はNFS（Network File System）プロトコルをサポートするファイルストレージサービス 複数のコンピュータからストレージを共有することができる EFSではデータ量で自動的に拡張・縮小のスケーリングがされる ACID特性のあるストレージ ファイルシステムに対する読み取り・書き込みパフォーマンスを設定できる パフォーマンスの設定にはファイルシステム作成時にのみ設定するパフォーマンスモードと運用中に変更できるスループットモードがある パフォーマンスモードには一般的な用途向けの汎用パフォーマンスモードと、ビッグデータ解析などの大容量データや数千台のクライアントの処理向けの最大I/Oパフォーマンスモードがある スループットモードにはベースライン性能の2倍まで性能向上できるバーストスループットモードと、ユーザーが予約した性能からスループットを提供するプロビジョンドスループットモードがある EFSのストレージ容量は無制限 FSx Amazon FSxはAWSが提供するファイルストレージサービス Amazon FSx For Windowsファイルサーバーは、SMBプロトコルを介してWindows Server上に構築されたファイルシステムを提供するフルマネージドのストレージサービス DFSR機能を備えたファイル共有を利用できる Active Directoryによるユーザー認証が行える NTFS（NT File System）を利用できる ファイルサーバーにはオンプレミス環境とAWSの両方からアクセスできる Amazon FSx For Lustreは、Lustreという既存のファイルシステムをAWS上で利用できる LustreファイルシステムはS3と連携できる HPC（High Performance Computing）や機械学習用途に適したストレージサービス Storage Gateway AWS Storage Gatewayは、オンプレミスからAWSストレージサービスへのアクセスを高速・セキュアに行うサービス ファイルゲートウェイは、オンプレミスからNFSまたはSMBを介してS3バケットへアクセスする オンプレミスにキャッシュストレージを持ち低レイテンシでのアクセスも可能 IAMロールでユーザーごとにアクセスするバケットを制御可能 ボリュームゲートウェイはS3をiSCSI接続のブロックストレージボリュームとして提供する キャッシュ型（キャッシュボリューム）は、データをS3に保存し、高頻度アクセスのデータのみオンプレミスのキャッシュストレージにコピーする 保管型（ストアドボリューム）は、データをオンプレミスのボリュームストレージに保存し、S3に非同期でバックアップを保存する DataSync AWS DataSyncは、ストレージ間のデータ転送サービス Snow Family AWS Snowファミリーにはデータの量・用途で3つのサービスがある Snowconeは最小のデバイスで、オフラインの転送およびAWS DataSyncを使用したオンラインでの転送に対応 Snowballは最大でHDD80TBのストレージ Snowmobileはエクサバイト規模（100PBのストレージ搭載のトレーラー） Snowball Edge Compute Optimizedはコンピューティング向けのデバイス RDS RDSは、フルマネージド型のリレーショナルデータベースサービス マルチAZでは、プライマリDBインスタンスとスタンバイDBインスタンスを異なるAZに配置することによって可用性を向上させる データベースインスタンスの暗号化を行うとバックアップ・スナップショット・ログ・リードレプリカへも暗号化が行われる RDSでは参照専用のデータベースとして動作するRR（リードレプリカ）参作ることができる インスタンスクラスやストレージタイプ、マルチAZのほか、サブネットの設定、自動スケーリングの有無、認証方法などの設定が可能 DBパラメータグループ（DBクラスターパラメータグループ）・オプショングループでタイムゾーン・最大接続数・監査ログの有効化などデータベースの設定を変更する Aurora Amazon Auroraは、MySQL/PostgreSQL互換のデータベースエンジン データベースインスタンスとストレージが分離しており、データベースインスタンスだけを必要に応じて増減できる デフォルトで3つのAZに2つずつのデータコピー・自動修復機能でストレージの高い耐障害性がある Redshift Redshiftはペタバイト級のデータウェアハウス Leaderノードは各クラスタに一台だけ存在する ComputeノードはLeaderノードからの命令を処理する クロスリージョンスナップショットでスナップショットを異なるリージョンへ保存できる DynamoDB シンプルな構造でありデータアクセスのパフォーマンスは非常に高い ストレージの容量制限がない インデックスを作成してテーブル内のデータに高速にアクセスが可能 自動的に3つのAZにデータが保存される テーブルへの書き込み・読み込みのスループット単位をキャパシティユニットとして管理する キャパシティユニットを自動的にスケールに設定するとコストを抑えられる リザーブドキャパシティで予約購入しコストを抑えられる DynamoDB Streamsでテーブルに対して行われた直近の24時間の変更（追加・更新・削除）をログに保存する オンデマンドバックアップでユーザーが任意のタイミングでバックアップを作成する ポイントインタイムリカバリ自動的に差分バックアップを行う Amazon DynamoDB Accelerator（DAX）は、DynamoDBのインメモリのキャッシュクラスタ ElastiCache ElastiCacheはフルマネージドのKey-Value型インメモリデータベース RedisはMemcachedよりも高機能なデータベースエンジン 自動フェイルオーバー・マルチAZ機能を持つ データを永続的に保持できる データの暗号化・SSL/TLSでの通信の暗号化に対応している CloudWatch 複数のメトリクスでアラームを通知したい場合は複合アラームを作成する 標準メトリクスとして取得可能な項目はCPU使用率・ディスクI/O・ネットワーク使用率 Amazon EventBridgeはAWS上のリソースの状態変化やスケジュールに応じてアクションを実行する アクションでLambda関数を実行できる Amazon CloudWatch LogsはAWSサービス・EC2インスタンスのOS・アプリケーションのログを収集・管理する ログの内容をフィルタリングして管理者に通知できる EC2インスタンスのOSのログを収集するにはEC2インスタンスにCloudWatchエージェントをインストールする CloudWatch Logs Insightsは収集されたログを解析するサービス Kinesisなどの別のサービスへ転送するには、サブスクリプションフィルターでデータの転送先を設定する CloudTrail 過去90日間のログを無料で参照できる 証跡情報を登録することによりCloudTrailのログをS3バケットへ保存することができる データイベント（S3上のオブジェクトの操作・Lambdaの実行）・インサイトイベント（書き込みAPIの呼び出しなど通常と異なる操作）のログを取得するには証跡情報を登録する Elastic Beanstalk AWS Elastic Beanstalkは、アプリケーションが動作する定番の構成を提供する 単一インスタンス・複数インスタンスの構成を選択できる Dockerに対応している シングルコンテナ・マルチコンテナを選択できる コンテナが動作する環境はElastic Beanstalkによって管理されるが、コンテナ上の環境はユーザーが管理する CloudFormation AWS CloudFormationは、AWSのリソースをコード化・構築する テンプレートを共有することで同じ環境を複数作成できる スタックセットを利用することでターゲットアカウント・リージョンを指定して環境を複製できる Trusted Advisor コスト最適化 EC2のリザーブドインスタンスの最適な購入数をチェック パフォーマンス EC2インスタンスの使用率をチェック セキュリティ アクセス元の制限がない（0.0.0.0/0）セキュリティグループが定義されていないかをチェック フォールトトレランス ELB配下のインスタンスが複数AZで稼働しているかをチェック サービスの制限 サービスの制限値と利用状況をチェック Shield AWS Shield Advancedは、EC2インスタンス・ELB・CloudFrontなどを対象にDDoSから保護する WAF AWS WAFは、CloudFront・ALB・API Gatewayなどを保護する Web ACLのアクセスコントロールリストで、IPアドレスなどに対してフィルタリングできる 接続元のIPアドレスから国別にアクセスを制限できる KMS 鍵の作成者ではないIAMユーザー・IAMロールが鍵で暗号・復号をしたい場合はキーユーザーとして使用者を追加する 鍵の使用ログはCloudTrailに記録される CloudHSM AWS CloudHSMでは、専用のハードウェアデバイスで鍵を生成・管理する 鍵の管理はユーザーが行う ハードウェアの管理はAWSが行う Route 53 ゾーン情報はホストゾーンで管理する パブリックホストゾーンはインターネットなどVPC外に公開されたドメインのDNSレコードを管理する プライベートホストゾーンはVPC内に公開されたドメインのDNSレコードを管理する エイリアスレコードはDNSレコードの1つで、AWSサービスのドメイン名に割り当てた別名から直接IPアドレスへ名前解決ができる Zone Apex（最上位のドメイン名）の別名を登録できる 位置情報ルーティングポリシーはクライアントの位置情報に基づいてIPアドレスを決める（例えばクライアントに合った使用言語ページを表示できる） 地理的近接性ルーティングポリシーはクライアントと地理的に近いリージョンのIPアドレスを決める 複数値回答ルーティングポリシーとフェイルオーバールーティングポリシーはヘルスチェックの結果に基づいて回答する CloudFront フィールドレベル暗号化は送信されたHTMLフォームのPOSTリクエストの一部のフィールドを暗号化し、特定のアプリケーションでのみ復号可能とする機能 OAIはS3へのアクセスをCloudFront経由でのアクセスに限定する機能 地理的制限はクライアントからのアクセスを国別に制限できる機能 Global Accelerator AWS Global Acceleratorは、ユーザーからAWSリソースまでのアクセス経路を最適化するサービス 複数のリージョンで展開しているWebアプリケーションなどへのリージョン間の負荷分散が可能 固定のパブリックIPアドレスが利用可能 Direct Connect Direct ConnectロケーションはオンプレミスとAWSのデータセンターとを相互に接続するポイント Direct ConnectエンドポイントはDirect Connectサービス提供範囲にあるオンプレミス側の終端のルーター Direct ConnectゲートウェイはDirect Connectエンドポイントと仮想プライベートゲートウェイの間に配置される VPN Site-to-Site VPNは、カスタマーゲートウェイ（オンプレミスのルーター）とVPCの仮想プライベートゲートウェイをインターネットVPNで接続する VPNトンネルを経由したネットワークトラフィック情報は、Amazon CloudWatchで収集できる SQS SQSはフルマネージドのメッセージキューイングサービス 可視性タイムアウトは、メッセージを受信した後に指定時間が経過するまでそのメッセージが他のクライアントから受信できないようにする 遅延キュー・メッセージタイマーは、送信したメッセージを指定時間経過後に受信させる デッドレターキューは、エラーが一定回数に達したメッセージを隔離する ショートポーリングではメッセージがない場合に空のレスポンスを返す ロングポーリングではメッセージが空である場合に設定された時間を待つ 似たサービスで、Apache ActiveMQ・RabbitMQに対応したフルマネージドのメッセージブローカーサービスであるAmazon MQがある SNS SNSはプッシュ型のメッセージングサービス 通知方法は、Eメール・HTTP/HTTPS・モバイル端末へのプッシュ通知などを利用できる Kinesis Amazon Kinesisはストリーミングデータをリアルタイムで収集・処理する Kinesis Data Analyticsは、Kinesis上のストリーミングデータを処理し、可視化・分析を行う Kinesis Data FirehoseはストリーミングデータをS3・Redshift・OpenSearch Serviceなどへ配信する Kinesis Data Streamsは外部から送信されるストリーミングデータを収集する EMR EMRはビッグデータの処理や分析を行う サーバー（EC2インスタンス）の管理が必要 HDFSでHadoopのファイルシステムを利用できる EMRFSでS3をEMRクラスターからファイルシステムとして利用できる Glue Glueは、フルマネージドのサーバーレスETLサービス サーバー等の管理が不要 クローラーはデータソースからデータを抽出しデータカタログを作成する データカタログは抽出データのメタデータ（データの属性情報）が保存されたもの データカタログはEMR・Athenaから参照できる AWS Data Pipelineは、データの移動や変換を自動化するサービス S3からDynamoDBへデータを取り込んだり、RDSからRedshiftへのデータコピーが可能 Athena AthenaはS3上のデータに対して標準SQLを実行できる CSV・JSON・Parquetなどのデータ形式に対応している Transcribe Transcribeは、機械学習を利用して音声をテキストに変換する Comprehend Comprehendは、機械学習を利用してテキストデータを解析する Comprehend Medicalは医療情報に特化したサービス Textract Textractは、機械学習を利用したOCR（光学的文字認識）サービス スキャンしたドキュメントやPDFからテキストやデータを抽出する SSM SSM（Systems Manager）は、複数のAWSリソースをグループ化し、グループ内リソースの運用管理サービス AWS Systems Manager Session Managerは、EC2インスタンスへブラウザ・CLIからセキュアにログインできる AWS Systems Manager Parameter Storeは、DBなどにアクセスする際のパラメーターを管理する AWS Systems Manager Patch ManagerはEC2インスタンスのOSパッチ適用を自動化する Config AWS Configは、AWSリソースの設定を管理・記録・評価するサービス Directory Service AWS Directory Serviceは、MicrosoftのActive Directory (AD) をAWS上で提供するマネージドサービス Secrets Manager AWS Secrets Managerは、データベースのログイン時の認証情報などを管理する ローテーション機能で定期的にシークレットを更新する Cognito Amazon Cognitoは、モバイルアプリケーション・Webアプリケーションのユーザー認証機能を提供する 参考文献 Exam Readiness: AWS Certified Solutions Architect – Associate (Digital) (Japanese) (日本語実写版) | Class Central"},{url:"/dimzakki-mainroad/domain-to-route53/",title:"【AWS】Amazon Route 53に他サービスの独自ドメインを移管する",date:"2023-07-29T00:00:00Z",body:"【AWS】Amazon Route 53に他サービスの独自ドメインを移管する ムームードメインで取得した独自ドメインをAmazon Route 53へ移管しましたので、移管の流れを備忘録として残します。 関連記事\r【Hugo】WordPressブログをHugo・AWSに移行した 【Hugo】ローカルにサイト（Mainroadテーマ）を構築する【サイト構築①】 【AWS】HugoをS3・CloudFrontにデプロイする【サイト構築②】 【Hugo】Github ActionsでS3に自動でデプロイする【サイト構築③】 ドメインをRoute 53で管理する利点 Route 53はAWSのDNS（ドメインネームシステム）サービスです。ドメインの管理やDNS権威サーバの役割を果たします。 当サイトはムームードメインで取得した独自ドメイン（dimzakki.com）を使い、ロリポップのサーバーにWordPressをホストしてます。そのドメインを、Route 53へと移管しました。移管料金は13ドル（移管してから1年分の管理費）かかりました。 ドメインをRoute 53で管理するメリットとしては、当サイトの様にS3・CloudFrontでホスティングする場合にSSL対応（HTTPS化）ができる点が大きいです。その他、DNSサーバー自体が冗長化されており、高いSLA（サービス品質保証）が保証されていることなどが利点になります。 作業の流れと必要な物 ドメイン移管の流れとしては、ざっくり分けると以下の2つになります。 ドメイン移管の流れ\rネームサーバー設定を移管元サービスからRoute 53へ変更する ドメインを移管元サービスからRoute 53に移管する ドメインを移管する前にネームサーバー設定をRoute 53へ変更しているのは、これを行わないとドメインの移行時にDNSサービスが使えなくなり、サイトにアクセスできなくなる可能性があるからです。 必要なものは移管元のドメインの管理権限に加え、AWSアカウントと（既にDNSでサービスを管理している場合は）サーバーの公開IPアドレスです。 また、既に独自ドメインでWordPress等のサービスを運営している場合は、作業前にバックアップをとっておきましょう。 ロリポップのサーバーのIPアドレスの確認 ロリポップの場合、ユーザーページの「ロリポップ！のドメイン」のIPアドレスがサーバーのIPアドレスになります。 ロリポップのサーバーIPアドレス確認1 IPアドレス自体はロリポップには書いていないので、自分で調べる必要があります。nslookupコマンドや「Google Admin Toolbox dig」などで調べ控えておきます。 ロリポップのサーバーIPアドレス確認2 ここで確認したIPアドレスを後でRoute 53に設定します。 Route 53でホストゾーンの作成・ネームサーバ設定の変更 ここから移管の作業を始めていきます。今回はムームドメインで取得した独自ドメイン移管を例として解説していきます。 まず、Route 53のダッシュボードからホストゾーンの作成を行っていきます。 ホストゾーンの作成1 ドメイン名は移管するドメイン名、タイプはパブリックホストゾーンを選択します。 ホストゾーンの作成2 ホストゾーンを作成すると、NSレコードが4つとSOAレコードが作成されます。ここのNSレコードを使って、ムームドメインでDNS設定を変更していきます。 ホストゾーンの作成3 ムームドメインにログインしネームサーバ設定変更から設定を変更していきます。今回の場合、変更前はロリポップのネームサーバーに設定されています。 ネームサーバ設定変更1 これを先ほどの4つのNSレコードに書き換えます。ここで、末尾の.は入力する必要はありません。 ネームサーバ設定変更2 ネームサーバ設定変更3 これで、ネームサーバー設定はRoute 53になりましたが、ドメイン名とIPアドレスが紐づいていませんので、Aレコードの設定をしていきます。 Route 53のホストゾーンからレコードの作成を行います。 レコードの作成1 レコードタイプをA、値を先ほど控えたIPアドレスを入力します。ここで、必須ではありませんがサブドメインのwww.dimzakki.comでもアクセスさせたいので、もう1つAレコードを追加作成しています。 レコードの作成2 レコードの作成3 これで、ネームサーバの設定変更が完了になります。nslookup等での疎通確認と、サイトへアクセスできるかも確認しておきましょう。設定が切り替わるまで、少し時間が掛かる可能性もあります。 ドメインをRoute 53に移管する 次に、ドメイン自体の移管を行います。 まず、準備として、Whois代行サービスを設定している場合は設定を解除しておきます。ドメイン移管時に送られる承認メールから承認を行うため、メールが届くようにするためです（ここで設定を解除しても、移管時にまたプライバシー保護の設定ができます）。 また、認証コード（AuthCode）もドメイン移管時に必要となるので控えておきます。 ドメインの移管1 Route 53の登録済みドメインから移管（イン）の単一のドメインを選択します。 ドメインの移管2 移管ドメイン名と、確認のチェックを入力します。移管可否のステータスが「移管可能」になっていることも確認しましょう。 ドメインの移管3 DNSサービスは先程設定したネームサーバーを使うので、このままでOKです。 ドメインの移管4 ドメインの認証コードの入力を求められるので、控えておいた認証コードを入力します。 ドメインの移管5 ドメイン登録者（自分）の連絡先情報を入力します。管理者も技術者も同じなのでチェックを入れます。プライバシーの保護にもチェックを入れます。 ドメインの移管6 最終的な確認画面になりますので、確認のチェックを入れてリクエストを送信をクリックします。 ドメインの移管7 時間を少し置くと、移管元から確認のメールが来ますので、メール内のリンクから承認を行います。 ドメインの移管8 ドメインの移管9 ここで、連絡先（メールアドレス）の検証を行っていないと、Route 53から「Verify your email address for ～」というメールが届くので、メール内のリンクをクリックしてメールアドレスの検証を行いましょう（これをしておかないと、ドメインが停止されてしまいますので注意）。 ここまでドメインの移管作業は終わりです。登録済みドメインに、移管したドメインが載っていることを確認しましょう。 ドメインの移管10 ここまで、Route 53へのドメイン移管の解説でした。以上で記事を終わりにします。 参考文献 Route 53 を使用中のドメインの DNS サービスにする | AWS ドメイン登録の Amazon Route 53 への移管 | AWS"},{url:"/dimzakki-mainroad/qualification-aws-clf/",title:"【AWS CLF】合格体験記【未経験で約1か月で合格】",date:"2023-07-22T00:00:00Z",body:"【AWS CLF】合格体験記【未経験で約1か月で合格】 AWS Certified Cloud Practitioner（クラウドプラクティショナー）試験（CLF-C01）を2023年6月に受け合格しましたので、試験の対策・結果・感想などを合格体験記としてまとめたいと思います。 関連記事\r【AWS CLF】試験対策用備忘録メモ【クラウドプラクティショナー】 試験概要・難易度 AWS CLF試験はAWS認定資格の中で入門レベルの資格に位置しています。AWSクラウド・サービス・用語について基礎的な理解が求められます。 項目 詳細 出題形式 選択問題・CBT方式 出題数 65問 試験時間 90分 合格点 700点以上（1,000点満点） 受験料 100ドル 合格点は1,000点満点中700点以上となっていますが、得点は100～1,000のスケールスコアで採点され、問題の配点が非公開のため、単に7割正解すればOKという訳では無いことに注意しましょう。合格率も非公開になっています。 試験としては、あくまで各分野の基礎が問われていますので、試験範囲の基礎を全般的に抑えられるかが重要です。しかし、試験で扱われる範囲が中々広いので、難易度としてはAWSの一番下のレベルの試験にしては結構高いんじゃないかなと感じました。単純に比較はできませんが、ITパスポート試験よりかは一段難しいと思います。 試験申し込み～試験対策 実際に私が受験を決めてから、試験本番までの流れを書いていきます。当時のプロフィールは以下になります。 プロフィール\r開発系のITエンジニア（2年目） AWSを業務で使用することはほぼなし 受験のきっかけ・申し込み 受験しようと決めた理由は、AWSへの興味もありましたが、会社の査定のためというのが大きかったです。CLFとその上の資格であるSAA（ソリューションアーキテクトアソシエイト）まで取得することで査定評価でプラスされるので、とりあえずそこまで取得しようと思っていました。 申し込みは公式サイトからピアソンビューで行いました。 実際にやった試験対策 ここから実際に行った試験対策について書いていきます。試験勉強では、参考書とWebの問題集を使いました。勉強期間は1ヶ月くらいで、勉強時間は30時間くらいでした。 まず始めに、ざっとAWS全体の基本を抑えるため、参考書の「AWS認定資格試験テキスト AWS認定 クラウドプラクティショナー 改訂第3版」を一周通して読みました。通称緑本と呼ばれており、最初の取っ掛かりとしては良い参考書だと思います。載っている練習問題の数は多くはありませんでした。新版が出ているので、そちらを紹介します。 AWS認定資格試験テキスト　AWS認定 クラウドプラクティショナー　改訂第3版 (ＡＷＳ認定資格試験テキスト)\r2,970円～ amazon.co.jp 参考書を読んだだけでは知識が定着しませんので、WEB問題集の「AWS認定資格 無料WEB問題集＆徹底解説」を解いていました。無料かつ問題の数は多く、各問題にコメント欄が搭載されているのが特徴です。少し気になった点として、後半の問題で問題文・選択肢の日本語がおかしい物が散見されました。コメント欄でも指摘・訂正されているので、コメントを参考にしつつ周回していけば良いと思います。 試験直前になって、上記の対策で大丈夫か不安になったので、公式で試験範囲がまとめられている「AWS Cloud Practitioner Essentials」にも目を通しました。こちらも無料ですが公式が出している物ですので、試験範囲の事項が分かりやすくポイントがまとめられています。 また、試験勉強と並行してポイントになりそうな所を「【AWS CLF】試験対策用備忘録メモ【クラウドプラクティショナー】」の記事にメモとしてまとめてみました。 試験本番・結果 試験は土曜日午前に受けました。試験会場はOracleの試験で来たことのあるビルでしたので、スムーズに受付までできました。受付の際は、本人確認に身分証明書が2点必要なので、事前にちゃんと確認しておきましょう。 試験では勉強した通りの問題はあまり出ないので、自分の中での手応えはイマイチでした。出題傾向としては長文の問題が結構出されていました。見直しも含めて、試験時間は30分くらいは残して終了しました。元々暗記が苦手なのもありますが、やはり勉強不足感が否めませんでしたね。 試験結果が以下になります。 AWS CLFの試験結果 結果は789点で合格でした。正直、試験中は合格しているか半々くらいかなと感じていましたが、配点が非公開のせいか思ったより点が伸びていましたね。 おすすめの試験対策について 今回の受験を踏まえての、おすすめの試験対策についてまとめていきます。 まず始めに、試験範囲の確認として範囲を網羅している参考書か、公式の「AWS Cloud Practitioner Essentials」を学習すると良いと思います。その後、WEB問題集やUdemyの有料問題集等で問題を繰り返し解いていくことがおすすめです。 なお、AWS試験では、「ブレインダンプサイト」と呼ばれる流出した過去問を販売しているサイトもあります。これらは、そもそもの運営元自体が怪しいものだったり、問題が古いバージョンから更新されていなかったりするので、避けた方が無難です。 AWSに慣れるため、ハンズオンで動かして学習するという対策方法もありますが、この様な方法は学習に時間が掛かってしまうので、合格が目的の場合は個人的にはあまりおすすめ出来ません。 確かに、当サイトでもAWSで運用していますので、実際にAWSを使うことが一番スキルが身に着くというのは理解できるんですけどね…。合格一点狙いの方は問題演習を中心にこなしましょう。 今回はAWS CLFの合格体験記についてまとめました。最近では、「Ping-t」にて、「CLF-C02」の「無料問題集」が出ているので、こちらも活用すると良いかもしれません。 以上で記事を終わりにします。 関連記事\r【AWS SAA】合格体験記【約1か月で合格した勉強方法】 参考文献 AWS Certified Cloud Practitioner 認定 | AWS"},{url:"/dimzakki-mainroad/wordpress-to-hugo/",title:"【Hugo】WordPressブログをHugo・AWSに移行した",date:"2023-07-16T00:00:00Z",body:"【Hugo】WordPressブログをHugo・AWSに移行した レンタルサーバーで運営していたWordPressブログをHugoに乗り換え、サイトのホスティングもAWS（S3・CloudFront）に変更しました。移行の理由や感想等を書いていきます。 当サイトの構成について 今回新サイトに移行するまでは、レンタルサーバーにWordPressをインストールし、ドメイン取得サービスで取得した独自ドメインのdimzakki.comでサイトを運営していました。 WordPress・レンタルサーバーの構成 WordPressでのブログ運営時から一貫していたことですが、あくまで趣味としてのブログ運営であることから、なるべく低コストで運営することを重視していました。レンタルサーバーは一番安いプランにし、ドメインは無料キャンペーンで取得したものを維持してきました。今まで運営で掛かっていた費用は年間6,000円未満のサーバー代のみでした。 ただ、安いプランを契約していると、サーバー性能が貧弱なのでサイトのスピードがあまり出ませんでした。その為、なるべくサイト速度が低下しないようブログ内容も余計な機能や装飾を抑え、シンプルな内容にしてきました。 この度、ブログの構成を一新し、レンタルサーバーメインの構成から、AWS上への運営へと移行することにしました。具体的には、サイトコンテンツを静的サイトジェネレータ（SSG）であるHugoに移行して、AWS S3にデプロイしています。 また、SSL対応やパフォーマンス向上の為CloudFrontをキャッシュサーバーとしています。併せてドメインもAmazon Route 53へ移管しました。 また、サイトのコンテンツはGit（Github）で管理しており、ブログ更新時のHugoのビルドとS3へのデプロイはGitHub ActionsによるCI/CDパイプラインを用いて自動的に行っています。 Hugo・AWS構成 補足：SSGについて SSGとは、「Static Site Generator（静的サイトジェネレーター）」の略で、文字通り静的なHTMLを生成するツールのことです。静的であるため、アクセスしたユーザーには常に同じ内容が表示されます。有名なSSGには、Hugoの他にGatsbyやJekyllなどがあります。 反対に、WordPressは動的サイトに分類され、アクセスしたユーザー毎に自動でページ生成されて表示されます。 HugoはGo言語で実装されており、ビルドの掛かる時間が高速であることが大きな特徴です。また、ブログ用のテンプレートが豊富にあることもメリットの1つですね。 Hugoに移行した理由 今回、WordPressからHugoへ移行した一番の理由は、コストを抑えつつ高速化したかったからです。 WordPressである程度のサイトスピードを得るには、それなりの性能のサーバーを使用する必要があり、結果サーバーの費用が掛かるので大きく赤字運営となってしまいます。 当サイトではWordPressで実現できる様な複雑な機能は特に必要としていないので、それなら静的サイトジェネレータで低コストかつ速度を重視したサイトへ変えようと思った訳です。 Hugo・AWS構成は、静的サイトジェネレータの中ではこの構成が比較的メジャーであり、ネット上の参考文献も他より多かったことも理由になりました。 また、AWSはこれまで仕事であまり使う機会が無かったので、AWSへの知見を深めるのにも丁度良いと思ったのも理由の1つになります。 Hugoのメリット ここから、レンタルサーバー・WordPressからHugo・AWSに移行するにあたってのメリットについてまとめます。 1.サイトスピードに優れる Hugoは静的サイトジェネレーターであり、生成したHTMLを公開しているだけなので、表示速度に優れているのが大きな特徴です。 対して、WordPressではリクエスト毎にPHPでデータベースにアクセスしてページを生成しているため、どうしても重くなってしまいます。 2.セキュリティリスクが少ない WordPressではWeb上の管理ツールでサイト管理を行うので、不正アクセスなどのセキュリティリスクが付きまといます。また、プラグインも様々な開発元が制作していますので、脆弱性が発生する可能性があります。 静的サイトであるHugoにはそのようなリスクは無いため、セキュリティ的に堅牢であると言えます。なお、ホスティングに使用するAWSについては、アカウント乗っ取りなどのリスクがあるため、最低限ログイン時のMFA（2段階認証）の有効化をする必要があります。 3.コストパフォーマンスに優れる このサイト構成の場合に掛かる費用は、AWSでのRoute 53・S3・CloudFrontの利用代のみになります。費用はドル換算のため、為替レートによって変動はありますが、個人のブログサイト程度ならレンタルサーバーと比較して非常に低コストで運営ができます。 厳密に言うと、DDoS攻撃によって高額な請求が発生する、いわゆるEDoS（Economic Denial of Sustainability）攻撃のリスクは存在しますが、個人サイトなので、そこまで気にしなくてもいいかなと思います。費用は掛かりますが、AWS WAFなどで対策することができます。 4.コンテンツ管理が簡単 Hugo・AWS構成ではサーバーやDBを管理する必要もありません。また、サイトの内容についてはGitHubのリポジトリにソースファイルを置くことでWordPressより低コストでバージョン管理が可能です。 Hugoのデメリット 次に、Hugoのデメリットについてもまとめます。 1.サイト構築の難易度が比較的高い Hugoだけではなく、AWSやGitの基礎知識が必要なので、WordPressよりは若干ハードルが高いです。 とは言え一度構築さえしてしまえば、記事の更新にはGitへのプッシュだけで簡単に行えます。 2.日本語の資料が少ない ネット上のドキュメントの数は、WordPressに比べると圧倒的に少ないです。場合によっては、英語の資料もある程度見ていく必要があります。 3.動的な機能が使えない Hugo上で人気記事ランキング・お問い合わせフォーム・コメント機能の様な動的な機能を実装するのには、ある程度カスタマイズが必要になってきます。なお、最低限必要なお問い合わせフォームに関しては、こだわりが無ければGoogleフォームで簡単に実装が可能です。 Hugoへの移行手順 WordPressからHugo・AWSに移行した際のメモを、備忘録として記事にまとめました。 レンタルサーバーのドメインをRoute 53に移管する 【AWS】Amazon Route 53に他サービスの独自ドメインを移管する Hugoをローカルに構築してコンテンツを移す 【Hugo】ローカルにサイト（Mainroadテーマ）を構築する【サイト構築①】 HugoをS3にデプロイし、CloudFrontで配信する 【AWS】HugoをS3・CloudFrontにデプロイする【サイト構築②】 GitHubで自動デプロイを設定する 【Hugo】Github ActionsでS3に自動でデプロイする【サイト構築③】 以上の4つのプロセスでサイトを運営することができました。 また、必須の機能ではありませんが、人気記事ランキングも実装してみました。 関連記事\r【Hugo】PV数の人気記事のランキングを取得する【Node.js】 移行した感想 とりあえず、無事にHugo・AWSへサイトを移行できたので一安心です。ブログ自体もサイトスピードが大きく向上しました。 手順の中で、一番時間が掛かったのはサイトコンテンツの移行でした。サイトの構築自体は参考文献が色々とありましたので、思ったよりスムーズに行きました。 運営コストについては、初月はドメイン代が掛かっているものの、以降の月は平均して1ヶ月で100円以下と非常に安く運用できています。 2023年6月以降のサイト運営コスト 悲しいことに、移行した後にロリポップの自動更新を切るのを忘れていて、結局プラス1年サーバー代を払うことになってしまいましたが…。 以上がWordPressからHugoへの移行についての話になります。AWSの各種サービスも色々と触ることができましたので、良い勉強になったと思います。 今後もサイトの更新を進めていきたいと思います。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/oracle-pearsonvue/",title:"【IT資格】OracleアカウントとCertViewアカウントの登録方法",date:"2023-07-05T00:00:00Z",body:"【IT資格】OracleアカウントとCertViewアカウントの登録方法 Oracleの認定資格を受験する際に、必要なアカウントの登録方法についてまとめます。 受験に必要なもの オラクルマスター試験やOracle認定Java試験などに初めて申し込む際には、認定資格の主催者であるOracleのアカウントと、試験の情報を管理するポータルサイトであるCertViewのアカウントが必要になります。 2つのアカウント登録方法について紹介していきます。 Oracleアカウントの登録 まず、以下のページからOracleアカウントを作成していきます。 Oracle | プロファイルの作成 Oracleアカウントの登録 CertViewアカウントの登録 続いて、CertViewアカウントの登録を行います。以下のページからCertviewへログインできます。英語になっている場合は、右上のメニューから言語の切り替えも可能です。 Certview へのログイン | Oracle University CertViewアカウントの登録1 Oracleアカウントのログイン画面になるので、先ほど作成したアカウントでログインします。 CertViewアカウントの登録2 その後、初回ログイン時のみ認証を行う必要があります。やり方は公式に乗っている通り1になります。 「ピアソンVUEのアカウントをお持ちですか？」の回答に「いいえ、持っていません。」を選択後、同意確認画面で「同意します」をクリックします。 CertView登録の画面になるので、登録情報を入力し、「送信」をクリックします。 今回はOracleアカウントとCertViewアカウント登録方法を紹介しました。ちょっと複雑で面倒ですが、2つのアカウントを作成すればCertviewからピアソンVUEで試験を予約できるようになります。以上で記事を終わりにします。 参考文献 Oracle.comのユーザー登録方法 | Oracle University CertView 初回ログイン時の手続き方法 CertView 登録 | Oracle University&#160;&#x21a9;&#xfe0e;"},{url:"/dimzakki-mainroad/aws-clf-measures/",title:"【AWS CLF】試験対策用備忘録メモ【クラウドプラクティショナー】",date:"2023-06-04T00:00:00Z",body:"【AWS CLF】試験対策用備忘録メモ【クラウドプラクティショナー】 AWS Certified Cloud Practitioner（クラウドプラクティショナー）試験（CLF-C01）の試験対策用の備忘録メモになります。試験の範囲である、AWSの各サービス・セキュリティ・料金等についてまとめています。 関連記事\r【AWS CLF】合格体験記【未経験で約1か月で合格】 クラウドコンピューティング クラウドコンピューティングの概要 クラウドコンピューティングとは、従量課金制による、インターネット経由のITリソースとアプリケーションのオンデマンド配信 クラウドコンピューティングには3つのデプロイモデルがある クラウドベース（クラウドへの移行・構築） オンプレミス（リソースをオンプレミスにデプロイ） ハイブリッド（クラウドベースのリソースをオンプレミスのインフラストラクチャへ接続） クラウドコンピューティングの利点 先行支出を変動支出に切り替える データセンターの維持管理費用が不要 キャパシティーの予測が不要 圧倒的なスケールメリット スピードと俊敏性を向上 数分でグローバルに展開 Amazon EC2 Amazon EC2（Elastic Compute Cloud）は、EC2インスタンスとしてサイズ変更可能で安全なコンピューティングキャパシティーを提供する EC2インスタンスは数分以内にプロビジョニング・作成ができる ワークロードの実行が終了したら使用を停止できる 料金はインスタンスの実行時に使用したコンピューティング時間に対してのみ支払いが発生する 必要なサーバー容量に対してのみ支払うのでコスト削減できる EC2インスタンスタイプ 汎用インスタンス コンピューティング、メモリ、ネットワークのリソースのバランスに優れている コンピューティング最適化インスタンス 高パフォーマンスプロセッサにより計算パフォーマンスが高い 計算負荷の高いサーバーなどに適している 多くのトランザクションを処理するバッチ処理にも適している メモリ最適化インスタンス メモリ量が多く高速 高パフォーマンスのデータベースなどに適している 高速コンピューティングインスタンス 浮動小数点数計算、グラフィックス処理、データパターン照合のパフォーマンスが高い ゲームストリーミングや画像処理に適している ストレージ最適化インスタンス ストレージアクセスが速い 分散ファイルシステムなどに適している EC2の料金 オンデマンドインスタンス インスタンスを停止するまで、使用したコンピューティング時間に対して料金が発生する 中断できない不規則で短期的なワークロード向け Amazon EC2 Savings Plans 一定のコンピューティング使用量を1年または3年の期間で契約 契約した使用量に達するまでは割引料金（Savings Plans料金）で、超えた分についてはオンデマンド料金になる オンデマンドの料金に比べて料金を最大72%節約できる リザーブドインスタンス 1年または3年の契約でオンデマンドインスタンスを割引価格で購入 期間の終了後はインスタンスを削除するか、新しいリザーブドインスタンスを購入するまでオンデマンドの料金になる スポットインスタンス 未使用のEC2コンピューティングキャパシティーを使用する キャパシティーが使用できなくなったり、スポットインスタンスの需要の増加でインスタンスが中断される可能性がある 開始時刻と終了時刻が定まっていないワークロードや、中断可能なワークロード向け オンデマンドの料金に比べて料金を最大90%節約できる Dedicated Hosts 専用のインスタンスキャパシティーを備えた物理サーバー 料金は最も高価 EC2のスケーリング EC2 Auto ScalingでEC2インスタンスの自動的な作成・削除が可能 動的スケーリングと予測スケーリングがある ELB ELB（Elastic Load Balancing）はアプリケーションへのトラフィックを、EC2インスタンスなどのリソースへ自動的に分散するサービス メッセージング・キューイング Amazon SNS（Simple Notification Service）はメッセージングサービス SNSトピックを使用してウェブサーバ・Eメールアドレス・Lambda関数へメッセージを配信する Amazon SQS（Simple Queue Service）はメッセージキューイングサービス ソフトウェアコンポーネント間でメッセージを送信・保存・受信できる その他 AWS Lambdaではサーバーのプロビジョニングや管理を行うことなく、コードを実行できる 料金は使用したコンピューティング時間に対してのみ発生する Amazon ECS（Elastic Container Service）はAWS上でコンテナを管理できる Dockerをサポートしている Amazon EKS（Elastic Kubernetes Service）はAWS上でKubernetesを管理できる Kubernetesはコンテナ化されたアプリケーションをデプロイ・管理できるオープンソースソフトウェア AWS Fargateは、コンテナ向けのサーバーレスコンピューティングエンジン Amazon ECSと Amazon EKSで利用できる グローバルインフラストラクチャ AWSグローバルインフラストラクチャ リージョンの選択には以下の4つの要素を考慮する データガバナンスと法的要件の遵守 ユーザーとの近接性 リージョン内で利用可能なサービス 料金 アベイラビリティーゾーンは、リージョン内の1つのデータセンターまたはデータセンターのグループで構成される エッジロケーション エッジロケーションは、Amazon CloudFrontでキャッシュコンテンツをユーザの近くに保存・配信するための場所 プロビジョニング AWS マネジメントコンソールは、AWSサービスを管理するためのウェブベースのインターフェイス AWS CLI（コマンドラインインターフェイス）は、コマンドラインからAWSサービスを管理する OSはWindows、macOS、Linuxに対応している AWSではSDK（ソフトウェア開発キット）を利用できる AWS SDKはAWSサービスをプログラムなどから操作できるようにするための開発キット AWS Elastic Beanstalkでは、アプリケーションを自動的にデプロイできる AWS CloudFormationでは、安全で繰り返し可能な方法でリソースをプロビジョニングできる インフラストラクチャをコードとして扱うことができる AWS Outpostsでは、AWSのインフラストラクチャとサービスをオンプレミスのデータセンターに拡張できる ネットワーク AWSへの接続 Amazon VPC（Virtual Private Cloud）では、AWSクラウドに独立した仮想ネットワークを構築できる 仮想ネットワークの中にリソースを起動できる VPC内をサブネットで区別し、リソースをその中に配置することが可能 インターネットとVPCを接続するには、インターネットゲートウェイをVPCにアタッチする VPC内のプライベートリソースにアクセスするには、仮想プライベートゲートウェイを使用する AWS Direct Connectで、データセンターとVPCの間に専用のプライベート接続を確立できる サブネット・ネットワークアクセスコントロールリスト サブネットはリソースをグループ化できるVPC内のセクション パブリック・プライベートに設定することができる ACL（ネットワークアクセスコントロールリスト）は、サブネットへのアクセス許可をチェックする仮想ファイアウォール インバウンドトラフィック・アウトバウンドトラフィックを制御する デフォルトのネットワークACLは、全てのインバウンド・アウトバウンドトラフィックを許可される カスタムネットワークACLは、許可ルールを追加するまで、全てのインバウンド・アウトバウンドトラフィックが拒否される セキュリティグループは、EC2インスタンスのインバウンド・アウトバウンドトラフィックを制御する仮想ファイアウォール デフォルトでは、全てのインバウンドトラフィックを拒否し、全てのアウトバウンドトラフィックを許可する グローバルネットワーク Amazon Route 53はAWSでホストされているインターネットアプリケーションにエンドユーザーをルーティングする ドメイン名のDNSレコードを管理することもできる ストレージとデータベース インスタンスストア・Amazon EBS インスタンスストアは、EC2インスタンスのブロックレベルの一時ストレージ インスタンスが削除されると、インスタンスストアのデータは失われる Amazon EBS（Elastic Block Store）は、EC2インスタンスで使用できるブロックレベルのストレージボリューム EC2 インスタンスが停止または削除されてもEBSのデータベースは保持される EBSスナップショットで、増分バックアップを作成できる 1つのアベイラビリティーゾーンにデータを保存する Amazon S3 Amazon S3（Simple Storage Service）は、データをオブジェクトとしてバケットに保存する S3 標準 頻繁にアクセスされるデータに最適なストレージクラス S3 標準–IA アクセス頻度が低いが、必要なときにすぐに使用できる高可用性が求められるデータ向け ストレージ料金が低く、取り出し料金が高い S3 1ゾーン–IA 1つのアベイラビリティーゾーン内にデータを保存する S3 標準–IAよりもストレージ料金が低い S3 Intelligent-Tiering S3 標準とS3 標準–IAを自動的に移動する S3 Glacier 数分から数時間以内にオブジェクトを取得できる 料金が低価格 S3 Glacier Deep Archive 12時間以内にオブジェクトを取得できる 料金が最も低価格 Amazon EFS Amazon EFS（Elastic File System）は、スケーラブルなファイルシステム ファイルを追加・削除でEFSが自動的に拡張・縮小する 複数のアベイラビリティーゾーンにデータを保存する Amazon RDS Amazon RDS（Relational Database Service）は、AWSでリレーショナルデータベースを実行する Amazon Auroraは、MySQL・PostgreSQLと互換性があり、高速なリレーショナルデータベース 3つのアベイラビリティーゾーン間にデータのコピーが6つ作成される Amazon DynamoDB Amazon DynamoDBはキーバリューデータベース（NoSQLデータベース） Amazon Redshift Amazon Redshiftはビッグデータ分析に使用できるデータウェアハウジングサービス AWS DMS AWS DMS（Database Migration Service）でデータベースの移行ができる その他 Amazon DocumentDBは、MongoDBをサポートするドキュメントデータベースサービス Amazon Neptuneは、グラフデータベースサービス Amazon QLDB（Quantum Ledger Database）は、台帳データベースサービス Amazon Managed Blockchainでは、ブロックチェーンネットワークを作成・管理できる Amazon ElastiCacheは、データベースの上にキャッシュレイヤーを追加するサービス Amazon DAX（DynamoDB Accelerator）は、DynamoDB のインメモリキャッシュ セキュリティ 責任共有モデル AWSの責任共有モデルには、AWSが責任を持つものとユーザが責任を持つものがある AWSはクラウド本体のセキュリティに責任を持つ データセンターの物理的なセキュリティ ハードウェア・ソフトウェアインフラストラクチャ ネットワークインフラストラクチャ 仮想化インフラストラクチャ ユーザはAWSクラウド内で作成・配置したものに対するセキュリティの責任を持つ ユーザのコンテンツへのアクセス権の管理 EC2インスタンスで実行するOSの選択・設定・パッチ適用・セキュリティグループの設定 ユーザのアクセス許可・アクセス権 AWS IAM（Identity and Access Management）ではAWSサービス・リソースへのアクセスを管理できる ルートユーザーはAWSアカウントを初めて作成する時に作成される 全ての操作ができ、最も権限が強い 日常的なタスクではルートユーザーを使用すべきでない IAMユーザーは、ユーザがAWS内に作成するID 名前と認証情報で構成される デフォルトではアクセス許可が何も無いので、IAMユーザーに必要なアクセス許可を付与する AWSにアクセスする必要があるユーザー毎に、個別のIAMユーザーを作成することが推奨される IAMグループは、IAMユーザーの集合 IAMポリシーは、AWSサービスとリソースへのアクセス許可を付与・拒否するドキュメント リソースへのユーザーのアクセスレベルをカスタマイズできる 特定のS3バケットへのアクセスのみを許可するなど IAMポリシーをIAMユーザー・IAMグループにアタッチして使う IAMロールでは、アクセス許可を一時的に利用するために引き受けることができる IAMロールを引き受けると、以前のロールのアクセス許可が取り消され、新しいロールのアクセス許可が与えられる サービスやリソースへのアクセス権を一時的に付与する場合に適している 多要素認証（MFA）でセキュリティを更に強化できる スマホやハードウェアデバイスでの2つ目の認証形式 AWS Organizations AWS Organizationsでは、複数のAWSアカウントをまとめて管理できる SCP（サービスコントロールポリシー）で複数のAWSアカウントのアクセス権を管理できる 一括請求を行える アカウントを組織単位（OU）にグループ化してアカウントの管理を行える コンプライアンス AWS Artifactでは、AWSセキュリティ・コンプライアンスレポートと特定のオンライン契約を提供する カスタマーコンプライアンスセンターでは、AWSコンプライアンスの詳細に関するドキュメントを確認できる サービスへの攻撃 AWS Shieldでは、DDoS攻撃をリアルタイムで検出し、自動的に攻撃を緩和する AWS Shield Standardでは無料で一般的なDDoS攻撃の検出・緩和を行う AWS Shield Advancedでは有料で詳細な攻撃診断と高度なDDoS攻撃の検出・緩和を行う その他 AWS KMS（Key Management Service）では、暗号化キーの作成・管理・使用を行う 暗号化キーは、AWSサービス・アプリケーションで使用・制御できる AWS WAFは、ウェブアプリケーションを保護するファイアウォール ウェブACL（アクセスコントロールリスト）でトラフィックを許可・ブロックする Amazon Inspectorでは、アプリケーションのセキュリティ評価を自動で実行する セキュリティの脆弱性・ベストプラクティスからの逸脱を検出する Amazon GuardDutyでは、VPCフローログ・DNSログ等からデータを分析し、脅威を検出する モニタリングと分析 Amazon CloudWatch Amazon CloudWatchは、様々なメトリクスデータをモニタリング・管理する 設定したしきい値を超えた時に、アクションを実行するアラームの作成ができる ダッシュボードでメトリクスデータを可視化できる AWS CloudTrail AWS CloudTrailは、AWS環境でのアカウントのAPIコールの記録・確認ができる つまり、AWSアカウント内の操作（ユーザーアクティビティも）が記録される AWS Trusted Advisor AWS Trusted AdvisorはAWS環境を検査し、リアルタイムの推奨事項（AWSのベストプラクティスに基づく）を提供する 5つのカテゴリ（コスト最適化・パフォーマンス・セキュリティ・耐障害性・サービスの制限）の推奨事項が提供される 料金とサポート AWS無料利用枠 AWS無料利用枠では、無料でAWSのサービスを使用できる 無期限無料・12か月間無料・トライアルの3種類 AWSの料金の概念 AWSサービスでは、実際に使ったリソースの量に応じて料金が発生する 一部のサービスには、前払いで割引を受けられるオプションがある 一部のサービスでは、段階制料金（使用量が増えるほど、単位あたりのコストが下がる）が用意されている AWS 料金計算ツールでは、コスト見積りの作成・比較ができる 請求ダッシュボード AWSマネジメントコンソールの請求ダッシュボードでは、リージョン別のサービスのコスト、今月の初めから現在までの支出など、AWS請求書の詳細を確認できる 請求ダッシュボードではアラートは設定できない 一括請求（コンソリデーティッドビリング） AWS Organizationsでは、一括請求（コンソリデーティッドビリング）ができる 一括請求で、1つの請求で複数のアカウントの支払いができる 複数アカウントの支払いをまとめられるため、料金のボリューム割引を受けることができる AWS Budgets AWS Budgetsで、予算を作成してサービスの使用量・コスト・インスタンスの予算を計画できる 使用量が予算量を超えた時のカスタムアラートを設定できる AWS Cost Explorer AWS Cost Explorerは、AWSのコスト・使用量を可視化して把握・管理する 上位5つのサービスのコスト・使用量のレポートがデフォルトで見られる AWSサポートプラン AWSには、無料・有料のサポートプランがある 有料のプランはデベロッパーが一番安く、エンタープライズが一番高い ベーシック アカウントの作成時に提供される無料のプラン Trusted Advisorのチェックの一部が利用できる デベロッパー Trusted Advisorのチェックの一部や、基盤となるアーキテクチャのサポートが受けられる ビジネス Trusted Advisorの全てのチェックや、ユースケースのガイダンスを受けられる エンタープライズ 他のサポートプランの全ての機能を利用できる テクニカルアカウントマネージャー（TAM）によるサポートを受けることができる AWS Marketplace AWS Marketplaceでは、ソフトウェアベンダから提供されるソフトウェアで構成されたデジタルカタログ AWSで実行するソフトウェアの試用・購入が可能 移行とイノベーション AWS CAF（Cloud Adoption Framework） AWS CAF（Cloud Adoption Framework）は、AWSへのクラウド導入フレームワーク CAFでは、6つの分野（パースペクティブ）がある ビジネスパースペクティブ ITへの投資とビジネスの成果の結び付きに重点を置く 人員パースペクティブ 組織全体の変更管理戦略に重点を置く ガバナンスパースペクティブ IT戦略をビジネス戦略に合わせるためのスキル・プロセスに重点を置く プラットフォームパースペクティブ クラウドの導入・移行のための原則・パターンに重点を置く セキュリティパースペクティブ セキュリティ目標の達成に重点を置く オペレーションパースペクティブ ITワークロードの運用と復旧に重点を置く 移行戦略 アプリケーションのクラウドへの移行では、6つの移行戦略がある リホスト アプリケーションを変更せずに移行する リプラットフォーム クラウドの最適化を行う 最適化はアプリケーションの中核となるアーキテクチャを変更せずに行う リファクタリング・アーキテクチャの再設計 アプリケーションのアーキテクチャの設計方法や開発方法を作り直す 再購入 従来のライセンスからSaaSへ移行する 保持 ソース環境でビジネスに重要なアプリケーションを従来の環境で維持する リタイア 不要になったアプリケーションを削除する AWS Snowファミリー AWS Snowファミリーは、エクサバイト規模までのデータをAWSとの間で転送できる物理デバイス AWS Snowconeは、小型で堅牢・安全なエッジコンピューティング・データ転送デバイス AWS Snowballは、2種類のデバイスがある Snowball Edge Storage Optimizedデバイスは、大規模なデータ移行・定期的な転送のワークフロー・大容量を必要とするローカルコンピューティングに適している Snowball Edge Compute Optimizedデバイスは、機械学習・フルモーション動画分析・ローカルコンピューティングスタックなどに適している AWS Snowmobileは、最大100PBのデータをAWSに転送できる AWSのイノベーション AWSでのサーバーレスは、サーバーをプロビジョニング・維持・管理の必要がない AWS Lambdaなど AWSには、人工知能（AI）を利用したサービスがある Amazon Transcribeで音声をテキストに変換する Amazon Comprehend でテキストのパターンを検出する Amazon Fraud Detectorで不正の可能性があるオンラインアクティビティを特定する Amazon Lexでは、会話型チャットボットを素早く構築できる AWSでの機械学習は、Amazon SageMakerで機械学習モデルをすばやく構築できる クラウドジャーニー AWS Well-Architectedフレームワーク AWS Well-Architectedはフレームワークは5つの柱に基づくアーキテクチャフレームワーク 運用上の優秀性 システムを運用・監視する能力 セキュリティ 情報・システム・アセットを保護する能力 信頼性 サービス障害からの復旧・コンピューティングリソースの動的な取得・サービスの中断を軽減する能力 パフォーマンス効率 コンピューティングリソースを効率良く使用し、システム要件を満たし、効率性を維持する能力 コスト最適化 最も安価にシステムを実行する能力 参考文献 AWS Cloud Practitioner Essentials (Japanese) (日本語字幕版) | Class Central"},{url:"/dimzakki-mainroad/github-actions-autocommit/",title:"【GitHub Actions】定期的に自動commit・pushを行う",date:"2023-05-20T00:00:00Z",body:"【GitHub Actions】定期的に自動commit・pushを行う GitHub Actionsを使い、自動でcommitとpushを行うように設定してみます。 やりたいこと GitHubのリポジトリ内のテキストファイルを、GitHub Actionsのワークフローを用いて毎日自動で更新し、同時にcommitとpushを行います。 テキストファイルとコミットログには、Actionを実行した時間を取得して書き込む様にします。 必要なファイル 必要なファイルは以下の2つになります。 リポジトリ構成\r1&lt;リポジトリ&gt; 2 ├ commit_log.txt 3 └ .github 4 └ workflows 5 └ auto-commit.yml\rGitHubのリポジトリ直下にコミットログを追加するためのcommit_log.txtと、自動コミット・プッシュのワークフローの設定ファイルであるauto-commit.ymlを/.github/workflows直下に配置します。 ymlファイルはリポジトリの「Actionsタブ「の「set up a workflow yourself」からでも作成することができます。 Actionsの設定ページ auto-commit.ymlの内容は以下になります。 auto-commit.yml\r1name: auto-commit 2 3on: 4 workflow_dispatch: 5 6 schedule: 7 - cron: &#34;0 0 * * *&#34; 8 9jobs: 10 build: 11 runs-on: ubuntu-latest 12 13 steps: 14 - uses: actions/checkout@v3 15 16 - name: Set current datetime as env variable 17 env: 18 TZ: &#39;Asia/Tokyo&#39; 19 run: echo &#34;CURRENT_DATETIME=$(date +&#39;%Y-%m-%d %H:%M:%S&#39;)&#34; &gt;&gt; $GITHUB_ENV 20 21 - name: Commit 22 run: | 23 git config --global user.email ${{ secrets.USER_EMAIL }} 24 git config --global user.name ${{ secrets.USER_NAME }} 25 echo -e ${{ env.CURRENT_DATETIME }} &gt;&gt; commit_log.txt 26 git add commit_log.txt 27 git commit -m &#34;[add] 自動コミット:${{ env.CURRENT_DATETIME }}&#34; 28 git push origin main\rワークフローの手動実行と毎日の自動実行を設定しています。 レポジトリの設定 続いて、環境変数のUSER_EMAILとUSER_NAMEを設定します。 リポジトリの「Settingsタブ」→「Secrets and variables」→「Actions」→「New repository secret」から環境変数を設定します。 環境変数はそれぞれ、USER_EMAILは登録しているメールアドレス、USER_NAMEはGitHubのIDになります。設定すると以下の様な画面になります。 レポジトリの設定ページ1 また、設定の「Actions」→「General」で「Workflow permissions」の設定が「Read and write permissions」になっているか確認しましょう。これが設定されていないとActionの書き込み権限が無いので上手く動作しません。 レポジトリの設定ページ2 Actionの実行 ここまでで準備が終わったので、Actionを実行します。 Actionの実行ページ これで、自動で設定したActionが実行されるようになりました。画像から設定したActionが毎日実行されていることが分かります。 Actionの実行履歴 今回はGitHub Actionsのワークフローに関する記事でした。特に有用な使い道は無さそうな内容ですが、参考になれば幸いです。以上で記事を終わりにします。 参考文献 GitHub Actionsのドキュメント | GitHub Docs Permission denied to github-actions[bot] | Stack Overflow"},{url:"/dimzakki-mainroad/wordpress-mathjax/",title:"【MathJax】サイトに数式を簡単に表示させる",date:"2023-04-30T00:00:00Z",body:"【MathJax】サイトに数式を簡単に表示させる JavaScriptプラグインであるMathJaxを使い、プラグイン無しでWordPressやHugoで数式を表示させる方法を解説します。 WordPressでMathJaxを使う方法 WordPressで数式を使うには、プラグインを導入する方法、テーマエディターでヘッダーにコードを記述する方法などがあります。ヘッダーにコードを記述すると、全てのページでそのコードが適用されてしまうので、意図しない表示になるページが発生する可能性があります。 今回紹介する方法は、数式を表示させたいページ単体にMathJaxを読み込ませて数式を表示させたいと思います。 まず、表示させたいページでカスタムHTMLブロックに以下のコードを貼り付けます。 カスタムHTMLブロック\r1&lt;script type=&#34;text/javascript&#34; id=&#34;MathJax-script&#34; async src=&#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&#34;&gt; 2&lt;/script&gt;\r上記コードを貼り付けることで、そのページではMathJax（バージョン3）が有効になります。そして、数式を\\(と\\)で囲むことで、数式を\\(TeX\\)で表示させることができます。試しにテーラー展開の公式を文中に表示させます。 インライン数式\r1\\( f(x)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!} (x-a)^{n} \\)\r文章の途中でも、\\( f(x)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!} (x-a)^{n} \\)のように数式を表示できます。 数式を\\[と\\]で囲むことでディスプレイ数式も可能です。 ディスプレイ数式\r1\\[ f(x)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!} (x-a)^{n} \\]\r\\[ f(x)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!} (x-a)^{n} \\] 数式の表示ができました。 公式ページにデモ機能1があるので、気軽に使ってみることも可能です。 改行が出来ない場合 MathJaxでは\\\\で改行を行うことができますが、バージョン3では改行が効かないといった不具合2があるようです。改行を行いたい場合はバージョン4のα版を使用することで、改行を行うことができます。 カスタムHTMLブロック\r1&lt;script type=&#34;text/javascript&#34; id=&#34;MathJax-script&#34; async 2 src=&#34;https://cdn.jsdelivr.net/npm/mathjax@4.0.0-alpha.1/es5/tex-mml-chtml.js&#34;&gt; 3&lt;/script&gt;\r改行\r1\\[ 1 \\\\ 2 \\\\ 3 \\]\r\\[ 1 \\\\ 2 \\\\ 3 \\] 改行されているのが分かります。 HugoでMathJaxを使う方法 Hugoの場合、記事のフロントマターにmathjax = trueを指定することで、MathJaxが有効化されます。 Hugoでは$$もしくは\\\\[と\\\\]で囲むことでディスプレイ形式で数式が表示できます。\\\\(と\\\\で囲むことでインライン形式で表示ができます。 インライン数式\r1数式：\\\\( f(x)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!} (x-a)^{n} \\\\)\r数式：\\( f(x)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!} (x-a)^{n} \\) ディスプレイ数式\r1$$ 2f(x)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!} (x-a)^{n} 3$$\r$$ f(x)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!} (x-a)^{n} $$ 改行は以下の様に書きます。 改行\r1\\\\[ 1 \\\\\\\\ 2 \\\\\\\\ 3 \\\\]\r\\[ 1 \\\\ 2 \\\\ 3 \\] 改行の書き方もWordPressとちょっと違うので注意しましょう。 当ブログでは数式を用いるシチュエーションはそんなに無いのですが、一部ページでのみ使用することがあったので、ページ単位でMathJaxを使う方法を採用することにしました。以上で記事を終わりにします。 参考文献 Getting Started with MathJax Components | MathJax Documentation Live Demo | MathJax&#160;&#x21a9;&#xfe0e; The line break() is not work | GitHub&#160;&#x21a9;&#xfe0e;"},{url:"/dimzakki-mainroad/qualification-oraclemastersilversql/",title:"【Oracle Silver SQL】合格体験記【約3か月で合格した方法】",date:"2023-04-08T00:00:00Z",body:"【Oracle Silver SQL】合格体験記【約3か月で合格した方法】 Oracle MASTER Silver SQL（1Z0-071-JPN）を2023年3月に受け合格しましたので、試験の対策・結果・感想などを合格体験記としてまとめたいと思います。 関連記事\r【Oracle Silver SQL】試験対策用備忘録メモ 試験概要 「Oracle MASTER Silver SQL」はOracleの資格の１つであり、主にSQLの知識が問われる試験です。 項目 詳細 出題形式 選択問題・CBT方式 出題数 78問 試験時間 120分 合格点 正答率63％以上 受験料 税込37,730円（2024/08/23時点）\rベンダー資格特有ですが、受験料は35,000円以上と結構高いです。また、受験に必要な前提資格はありませんので、いきなり受けることが可能です。 試験申し込み・試験対策 実際に受験することを決めてから試験本番までの流れを書いていきます。 プロフィール\r開発系のITエンジニア（2年目） Oracleはほぼ使ったこと無し（SQL自体は開発業務で使用経験有り） OracleやDBの資格試験を受けた経験は無し 受験のきっかけ・申し込み 受験日は2023年の3月になりますが、受験することを決めたのは結構前で2022年の夏頃だと思います。動機は単純で、「資格手当が貰えるから・査定評価のため」が主な理由です。 試験の申し込みは以前「Oracle Java Silver」を受けたことがあったので、その流れで多少楽にできました。しかし、始めて受ける人はアカウント登録等が複雑なので結構大変だと思います。 以下の関連記事で申し込み方法も簡単にまとめていますので、参考にしてみてください。テストセンターのキャパにもよりますが、予約は1ヶ月くらい前だと土日が空いていましたので、早めにやっておくといいと思います。 受験料支払いは、楽天でチケットを買うと試験代が浮くので、結構ありがたいです。 【ピアソンVUE専用】OracleピアソンVUE配信監督付き試験用受験チケット(電子チケット)\r38,995円～ rakuten.co.jp 試験の申し込みについてはこちらの記事にまとめてあります。 関連記事\r【ORACLE MASTER】試験の申し込みを格安で行う方法【OCJ-P】 また、Oracleの再受験無料キャンペーンが毎年行われているので、それを利用するのも手ですね。 試験勉強 試験勉強の本腰を入れたのは2023年に入ってからになります。主に黒本と呼ばれる参考書とPing-tというサイトにある問題集を使って勉強しました。 本番1ヶ月前までは参考書を1日30分くらい学習しました。本番1ヶ月前からはPing-tを使い、平日は1時間～2時間、休日は1時間～3時間くらい勉強しました。掛けた勉強時間は約3か月で80時間～100時間くらいだと思います。 具体的な対策方法は下で詳しく書いていきたいと思います。 試験本番・試験結果 試験は土曜日の午前に受けました。会場がビルの6階だかにあったんですが、時間が押してて急いでいたのと、エレベーターの場所が分からず階段で登ったらかなり大変でした…。帰りはエレベーター見つけたので使えました。土曜日だからか受験者はそこそこ多く、Oracle以外にもAWS試験を受けに来ている人もいました。 受付の際は、本人確認に身分証明書が2点必要なので、ちゃんと確認しておきましょう。私の場合は確認不足で運転免許証があれば良いかと勘違いしていて当日焦りましたが、財布に保険証があったので事なきを得ました。 試験は勉強した内容が聞かれるのでちゃんと覚えているかどうかです。全問自信を持って答えられた訳ではありませんが、30分くらい余らして退出しました。 試験結果が以下になります。 Oracle MASTER Silver SQLの試験結果 正解率84%で合格でした。試験終了時は多分7割台で合格だろうとは思いましたが、予想より高得点でした。 試験の難易度と対策について 試験の難易度についてですが、実務経験無しの場合だと少し難しく感じるレベルだと思います。しかし、しっかり勉強すれば合格は十分に可能なレベルではあります。経験者の場合だと、それ程難しくは無い試験かなと感じました。 次に、試験の難易度と具体的な試験対策についてまとめていきます。対策としては、「黒本」の周回→「Ping-t」の周回という流れで勉強していくのがおすすめです。 参考書（黒本） 参考書は黒本と呼ばれる物がおすすめです。黒本とは「オラクルマスター教科書 Silver SQL Oracle Database SQL」という参考書のことです。 オラクルマスター教科書 Silver SQL Oracle Database SQL\r5,280円～ amazon.co.jp 黒本は試験問題に近い形式の問題とその解説がテーマごとにまとまっている問題集になっています。こちらを3周程度やって、試験範囲の知識をまんべんなく取得しましょう。 ただ、この問題集だけでは、試験を合格するレベルには若干足りないかもしれません。 Ping-tの問題集 黒本で基礎固めをした後は「Ping-t」を使います。このサイトはIT試験対策に特化した問題集サイトです。 このサイトでは、各IT試験に対応した有料・無料の問題集が用意されています。「Oracle MASTER Silver SQL」に関しては、無料で580問以上収録された実戦形式の問題集とその解説を利用することができます。 利用にはアカウント登録が必要ではありますが、無料でこのクオリティは凄いですね。基礎的な知識は黒本で獲得できた状態なので、後はこの問題集をひたすら周回することで、試験に受かる水準に持っていきましょう。 黒本を勉強した後なので、こちらの問題集では簡単に解ける問題・よく分からない問題と分かれると思います。問題集では、間違えた問題のみを出題させたり、任意の問題をお気に入り登録することができますので、自分に足りない分野を重点的に解いていくことで効率良く学習することができます。 もちろんスマホでも利用できますので、通勤時間や空き時間にもサッと勉強することができるのも利点ですね。 問題集と実際の試験の差異 各問題集と実際の試験問題は似ている問も多いので、本番を意識した学習をすることがおすすめです。 1つポイントとして、問題集では「正しい（間違っている）選択肢を全て選びなさい」と出題されることがありますが、実際の試験では「全て選びなさい」形式は出ず、選ぶ選択肢の数は指定されていましたので、ある程度は絞り込みやすいかと思います。 試験を受けた感想 「Oracle Java Silver」を受験した時と同じですが、Oracleの試験は受験料が35,000円以上と高いので、簡単に落ちれないプレッシャーを感じてしまいますね。また、この試験ではOracle独自のSQL構文を学ぶことが出来るので、Oracleを使う仕事では役立つこともあるかもしれないですね。 試験時間については、勉強時に解答時間を意識したことはありませんでしたが、本番では時間が余ったのでそれ程意識する必要は無いかと思います。 問題集をしっかり解いていけば、それ程難しくなく受かることができる試験ですので、これから受験予定の方は参考にしてみてください。 以上で記事を終わりにします。 関連記事\r【Oracle Silver DBA】合格体験記【約2か月で合格した勉強方法】 参考文献 Oracle Database SQL | Oracle University"},{url:"/dimzakki-mainroad/qualification-oraclemastersilversql-measures/",title:"【Oracle Silver SQL】試験対策用備忘録メモ",date:"2023-03-19T00:00:00Z",body:"【Oracle Silver SQL】試験対策用備忘録メモ ORACLE MASTER Silver SQL（1Z0-071-JPN）の試験対策用の個人的な備忘録として、暗記事項をまとめました。 なお、記事の構成は公式1の出題範囲に依拠しました。 関連記事\r【Oracle Silver SQL】合格体験記【約3か月で合格した方法】 第1章:リレーショナル・データベースの概要 DBMSの利点 DBMS（データベース管理システム）を使うと以下の様なメリットを得られる 大量のデータを複数のユーザで利用でき、データを高速で参照・変更ができる データ型・トランザクション機能・整合性制約により、データの高い整合性を維持できる データが破損した場合速やかに復旧できる ユーザ単位でアクセスと操作権限の制御ができる SQLを実行するツール Oracleの実行ツールには、SQL*PlusとOracle SQL Developerがある SQL*Plusはコマンドラインベースのツール ターミナル・コマンドプロンプト上で実行する SQLに加えて専用のコマンドを実行できる Oracle SQL DeveloperはGUIベースのツール オブジェクト オブジェクトとは表などのデータを管理するものをオブジェクトと呼ぶ Oracleでは主に以下のオブジェクトが使われる オブジェクト名 内容 表 データを格納する ビュー（view） SELECT文に名前を付け保存したもの シーケンス 一意である数値（連番など）を生成する 索引 表からのデータの読み取りを高速化するもの シノニム オブジェクトの別名を定義できる セグメント・表領域 セグメントとは記憶域のこと 表などのデータを持つオブジェクトには、セグメントが1対1で対応している セグメントは表領域に格納さ 1つの表領域は複数のセグメントを格納できる スキーマ スキーマとはユーザと1対1で対応するもので、オブジェクトが格納されている スキーマには同名のユーザが所有しているオブジェクトが入っている 初期化パラメータ 初期化パラメータはメモリサイズや各機能のオンオフ等の設定値 ALTER SESSION SET文で初期化パラメータをセッションレベルで変更できる ALTER SESSION SET文\r1ALTER SESSION SET &lt;パラメータ名&gt; = &lt;設定値&gt;;\r第2章:SQL SELECT 文を使用したデータの取得 列別名 列名の後に列別名を指定できる 列別名の前のASは省略できる 列別名を&quot;（2重引用符）で囲む必要があるのは列別名が以下の場合 空白を含む $・_・#以外の記号を含む 大文字・小文字を区別する 最初の文字が数字・記号を含む Oracleの予約語 データ型 列にはデータ型が指定され、データ型に対応するデータしか格納できない 主なデータ型は以下 データ型名 内容 NUMBER 整数と小数NUMBER(n)　n桁の整数（n:1~38）NUMBER(n,m)　最大桁数n、小数点以下の最大桁数mの整数・小数 CHAR(n) サイズがnバイト固定長の文字列（n:1~2000）nは省略可能（省略時は1）n未満の文字列を入れた場合、空白埋めされる VARCHAR2(n) 最大サイズがnバイトの文字列（n:1~4000）nの指定必須 BLOB 最大128テラバイトのバイナリデータ CLOB 最大128テラバイトの文字列 DATE 日付と時刻（小数秒を含まない）年・月・日・時・分・秒を格納できる TIMESTAMP 日付と時刻（小数秒を含む）年・月・日・時・分・秒・小数秒を格納できる TIMESTAMP WITH TIME ZONE 日付と時刻（小数秒を含む）とタイムゾーン情報 TIMESTAMP WITH LOCAL TIME ZONE 正規化された日付と時刻（小数秒を含む） INTERVAL YEAR TO MONTH 年月の時間間隔 INTERVAL DAY TO SECOND 日時分秒の時間間隔 DESCRIBEコマンド DESCRIBEコマンドで表の構造を確認できる コマンドはDESCと短縮可能 コマンドで確認できる要素は以下 列名 内容 名前 表にある列名 NULL? 空白の場合NULLが入力できるNOT NULLの場合NULLが入力できない 型 データ型と文字サイズ・数値の精度 文字リテラル '（1重引用符）で文字列を囲むと文字リテラルとなり、文字列そのものを指定できる 文字リテラル内で1重引用符を使用したい場合は1重引用符を2つ続けて記述するか、代替引用メカニズムを使う 代替引用メカニズムは「q'と任意の文字」「任意の文字と'」で囲む NULL 列に値を設定せずに追加・更新するとNULLが設定される 空文字はNULLとして扱われる NULLを含む計算式はNULLとして扱われる NULLと「指定した文字列」を連結すると指定した文字列が返される DISTINCT SELECTの直後にDISTINCTを記述すると重複データを除外できる それ以外の場所には指定できない 第3章:データの制限とソート 条件式 条件式には列別名を指定できない 条件の評価順序 条件の評価順序は以下になる（上にあるものが優先される） =・!=・&lt;・&gt;・&lt;=・&gt;= IS NULL・LIKE・BETWEEN・IN・EXISTS NOT AND OR ()で囲むと順序が優先される 置換変数 置換変数を使うことでSQL文の一部を変えたものを繰り返して実行できる &amp;&lt;変数&gt;を使うと毎回変数の値入力が必要 &amp;&amp;&lt;変数&gt;を使うと変数の値が保存され繰り返し使える DEFINEコマンドでSQL実行前に置換変数を値を設定できる 置換変数の処理前後を非表示にするには変数VERIFYをOFFにする 第4章:単一行関数を使用した出力のカスタマイズ 文字列を受け取るファンクション（引数:文字列） UPPER・LOWER・INITCAPファンクション アルファベットの大文字・小文字を変更するファンクションはUPPER・LOWER・INITCAPがある INITCAPファンクションは先頭文字を大文字、それ以降を小文字にする SUBSTRファンクション 文字列から文字を抜き出す SUBSTRファンクション\r1--STRの先頭N文字目からL文字を抜き出す 2--lを省略したら最後まで抜き出す 3SUBSTR(&lt;文字列STR&gt;,&lt;開始位置N&gt;,&lt;長さL&gt;) 4 5SUBSTR(&#39;ABCDE&#39;,2) --BCDE 6SUBSTR(&#39;ABCDE&#39;,-2) --DE マイナスは開始位置を後ろから数える 7SUBSTR(&#39;ABCDE&#39;,2,3) --BCD\rREPLACEファンクション 文字列を置換する REPLACEファンクション\r1REPLACE(&lt;文字列STR&gt;,&lt;開始位置N&gt;,&lt;長さL&gt;) LPAD・RPADファンクション 文字列に文字を埋め込む（0埋めなど） LPADファンクション\r1--STRの左側に、長さがLになるようにPADを埋め込む 2--PADを省略したら空白が埋め込まれる 3LPAD(&lt;文字列STR&gt;,&lt;長さL&gt;,&lt;文字列PAD&gt;) 4 5LPAD(&#39;AB&#39;,5,&#39;0&#39;) --000AB 6LPAD(&#39;AB&#39;,5) -- AB\rRPADファンクション\r1--STRの右側に、長さがLになるようにPADを埋め込む 2--PADを省略したら空白が埋め込まれる 3RPAD(&lt;文字列STR&gt;,&lt;長さL&gt;,&lt;文字列PAD&gt;) 4 5RPAD(&#39;AB&#39;,5,&#39;0&#39;) --AB000\rTRIMファンクション 文字列の前後から指定の文字を削除する 指定する文字は1つのみ（複数はエラー） TRIMファンクション\r1--STRの先頭と末尾から連続した文字CHARを削除 2--&lt;文字CHAR FROM&gt;を省略した場合は前後の空白文字を削除 3TRIM(&lt;文字CHAR FROM&gt; &lt;文字列STR&gt;) 4 5TRIM(&#39; AB &#39;) --AB 6TRIM(&#39;A&#39; FROM &#39;ABA&#39;) --B\rTRIMファンクション\r1--LEADINGを指定した場合STRの先頭の文字CHARを削除 2--TRAILINGを指定した場合STRの末尾の文字CHARを削除 3--BOTHを指定した場合STRの先頭・末尾の文字CHARを削除 4--&lt;文字CHAR FROM&gt;を省略した場合は前後の空白文字を削除 5TRIM(&lt;LEADING | TRAILING | BOTH&gt; &lt;文字CHAR FROM&gt; &lt;文字列STR&gt;) 6 7TRIM(LEADING &#39;*&#39; FROM &#39;**AB**&#39;) --AB** 8TRIM(TRAILING &#39;*&#39; FROM &#39;**AB**&#39;) --**AB 9TRIM(BOTH &#39;*&#39; FROM &#39;**AB**&#39;) --AB\r数値を受け取るファンクション INSTRファンクション 指定した文字列の出現した位置を返す INSTRファンクション\r1--文字列STRのPOS文字目から文字列SEARCHを検索、N回目に出現する位置を返す 2--POSとNを省略した場合は1となる 3--SEARCHが無い場合0が戻る 4INSTR(&lt;文字列STR&gt;, &lt;文字列SEARCH&gt;, &lt;場所POS&gt;, &lt;回数N&gt;) 5 6INSTR(&#39;ABCDE&#39;, &#39;C&#39;) --3 7INSTR(&#39;ABCDEABCDE&#39;, &#39;C&#39;, 6, 1) --8（6文字目から数えて1回目に出現する位置）\rROUNDファンクション 数値を四捨五入する ROUNDファンクション\r1--数値Nを小数点以下INT桁で四捨五入 2--INTが負の時は小数点左側INT桁で四捨五入 3--INTを省略した時は0扱いになり整数で四捨五入 4ROUND(&lt;数値N&gt;, &lt;桁INT&gt;) 5 6ROUND(15.555) --16 7ROUND(15.555, 1) --15.6 8ROUND(15.555, -1) --20\rTRUNCファンクション 数値を切り捨てる 日時の計算・日時ファンクション 日時データの計算 日時データの計算の挙動は以下の表の通りになる 日時+日時の計算はエラーになる 計算式 内容 戻り値 日時 + 数値 日時に日数（数値分）が足される 日時 日時 - 数値 日時から日数（数値分）が引かれる 日時 日時 - 日時 日時間の日数が戻される 数値 NEXT_DAYファンクション 指定した日付の後に来る、指定した曜日の日付を返す NEXT_DAYファンクション\r1--日付DATEの後に来るSTRに指定した曜日で最初の日付を返す 2NEXT_DAY(&lt;日付DATE&gt;, &lt;曜日STR&gt;) 3 4--日付DATEの後に来るNUMに指定した曜日で最初の日付を返す 5--数値NUMは、1:日、2:月、3:火…のように定義される 6NEXT_DAY(&lt;日付DATE&gt;, &lt;曜日NUM&gt;) 第5章:変換関数と条件式の使用 データ型の変換 データ型の変換については明示的な変換（ファンクションを使用して型を変換を指定する）と暗黙的な変換（Oracleが自動的に型を変換する）がある 暗黙的な変換は意図しない挙動になることがあるため明示的な変換が推奨される ファンクション 変換内容 TO_CHAR 数値型・日時型→文字型 TO_NUMBER 文字型→数値型 TO_DATE 文字型→日時型 NULLに関するファンクション NVLファンクション NULLを指定した値に置き換える NVLファンクション\r1--INがNULL以外の場合INをそのまま戻す 2--INがNULLの場合OUTを戻す（INとOUTの型が異なる場合は暗黙的な変換が行われる） 3NVL(&lt;入力IN&gt;, &lt;出力OUT&gt;)\rNVL2ファンクション 入力がNULLかNULL以外かで指定した値に置き換える NVL2ファンクション\r1--INがNULL以外の場合OUT1を戻す 2--INがNULLの場合OUT2を戻す（INとOUTの型が異なる場合は暗黙的な変換が行われる） 3NVL2(&lt;入力IN&gt;, &lt;出力OUT1&gt;, &lt;出力OUT2&gt;)\rNULLIFファンクション 2つの引数の値が等しい時にNULLを戻す 等しくない時は1つ目の引数の値をそのまま戻す 2つの引数のデータ型は一致している必要がある COALESCEファンクション 複数の値から最初にあるNULLでない値を返す 引数のデータ型は全て一致している必要がある COALESCEファンクション\r1--入力の中から最初の非NULL値を返す 2--全てNULLの時はNULLを返す 3COALESCE(&lt;入力IN1&gt;, &lt;入力IN2&gt;, ....)\r第6章:グループ関数を使用した集計データのレポート 集計ファンクション 複数のデータを集計するときは集計ファンクションを使用する ファンクション 集計内容 SUM 合計値を返す AVG 平均値を返す MAX 最大値を返す MIN 最小値を返す COUNT 行数を返す 集計ファンクションは返り値のデータは1件になる NULLは集計の対象外になる COUNT(*)ではNULLもカウントの対象になる COUNT(&lt;列名&gt;)の時は列がNULLの時は集計の対象外になる DISTINCTを集計ファンクションに指定すると、重複データを排除してから集計処理を行う 例:AVG(DISTINCT &lt;列名&gt;) GROUP BY句とHAVING句 データをグループに分けてからそれぞれ集計したい時はGROUP BY句にグループ分けしたい列を指定する WHERE句で絞ってからグループ分けできる（グループ分けの前に絞り込みされる） GROUP BY句に複数の列を指定した場合列の組み合わせでグループ分けされる 集計ファンクションをネストすることで、グループごとに集計したデータをさらに集計できる HAVING句を使うとグループ分けし集計した後にデータの絞り込みができる 第7章:複数の表からのデータの表示 内部結合 複数の表からデータを結合（JOIN）することができる 内部結合では結合条件（ON句）を満たすデータのみ表示する 外部結合 外部結合では結合条件を満たさないデータも表示される 外部結合 結合条件を満たさなくても表示される表 左外部結合 結合条件の左側の表 右外部結合 結合条件の右側の表 完全外部結合 結合条件の両方の表 USING句 2つの表を同じ名前で結合する時はUSING句が使用できる NATURAL JOIN構文 列の名前とデータ型が同じ場合NATURAL JOINを使用できる 自己結合 同じ表を結合することもでき、自己結合と呼ばれる クロス結合 クロス結合（デカルト積）では行の全ての組み合わせを返す 表名を指定する時にCROSS JOINか,を指定する 非等価結合 結合に=以外の条件を使用した結合は非等価結合と呼ばれる USINGとNATURAL JOINを用いた結合では非等価結合はできない 第8章:副問合せを使用した問合せの解決 副問合せ SQL文の中にSELECT文を埋めることができ、そのSELECT文を副問合せ（サブクエリ）と呼ぶ 副問合せを埋め込んだSQL文を主問合せと呼ぶ 1つの主問合せに埋め込める副問合せの数に制限は無く、副問合せの中に副問合せを埋め込むことも可能 スカラー副問合せ 「1つの行の1つの列の値」を戻す副問合せをスカラー副問合せと呼ぶ スカラー副問合せはSELECT文のWHERE句だけではなく、FROM句やHAVING句などの単独の値を指定できる所ならどこでも使える スカラー副問合せでは複数の行・列の値を返す場合はエラーになる スカラー副問合せのWHERE条件を満たす行がない時はNULLを返す 非スカラー副問合せ 「1つの行の1つの列の値以外」を戻す副問合せを非スカラー副問合せと呼ぶ IN条件を指定すると複数の値のいずれかに等しい時条件を満たす ANY条件を指定すると複数の値のいずれかが指定した演算子を満たす場合に条件を満たす =・!=・&gt;・&gt;=・&lt;・&lt;=・&lt;&gt;を指定できる ALL条件を指定すると複数の値の全てが指定した演算子を満たす場合に条件を満たす 指定できる演算子はANY条件と同じ 相関副問合せ 副問合せの中で「主問合せで参照している表の列」を参照している問合せを相関副問合せと呼ぶ 相関副問合せでは主問合せと副問合せが関連付けられているので、副問合せのSQLを単独で実行はできない 相関副問合せの内、主問合せと副問合せで同じ表を参照するものを自己相関副問合せと呼ぶ 第9章:集合演算子の使用 集合演算 SQLでは問合せによって戻されるデータを1つの集合として扱うことで集合演算が可能 集合演算子は以下の4つ 集合演算子名 内容 UNION ALL 結合条件の左側の表 UNION 結合条件の右側の表 INTERSECT 結合条件の両方の表 MINUS 結合条件の両方の表 集合演算の注意事項 SELECTの列数・データ型を一致させる SELECTの列名は異なっても良い ORDER BY句は文の最後に指定する UNION ALL以外の集合演算では戻るデータがソートされる（最初の列の昇順） 第10章:DML 文を使用した表の管理 DML DML（表のデータを操作するSQL）にはINSERT文・UPDATE文・DELETE文・MERGE文などがある マルチテーブルINSERT マルチテーブルINSERTでは副問合せが戻す複数行を複数表の行へ挿入できる マルチテーブルINSERTの種類 内容 無条件 INSERT 副問合せから戻された行がINTO句で指定された全ての表に挿入される 条件付き INSERT ALL 副問合せから戻された行がWHEN句の条件を満たすものの全ての表に挿入される 条件付き INSERT FIRST 副問合せから戻された行がWHEN句の条件を最初に満たす時表に挿入される MERGE文 MERGE文はある表から取得した行を元に、別の表の追加・更新を行う MERGE文\r1MERGE INTO &lt;ターゲット表&gt; 2 USING &lt;ソース表&gt; 3 ON (結合条件) 4 WHEN MATCHED THEN 5 UPDATE ... 6 WHEN NOT MATCHED THEN 7 INSERT ...\rトランザクション トランザクションはDMLを実行すると自動で開始され、COMMIT文を実行すると終了する（変更が確定） COMMIT文を実行する前にROLLBACK文を実行すれば変更を取り消せる トランザクションの開始・終了の条件は以下 トランザクションの開始 条件 トランザクションの開始 トランザクションが実行されていない時にDMLを実行SET TRANSACTION文を実行した時 トランザクションの終了（COMMIT） COMMIT文を実行接続を正常終了した時DDLを実行した時 トランザクションの終了（ROLLBACK） ROLLBACK文を実行接続が異常終了した時 トランザクション中にセーブポイントを指定すると、トランザクション中にセーブポイントまで戻ることができる 第11章:DDL による表とその関係の管理 オブジェクト オブジェクトにはスキーマオブジェクトと非スキーマオブジェクトがある スキーマオブジェクトは表・索引・ビュー・シーケンス・シノニムなど特定のユーザに所有される 非スキーマオブジェクトはユーザ・ロール・表領域など特定のユーザに所有されない DDL オブジェクトの定義に関するSQLはDDLと呼ばれる 第12章:ビューの管理 ビュー ビューは表に対するSELECT文より定義されるオブジェクト ビューを作成するにはCREATE VIEW文を使用する OR REPLACEを指定すると同じビューがあったときに上書きされる WITH READ ONLYを指定するとビューは読み取り専用になる WITH CHECK OPTIONを指定するとビューのデータを変更した時、変更後のデータがビュー定義のWHERE条件を満たすかチェックする（満たさない場合エラー） 第13章:索引とシノニムとシーケンスの管理 索引 表からのデータの読み取りを高速化するオブジェクトを索引（インデックス）と呼ぶ 使用することで読み取るデータ量を削減して処理を高速にする 索引\r1CREATE INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; ... ) --索引の作成 2 3DROP INDEX --索引の削除\r索引をUNUSABLE（使用不可）にすると索引のセグメントが削除される（索引の定義は削除されない） 索引をINVISIBLE（不可視化）にすることで、索引を削除しても影響が無いか確認ができる（索引が見えなくなるが実体は残る） シーケンス シーケンスを使うことでデータベース全体で一意である連番を振る処理を行う 索引\r1CREATE SEQUENCE &lt;シーケンス名&gt; --シーケンスの作成 2 3&lt;シーケンス名&gt;.NEXTVAL --シーケンスから新たに連番を振り出す 4 5&lt;シーケンス名&gt;.CURVAL --振り出された連番の確認\rシノニム シノニムは表・ビューなどのオブジェクトに対して付ける別名 プライベートシノニムとパブリックシノニムがある プライベートシノニムは所有ユーザとシノニムが差すオブジェクトにアクセスできるユーザがアクセスできる パブリックシノニムはどのユーザでもアクセスできる 第14章:ユーザー・アクセスの制御 ユーザ DBでデータを管理するには属性・権限を付与したユーザを作成する ユーザは所有するオブジェクトに対してどの表領域からどれだけストレージ領域を割り合てるか設定できる スキーマ ユーザには同名のスキーマが存在し、ユーザが所有するオブジェクトはユーザのスキーマに格納される 権限 Oracleの権限はシステム権限とオブジェクト権限の2種類ある システム権限はデータベースへの操作が実行可能かを制御する権限 オブジェクト権限は他のユーザが所有する表・ビューなどのオブジェクトに対する操作が実行可能かを制御する権限 権限はGRANT文で付与しREVOKE文で取り消す ADMINオプションを指定してシステム権限を付与されたユーザは他のユーザにそのシステム権限を付与できる GRANTオプションを指定してオブジェクト権限を付与されたユーザは他のユーザにそのオブジェクト権限を付与できる ロール 複数の権限をまとめたものをロールと呼ぶ 第15章:データ・ディクショナリ・ビューを使用したオブジェクトの管理 データディクショナリと呼ばれるOracle内部の管理情報を格納している特殊な表から作られるビューをデータディクショナリビューと呼ぶ 第16章:異なるタイムゾーンでのデータの管理 タイムゾーン 各国・地域で使われる日時の基準を標準時と呼び、その標準時を使う国・地域をタイムゾーンと呼ぶ タイムゾーンはタイムゾーンリージョン名かタイムゾーンオフセットで指定する タイムゾーンリージョン名は日本の場合Japan・Asia/Tokyo タイムゾーンオフセットは日本の場合+9:00 Oracleにはタイムゾーンに対応している日時データ型はTIMESTAMP ＷITH TIME ZONE型とTIMESTAMP ＷITH LOCAL TIME ZONE型がある 期間データ型 期間データ型にはINTERVAL YEAR TO MONTH型とINTERVAL DAY TO SECOND型がある 参考文献 ORACLE MASTER Silver SQL 1Z0-071-JPN受験準備ガイド | Oracle Oracle Database SQL言語リファレンス, 12cリリース1 (12.1) | Oracle Oracle Database SQL | Oracle&#160;&#x21a9;&#xfe0e;"},{url:"/dimzakki-mainroad/java-sqrt-method/",title:"【Java】sqrtメソッドで平方根（ルート√）を求める方法",date:"2023-02-11T00:00:00Z",body:"【Java】sqrtメソッドで平方根（ルート√）を求める方法 JavaのMathクラスのsqrtメソッドで平方根を求める方法を紹介します。 また、sqrtメソッドを使わずに平方根を計算する方法も紹介します。 ここで、平方根とは数 \\(a\\) があるとき、2乗して \\(a\\) になるような数のことを指します。つまり \\(x^{2}=a\\) を満たす数 \\(x\\) が \\(a\\) の平方根になります。 sqrtメソッドの書式 メソッドの書式は以下になります。 sqrtメソッドの書式\r1Math.sqrt(double a); 2Math.sqrt(4); // 2が返る\r引数の平方根が返ってきます。戻り値の型はdouble型になります。 正の無限大の時は正の無限大がそのまま返されます。また、引数が負の数値である場合はNaN（Not a Number/非数）を返します（NaNが引数の時も同様です）。 似た機能を持つメソッドに、立方根を計算するcbrtメソッドがあるので注意しましょう。 関連記事\r【Java】cbrtメソッドで立方根を求める メソッドの使用例 メソッドの使用例をサンプルコードで示します。 SqrtTest1.java\r1public class SqrtTest1 { 2 public static void main(String[] args) { 3 System.out.println(&#34;4の平方根:&#34; + Math.sqrt(4)); 4 System.out.println(&#34;9.0の平方根:&#34; + Math.sqrt(9.0)); 5 System.out.println(&#34;10の平方根:&#34; + Math.sqrt(10)); 6 System.out.println(&#34;-1の平方根:&#34; + Math.sqrt(-1)); 7 System.out.println(&#34;0の平方根:&#34; + Math.sqrt(0)); 8 System.out.println(&#34;正の無限大の平方根:&#34; + Math.sqrt(Double.POSITIVE_INFINITY)); 9 System.out.println(&#34;NaNの平方根:&#34; + Math.sqrt(Double.NaN)); 10 } 11}\r実行結果が以下になります。 出力結果\r14の平方根:2.0 29.0の平方根:3.0 310の平方根:3.1622776601683795 4-1の平方根:NaN 50の平方根:0.0 6正の無限大の平方根:Infinity 7NaNの平方根:NaN\rそれぞれの数字の平方根が、double型で出力されていることが分かります。 sqrtメソッドを使わずに平方根を計算する sqrtメソッドを使わない方法として、数 \\(x\\) の平方根を求めたい時、 \\(0\\) から \\(x\\) までの平均を近似していくことで平方根を求める方法があります。この手法は二分法と呼ばれており、アルゴリズムの概要は以下のようになります。 アルゴリズム\r変数 \\(\\text{num1}=0\\) 、 \\(\\text{num2}=x\\) とし、 \\(\\text{num1}\\) と \\(\\text{num2}\\) の平均 \\(\\text{mid}\\) を求める \\(\\text{mid}^{2}=x\\) の時、処理を終了する \\(\\text{mid}^{2} &lt; x\\) だったら \\(\\text{num2}=\\text{mid}\\) とする \\(x &lt; \\text{mid}^{2}\\) のとき、 \\(\\text{num1}=\\text{mid}\\) とする \\(\\text{mid}^{2}=x\\) か、ループの規定回数に達するまで1、2を繰り返す 例として、10の平方根を求めるサンプルコードを以下に示します。近似の回数は最大1000回にしています。また、double型は誤差が発生するので、アルゴリズム2.の比較時は差がある程度の数値を下回るかどうかで判定します。 SqrtTest2.java\r1public class SqrtTest2 { 2 public static void main(String[] args) { 3 double x = 10; 4 double num1 = 0; 5 double num2 = x; 6 double mid; 7 8 for (int i = 0; i &lt; 1000; i++) { 9 mid = (num2 + num1) / 2; 10 if (Math.abs(mid * mid - x) &lt; 0.00000000000001) { 11 System.out.println(x + &#34;の平方根:&#34; + mid); 12 break; 13 } else if (mid * mid &lt; x) { 14 num1 = mid; 15 } else if (x &lt; mid * mid) { 16 num2 = mid; 17 } 18 } 19 } 20}\r実行結果が以下になります。 出力結果\r110.0の平方根:3.16227766016838\r先ほどの出力結果とほぼ数値が出力されたことが分かります。平方根が無理数の場合、繰り返し処理は最大まで達して処理を終了します。 ここまで色々と書きましたが、この方法だとコードが長いので普通にsqrtメソッドを使った方がコードが見やすく便利であることが分かります。以上で記事を終わりにします。 参考文献 Math (Java Platform SE 8 ) | Oracle 二分法の意味と平方根を計算する例 | 具体例で学ぶ数学"},{url:"/dimzakki-mainroad/java-isalphabetic-method/",title:"【Java】isAlphabeticメソッドで文字が英数字か調べる方法",date:"2023-01-24T00:00:00Z",body:"【Java】isAlphabeticメソッドで文字が英数字か調べる方法 JavaのCharacterクラスのisAlphabeticメソッドで文字がアルファベットか判定する方法についてまとめます。 isAlphabeticメソッドの書式 isAlphabeticメソッドは、以下の様に記述します。 isAlphabeticメソッドの書式\r1Character.isAlphabetic(int i);\r文字を比較してアルファベットであればture、そうでなければfalseを返します。戻り値の型はboolean型です。 isAlphabeticメソッドの使用例 メソッドの使用例をサンプルコードで示します。 IsAlphabeticTest.java\r1public class IsAlphabeticTest { 2 public static void main(String[] args) { 3 // a,0をそれぞれアルファベットかどうか判定する 4 System.out.println(Character.isAlphabetic(&#39;a&#39;)); 5 System.out.println(Character.isAlphabetic(&#39;0&#39;)); 6 } 7}\r実行結果が以下になります。 出力結果\r1true // aのアルファベット判定 2false // 0のアルファベット判定\rアルファベットの判定が出来ました。 今回はisAlphabeticメソッドの使い方の紹介でした。以上で記事を終わりにします。 参考文献 Character (Java Platform SE 7 ) | Oracle"},{url:"/dimzakki-mainroad/blog-alt-setting/",title:"【WordPress】alt属性を自動で記事タイトルに設定する【プラグインなし】",date:"2023-01-14T00:00:00Z",body:"【WordPress】alt属性を自動で記事タイトルに設定する【プラグインなし】 WordPressで画像のalt属性（代替テキスト）をプラグインを使わずに一括で記事タイトルに変更する方法を紹介します。 WordPressでの代替テキストの設定について Webサイトの画像のalt属性は、設定することで検索エンジンに画像の内容をより正確に伝えることができます。WordPressでは画像のalt属性は「代替テキスト」により設定されます。 代替テキストを設定するには以下の2パターンの標準的な方法があります。 代替テキストを設定する方法\r画像アップロード時に設定する 各記事の画像ブロックで直接設定する 画像アップロード時に代替テキストを設定する方法 画像アップロード時に代替テキストを設定した場合、メディアライブラリの画像ファイルにも代替テキストが保存されます。その後各記事で画像を貼った時に、アップロード時の代替テキストが自動で適用されます。 各記事の画像ブロックで代替テキストを設定する方法 この方法は注意が必要です。 画像アップロード時に代替テキストを設定せずに、各記事の画像に個別に代替テキストを設定した場合、メディアライブラリにはその代替テキストが保存されません。つまり、画像を他の記事に添付したい場合はまた代替テキストを設定する必要があります。 また、両方で共通する注意点として、後からメディアライブラリで代替テキストを変更した場合、各記事に添付されている画像の代替テキストは変更されません。 空のalt属性を変更する方法 既に各記事に画像を大量にアップロードしている場合、空のalt属性を1つ1つ修正していくのには時間が掛かります。しかし、alt属性のために余計なプラグインを入れるとかえって重くなったりするので避けたいところです。 応急処置として、alt属性が空の場合に自動で文字列を挿入できないか調べてみます。すると、有用そうなブログ記事を発見したのでそこに載っていたコードを若干改良してみました。 以下のコードをfunctions.phpに貼り付けることで動作します。 functions.php\r1function my_set_img_alt_title( $content ) { 2 global $wpdb; 3 if ( preg_match_all( &#39;/&lt;img [^&gt;]+alt=&#34;&#34;[^&gt;]+&gt;/i&#39;, $content, $images ) ) { 4 foreach( $images[0] as $image ) { 5 if ( preg_match( &#39;/src=[\\&#39;&#34;]([^\\&#39;&#34;]+)[\\&#39;&#34;]/i&#39;, $image, $src ) ) { 6 if ( preg_match( &#39;/([^\\/]+?)(-e\\d+)?(-\\d+x\\d+)?(\\.\\w+)?$/&#39;, $src[1], $file ) ) { 7 $attachiment_id = (int)$wpdb-&gt;get_var( $wpdb-&gt;prepare( &#34;SELECT ID FROM {$wpdb-&gt;posts} WHERE post_name=%s&#34;, $file[1] ) ); 8 if ( $attachiment_id ) { 9 $alt = get_post_meta( $attachiment_id, &#39;_wp_attachment_image_alt&#39;, true ); 10 if ( $alt === &#39;&#39; ){ 11 $alt = get_the_title(); 12 } 13 $replace = str_replace( &#39;alt=&#34;&#34;&#39;, &#39;alt=&#34;&#39; . esc_attr( $alt ) . &#39;&#34; &#39;, $image ); 14 $content = str_replace( $image, $replace, $content ); 15 } 16 } 17 } 18 } 19 } 20 return $content; 21} 22add_filter( &#39;the_content&#39;, &#39;my_set_img_alt_title&#39; );\r画像のalt属性が空だった場合は、メディアライブラリの代替テキストを取得します。更に改良点として、メディアライブラリの代替テキストも空だった場合に記事のタイトルを取得しalt属性に設定するように手を加えました。 このコードではあえてalt属性を設定したくない画像にも記事タイトルが設定されてしまうためご注意ください。 alt属性に記事タイトルを入れるのはあくまで応急処置的な処置なので、後々ちゃんと個別に設定していった方がベターですね。以上で記事を終わりにします。 参考文献 WordPressのALT属性(代替テキスト)の設定と保存先 | sakue.com alt属性を自動入力するプラグインについて | ja.wordpress.org"},{url:"/dimzakki-mainroad/product-review-monitor-arm-desk/",title:"幕板付きの勉強机にモニターアームを設置する方法【商品レビュー】",date:"2023-01-03T00:00:00Z",body:"幕板付きの勉強机にモニターアームを設置する方法【商品レビュー】 勉強机にモニターアームを設置しモニターを固定する方法について、個人的におすすめのやり方を紹介します。 勉強机の様なクランプ式のモニターアームが挟めないタイプの机にできる方法になります。 前置き 本題に入る前に、今使っている机についてやモニターアームを使いたい理由などを前置きに書いておきます。別に読まなくても良い話なので飛ばしてしまっても問題ありません。 家で使っている机について 私がモニターを置いて使っているデスクなんですが、いわゆる勉強机の机上ラック等を取り外した机を使っています。とりあえず机上を整理してみるとこんな感じです。左にあるBenQのモニター（24インチ）は別のPCデスクに設置しているものですので無視してください。 使用している勉強机 まあ実家に良くあるタイプというヤツです。このタイプの机、作りはしっかりしていて作業もしやすく使い勝手は悪くはないのですが、1つ致命的な欠点があります。それが、クランプ式モニターアームとの相性が非常に悪いということ。クランプ式というのは万力（クランプ）で机などを挟んで固定する方式のモニターアームです。 机の背面が以下の画像の様になっていて、背面板（幕板）が邪魔して奥行きが足りず、クランプを挟むには長さが足りません。 机の背面 古いモニターはもう5年は使っていて、前々からそろそろ新しいゲーミングモニターを1枚買おうかと思ってたんですよね。それで上の画像にある今まで使っているモニターをどうしようかなと悩んでいました。古いモニターは処分しようかなとも考えましたが、まだリモートワーク等にも使えそうだったので、この機会にデュアルモニターにしてみたいと思いました。 そして、モニター位置の調整のしやすさや机上の省スペース等も考えると、モニターアームもなんとかして使いたいと思い、方法を試行錯誤することになりました。 勉強机にクランプ式モニターアームを使えるか？ まず、勉強机にクランプ式モニターアームを設置する方法を模索してみました。考えられるやり方としては以下のやり方が挙げられます。 クランプ式モニターアームを設置する方法\r狭い奥行きでも設置できるモニターアームを使う 机を改造してモニターアームを設置できるようにする 机上台を机に乗せて、その上にモニターアームを取り付ける 1の狭い奥行きでも設置できるモニターアームに関しては、探してみると「エルゴトロン MXV」という製品がありました。 ERGOTRON エルゴトロン MXV デスク モニターアーム スリムタイプ マットブラック 34インチ(3.2~9.1kg)まで VESA規格対応 45-486-224\r24,700円～ amazon.co.jp この製品はクランプ下端が短く、下側の奥行きが5㎝未満の机でも取り付け可能ですが価格が2万円以上と高価格です。お金があれば選択肢に入りましたが…今回は断念。 2の勉強机の改造については、板を幕板を取り外す、もしくはクランプを挟むのに必要な分を削る等ありますが、工作には自信がないし失敗したら取り返しがつかないのでこれも不採用。 3に関してはこの中で一番実現できそうではありますが、机上台によっては安定性に欠けそうなイメージがあります。加えて、そもそもの目的は机上をスッキリさせたいことなので、モニターアームを使いたいが為に机上台を置いてしまうと本末転倒感があり、なるべくやりたくない手段です。 以上より、クランプ式のモニターアームを採用するのは難しそうという結論に至りました。 勉強机にモニターアームを設置する方法 ここからが本題になります。結論として採用したのは、突っ張り棒と支柱取り付けタイプのモニターアームでした。突っ張り棒を机と天井に突っ張らせ、突っ張り棒を支柱としてモニターアームを取り付けます。採用した主な理由は購入費用がそれ程掛からないこと、取り付け作業がお手軽であることでした。 実際に購入したのが「Umimile 突っ張り棒 3m」と「イーサプライ モニターアーム ポール取付 4関節」の2つ。 突っ張り棒 強力 3m つっぱり棒 伸縮棒 強負荷 ものほし竿 ドリル不要 物干し竿 洗濯物干し 布団干し 室内 屋外 調節簡単 耐荷重30~10kg 直径32mm ブラック(130-320cm)\r3,680円～ amazon.co.jp イーサプライ モニターアーム ポール取付 4関節 支柱 32インチまで 耐荷重8kg 多関節 1画面 上下 左右 VESA 75 100 EEX-LAP07\r3,980円～ amazon.co.jp このモニターアームは直径28mm以上のポールに取り付け可能ですので、直径32mmの突っ張り棒を購入しました。取り付けの画像がこんな感じになります。突っ張り棒を設置する前に、モニターアームを棒に通しておかなければならないので注意。 突っ張り棒とモニターアームの取り付け1 突っ張り棒とモニターアームの取り付け2 突っ張り棒とモニターアームの取り付け3 突っ張り棒とモニターアームの取り付け4 机自体がしっかりしていて安定性が高いこともあって、突っ張り棒もしっかり固定できてイイ感じ。作業に関しては1人で20分とかからず出来ました。後日購入した新しいモニターにつけ変え、位置調整しデュアルモニターにしてみたのがこちら。 デュアルモニターの完成形 右の新しいモニターは突っ張り棒からモニターアームに固定していて、左のモニターは別に購入したルミナスのラックの25mmポールに同じモニターアームもう1つ買い取り付けました。モニターアームは28mm以上のポールに対応とのことでしたが、25mmポールにも取り付けられました（使用法に則っていませんので、あくまで自己責任でやってます）。 これでデュアルモニターの完成です！特に大変な作業などもなく、上手くいって良かったです。 このやり方のデメリットとしては、机を固定しているので気軽に動かせないこと、ポールにより見栄えに変わることの2つが挙げられます。私の場合、机は頻繁に動かさないし、見栄えも特に不満はないので満足です。 今回は勉強机にモニターアームを設置しモニターを固定する方法を紹介しました。かなりお手軽にできますのでお困りの方は是非参考にしてみてください。 作業スペースは広くなったものの、やはり子供用の勉強机だと狭くて使いづらいですね。早く大きな机を購入したいと思いました。追記ですが、結局、記事を書いた半年以上後にIKEAでモニターアームが挟める大きめのデスクを購入しました。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/java-pow-method/",title:"【Java】powメソッドでべき乗（累乗）を求める",date:"2022-12-20T00:00:00Z",body:"【Java】powメソッドでべき乗（累乗）を求める JavaのMathクラスのpowメソッドでべき乗（累乗）を求める方法を紹介します。 べき乗とは、 \\(a^{n}\\) のような \\(a\\) の \\(n\\) 乗で表せる数のことです。 関連記事\r【Java】sqrtメソッドで平方根（ルート√）を求める方法 powメソッドの書式 メソッドの書式は以下になります。 powメソッドの書式\r1Math.pow(double a, double b);\raが底、bが指数になります。底を10、指数を2とすると、\\(10^{2}=100\\)なので、戻り値は100が返されます。また、戻り値はdouble型で返されます。 底か指数がNaNの場合はNaNが返されます。指数が0の場合は1.0が返されます。 powメソッドの使用例 べき乗を求めるサンプルプログラムを、for文を使うパターンとpowメソッドを使うパターンの両方でサンプルコードで示します。 PowTest.java\r1public class PowTest { 2 public static void main(String[] args) { 3 // for文で5の3乗を求める 4 int num1 = 1, num2 = 5; 5 for (int i = 0; i &lt;= 2; i++) { 6 num1 *= num2; 7 } 8 System.out.println(&#34;5の3乗（for文）:&#34; + num1); 9 10 // powメソッドで5の3乗を求める 11 double num3 = Math.pow(5, 3); 12 // double型をint型に変換して出力する 13 System.out.println(&#34;5の3乗（powメソッド）:&#34; + (int) num3); 14 } 15}\r実行結果が以下になります。 出力結果\r15の3乗（for文）:125 25の3乗（powメソッド）:125\rpowメソッドを使った方が1行で書けるため、コードがすっきりして見やすいですね。 今回はpowメソッドの使い方の紹介でした。 そもそも、Javaではべき乗の演算子がありません。^はJavaでは排他的論理和（XOR）演算子ですので、べき乗だと思って使用すると違った結果となります。他言語だと、JavaScriptでは**が演算子となっていますね。 以上で記事を終わりにします。 参考文献 Math (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/java-browser-compile/",title:"【初心者向け】ブラウザ上でプログラムを書く方法【環境構築不要】",date:"2022-11-20T00:00:00Z",body:"【初心者向け】ブラウザ上でプログラムを書く方法【環境構築不要】 プログラミングを始めたい人向けに、ブラウザ上でコードを書く方法についてpaiza.ioなどを紹介します。 プログラミングの実行環境を作るのは大変 プログラミングを初めて学ぶ人が挫折しやすいのが、統合開発環境（IDE）の構築ですね。IDEは開発作業に必要な機能が最初から入っているソフトウェアのことで、EclipseやMicrosoft Visual Studioやなどが有名です。 私は仕事ではEclipseやVisual Studioを使うことが多いですが、IDEの構築はインストールや設定等やることが多くて面倒です。また使う言語やツールによって、必要な設定手順やインストールしないといけないものは変わります。 また、コードエディタのVisual Studio Code（VS Code）も人気ですね。ある程度のことが出来て動作も軽いので、このサイトに関してはVS codeで管理しています。 趣味程度でプログラミングを触ってみたい人にとっては、環境構築はハードルが高いのではないでしょうか。ただコードだけ書いてみたいというニーズも一定あると思います。 そんな人達におすすめなのが「paiza.io」というサイトです。 paiza.ioについて paiza.ioは、オンライン上でコードのコンパイルと実行ができるwebサービスです。オンラインで動かすので、ソフトのインストールなどは不要です。ブラウザ上でコードの記述と実行を行うことができます。 paiza.ioという名前ですが、「paiza」はIT系の就活・学習サイト名で、「io」はテクノロジー系サイトに良く使われているドメインです。 このサイトの利点として以下の様な点があります。 paiza.ioの特徴\r無料・会員登録無しでコードのコンパイルと実行ができる Java・C言語・Pythonなど主要な24言語に対応している 日本語に対応している 「GitHub」等の外部サイトと連携している これほどの機能をブラウザ上で実行できるのは凄いですね！ paiza.ioでプログラミングを実行してみる 実際にpaiza.ioを使って、Javaで「こんにちは」と出力するコードをコンパイルして実行してみます。 Main.java\r1public class Main { 2 public static void main(String args[]) { 3 System.out.println(&#34;こんにちは&#34;); 4 } 5}\r実行ボタンもしくはctrl + enterで実行できます。こんな感じになりました。 paiza.ioのコードエディタ画面 下の方に「こんにちは」と出力できてますね。設定等は必要無しでコードの実行もすぐできるので楽ちんです。 また、歯車アイコンから「エディタの設定」が開きます。エディタのテーマを始め、フォントサイズやtabスペースの幅などを設定できます。 このサイトのデメリットとして「プログラム実行のタイムリミットは2秒」であるという縛りがあります。例えば計算量が多いプログラムなどは実行できずに停止してしまうので注意しましょう。 その他にも、書いたコードをブログ等のWebページに埋め込みを行うこともできます。先ほどのコードをこのページに埋め込んでみます。 埋め込みも手軽に実行環境を埋め込むことができて便利ですね。 その他のブラウザ上でコードを実行できるサイト C言語のコンパイルをしたい方は「ブラウザで動く C言語実行環境」というサイトもあります。こちらはオフラインでも動作します。こちらはよりコンパクトに操作することが出来ます。 関連記事\r学習用C言語開発環境について【おすすめ学習サイトも紹介】 また、HTML、CSS、JavaScriptを実行できる「JSFiddle」や「codepen」なんかもあります。 JSFiddleのコードエディタ画面 codepenのコードエディタ画面 どちらも簡単なWebページを作成することができます。画面レイアウトも似ているので、好みで選択すれば良さそうですね。 これからプログラミングをしたい人向けにpaiza.ioを紹介してみました。無料の会員登録なしでこの機能は充実してると思います。手軽にプログラムを書けるのは入門用として良いツールですね。 「とりあえずコードだけ書いてみたい」といった人にはおすすめです。とりあえずpaiza.ioでプログラミングに触れてみて、もっとやりたくなったらIDEをインストールしてみるのもありです。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/product-review-aviot-te-d01v/",title:"【AVIOT TE-D01v】コスパが良いワイヤレスイヤホン【商品レビュー】",date:"2022-10-16T00:00:00Z",body:"【AVIOT TE-D01v】コスパが良いワイヤレスイヤホン【商品レビュー】 ワイヤレスイヤホンのAVIOT TE-D01vを購入しました。使用してみてのレビューなどをまとめていきます。 AVIOT TE-D01vの用途・購入のきっかけ イヤホンの用途は、主に通勤時に音楽を聴くためです。レビューに入る前にこのイヤホンを選んだ理由も書きたいと思います。 今までは、ワイヤレスのAVIOT TE-D01gを使用していました（購入時の価格は約7,000円）。「AVIOT（アビオット）」は日本のオーディオメーカーです。 TE-D01gは長時間の再生時間が売りで、音質等のスペックもそこそこ良いという、コストパフォーマンスが高い製品でお気に入りでした。残念な点は、強いて言えば人混みだとたまにBluetoothが混線して破裂音のようなノイズが出ることがぐらいでした。こちらはもう1年以上使っていて、ケースの蓋が割れてパカパカしていたので「そろそろ替え時かな」と思っていたら、通勤時にどこかで落としたのかケースを紛失してしまい買い替えることにしました。 買い替えるにあたって、予算は10,000円。気にしたポイントは「長時間再生できる（バッテリーが長持ちである）こと」です。平日は毎日1時間強は使うため、充電を頻繁にするのは面倒だから避けたい。そういう意味では、TE-D01gにはとても満足していましたので、折角だから同じメーカーにしようと思い、「AVIOT TE-D01v」を選んだという訳です。 AVIOT TE-D01v ワイヤレスイヤホン ノイズキャンセリング イヤホン bluebooth 5.2 最大60時間 長時間再生 完全ワイヤレスイヤホン 重低音 IPX4防水 マルチポイント 外の音が聞こえる マイク付き 片耳モード タッチ操作 小型軽量 (ホワイト)\r10,900円～ amazon.co.jp ワイヤレスイヤホンって、Amazonとかだと5,000円以下の安い中国メーカー製が溢れていて、ぱっと見どれが良いのか分からないんですよね。別に中国製品だからダメという訳では無く、良い製品は日本製品以上のクオリティ・コストパフォーマンスを持っているのは事実です。 私はコスパ重視の貧乏性なので、こういった製品には飛びつきたいところでもあります。しかし、オーディオ製品って常に失敗と隣り合わせにあることが多いと感じるので、今回は安物買いの銭失いを避けて安定を取りたかったという背景もあります。 AVIOT TE-D01vの概要 ようやく本題です。「AVIOT TE-D01v」の製品概要を紹介します。価格はAmazonで約10,000円強でした。 外観 外観はこんな感じです。色は白を購入しました。 「AVIOT TE-D01v」の外観1 「AVIOT TE-D01v」の外観1 同梱品は以下のものになります。 イヤホン本体 ケース イヤーピース（3種類） USB-Cケーブル 説明書 実際に使用してのレビュー 項目 評価 総合得点 ★★★★☆ 音質 ★★★★☆ バッテリー ★★★★★ ノイズキャンセリング ★★★★★ 装着感・取り回し ★★★☆☆ 音質 10,000円のワイヤレスイヤホンとしては、音質はかなり良いと感じました。高音が目立たずやや低音が強いかな？と感じましたが全体的なバランスは取れてるかと思います。低音が気になる方は、専用アプリでイコライザ設定を行うこともできます。 バッテリー ケース込みで最大60時間再生可能と、スペックとしては充分です。平日で1日1時間半使うとしても数週間は充電しなくても持つ計算です。 ノイズキャンセリング R側のタッチセンサーを1.5秒長押し、または専用アプリからアクティブノイズキャンセリング機能をONにすることができます。アクティブノイズキャンセリング機能をONにしない状態でも、ノイズキャンセリングはかなり効いていると感じました。通勤時にはバスを利用していますが、走行中の騒音などはほとんど気になりません。 装着感・取り回し イヤホンの装着感に関しては良くも悪くも気になった点はありませんでした。装着時の違和感は通勤程度の運動なら全く問題ありません。 ただ、製品の取り回しで気になった点がありまして、充電ケースを開く際にちょっと引っ掛かりを感じました。ケースからイヤホンを取る際もツルツルしていて若干取り出しにくい。ケース自体は小型で携帯しやすいです。 半年程使用した結果、ケースにしまう際の接触が劣化してきてるのか、電源オフにならないことがたまに起こるようになりました。それ以外では特に不満はありません。 アプリについて 当製品は、AVIOTのイヤホン専用アプリの「AVIOT SOUND ME」からイコライザ設定などができます。ただ、アプリの評価がかなり低く、不具合が結構あるようです。実際にインストールしてみましたが、イヤホンを認識してくれなかったり、よく固まるので使っていません。幸い使わなくても性能に満足していますが、アプリが使いづらいのは残念な所の1つですね。 「AVIOT TE-D01v」についてレビューをまとめてみました。10,000円で買えるワイヤレスイヤホンとして、かなりおすすめできる商品だと思います。 このイヤホンが届くまで、数日間有線のイヤホンを使って「コードって邪魔だな…」と痛感しました。ワイヤレスは歩いたりするときの快適さは無論、持ち運びも簡単だから、通勤時が快適さが違いますね。小さいので落としたりなくしたりは気を付けなければいけませんが…。 以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/java-intern/",title:"【Java】internメソッドの仕組みをまとめる【コンスタントプール】",date:"2022-09-11T00:00:00Z",body:"【Java】internメソッドの仕組みをまとめる【コンスタントプール】 JavaのStringクラスのinternメソッドについて、その機能と使い方をまとめます。 internメソッドの機能と書式例 internメソッドはコンスタントプールの文字列を探します。コンスタントプールとは、重複する定数（特に文字列）を1か所にまとめて保持するメモリ領域のことです。 同じ文字列が存在すればその文字列を返し、同じ文字列が存在しない場合は新たに文字列を生成します。 文章だと分かりにくいので、下にあるサンプルコードで動きを理解しましょう。 メソッドの書式例は以下の通りです。 internメソッドの書式例\r1// 文字列がコンスタントプールにあるか検索 2&lt;文字列&gt;.intern();\rinternメソッドの使用例 メソッドの使用例をサンプルコードで示します。 InternTest.java\r1public class InternTest { 2 public static void main(String[] args) { 3 String s1 = new String(&#34;123&#34;); 4 String s2 = &#34;123&#34;; 5 String s3 = s1.intern(); 6 String s4 = s2.intern(); 7 8 System.out.println(&#34;s1 == s2:&#34; + (s1 == s2)); 9 System.out.println(&#34;s1 == s3:&#34; + (s1 == s3)); 10 System.out.println(&#34;s2 == s3:&#34; + (s2 == s3)); 11 System.out.println(&#34;s3 == s4:&#34; + (s3 == s4)); 12 } 13}\r実行結果が以下になります。 出力結果\r1s1 == s2:false 2s1 == s3:false 3s2 == s3:true 4s3 == s4:true\rサンプルコードでは、s1はnew演算子によってインスタンス化されています。s2とは参照先が違うためs1 == s2はfalseとなります。 s3は「コンスタントプール内のs1と同じ文字列」を探しますが、s1はインスタンス化されているため見つけることが出来ず、新たに文字列を生成しています。よって参照先が異なるためs1 == s3はfalseとなります。 s2とs3では、s3は「コンスタントプール内のs1と同じ文字列」を探しています。s2にs1と同じ文字列が入っているため、s3に「s2と同じ参照先の文字列」を代入します。よってs2 == s3はtrueになります。 s3とs4に関してもそれぞれ同じ文字列がs2に入っているため、どちらも「s2と同じ参照先の文字列」を代入します。よってs3 == s4はtrueになります。 今回はinternメソッドの紹介でした。以上で記事を終わりにします。 参考文献 String (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/javascript-var/",title:"【JavaScript】変数varは使わない方が良い理由【const・let】",date:"2022-09-05T00:00:00Z",body:"【JavaScript】変数varは使わない方が良い理由【const・let】 JavaScriptの変数型var・let・constについて、varの使用が非推奨とされる理由について、各変数宣言の特徴や巻き上げなどの観点からまとめます。 JavaScriptの変数宣言の特徴 JavaScriptの変数宣言にはvar・let・constの3種類があります。 JavaScriptの変数宣言\r1var a; 2let b; 3const c;\rそれぞれの特徴について見てみましょう。 var let const 再代入 ○ ○ × 再宣言 ○ × × スコープ 関数スコープ ブロックスコープ ブロックスコープ 再代入 再代入とは宣言した変数に、再度値を代入することです。var・letは再代入が可能ですが、constは不可能です。 再代入\r1//再代入可能 2var a = 1; 3a = 2; 4 5//再代入可能 6let b = 1; 7b = 2; 8 9//エラーが起きる 10//Uncaught TypeError: 11const c = 1; 12c = 2;\rここで、constは単なる再代入はできませんが、オブジェクト型の中身を変更することができます。 再代入\r1const obj = { 2 id: 01; 3 name: &#34;オブジェクト1&#34;; 4} 5//オブジェクトの中身は変えられる 6obj.name = &#34;オブジェクト2&#34;;\r再宣言 再宣言とは、宣言した変数名を再度宣言し直すことです。varは再宣言が可能ですが、let・constは不可能です。 再宣言\r1//再宣言可能 2var a = &#34;宣言1回目&#34;; 3var a = &#34;宣言2回目&#34;; 4 5//エラーが起きる 6//Uncaught SyntaxError: 7let b = &#34;宣言1回目&#34;; 8let b = &#34;宣言2回目&#34;; 9 10//エラーが起きる 11//Uncaught SyntaxError: 12const c = &#34;宣言1回目&#34;; 13const c = &#34;宣言2回目&#34;;\rスコープ スコープとは関数を呼び出すことが出来る範囲のことです。varのスコープは関数スコープであり、ある関数内で宣言した変数は、その関数のどこからでも呼び出すことができます。 スコープ\r1function x() { 2 3 var a = 1; 4 console.log(a); 5 { 6 7 a = 2; 8 console.log(a); 9 } 10 console.log(a); 11} 12 13//出力結果 14//1 15//2 16//2 対して、let・constのスコープはブロックスコープです。関数スコープと違い、関数内の記述位置でスコープから外れます。 スコープ\r1function x() { 2 3 let b = 1; 4 console.log(b); 5 { 6 7 b = 2; 8 console.log(b); 9 } 10 console.log(b); 11} 12 13//出力結果 14//1 15//2 16//1 変数の巻き上げについて JavaScriptには変数の巻き上げという独特の特徴を有しています。関数内で宣言された変数は、関数の先頭で宣言したとみなされます。 変数の巻き上げ\r1var x = &#34;Test1&#34;; 2 3function func() { 4 console.log(x); // undefinedが出力される 5 var x = &#34;Test2&#34;; 6 console.log(x); // Test2 7}\r上のコードではxの宣言前にconsole.logで記述していて、一見Test1が出力される気がしますが、undefined（未定義）が出力されます。これが変数の巻き上げで、上のコードは実行時には下のコードのように見なされます。 変数の巻き上げ\r1var x = &#34;Test1&#34;; 2 3function func() { 4 var x; //変数の巻き上げ 5 console.log(x); // undefinedが出力される 6 x = &#34;Test2&#34;; 7 console.log(x); // Test2 8}\rvarの利用が非推奨な理由 上で述べた様に、varは再宣言・再代入が可能であること、スコープの範囲が広いこと、巻き上げの特徴を持つことから、変数の値が意図しない影響を受けてしまう可能性があります。 上記のような仕様から、特に複雑なソースコードではvarを使用を避けるべきであると言えます。 基本的には変数宣言にはconstを使い、constだけでは難しい場合にletを使うようにしましょう。例えばfor文などは使うのはletですね。 今回はJavaScriptの変数型についてまとめました。以上で記事を終わりにします。 参考文献 var - JavaScript | MDN 変数 | 現代の JavaScript チュートリアル 古い var | 現代の JavaScript チュートリアル"},{url:"/dimzakki-mainroad/blog-pagespeed/",title:"【WordPress】PageSpeed Insightsで90点以上取る方法を解説",date:"2022-08-21T00:00:00Z",body:"【WordPress】PageSpeed Insightsで90点以上取る方法を解説 今回はWordPress（cocoonテーマ）でPageSpeed Insightsの測定をモバイル・デスクトップ共に90点以上を取る方法を紹介します。 記事を書いた当時、サイトにはWordPressの無料のcocoonテーマを導入しており、Google AdSenseも入れていたので、それに関連した設定方法も紹介しています。 なお、現在は更なる速度向上と運営コストを下げるために、WordPressからHugoに移行しました。 関連記事\r【Hugo】WordPressブログをHugo・AWSに移行した 当サイトのPageSpeed Insightsでの速度 Webサイト運営において、サイトの読み込み速度はSEO面で重要な要素の1つです。当サイトでもサイト速度を重視した設定にしています。 「PageSpeed Insights」で当サイトトップページの速度を計測した結果、スマホは94点、デスクトップは99点でした。 PageSpeed Insightsの計測結果（スマホ） PageSpeed Insightsの計測結果（デスクトップ） ちなみに、当サイトはレンタルサーバーの「ロリポップ」の一番安いプランで運営しています。単に読み込み速度を向上させるには、お高いレンタルサーバーの高額プランを契約することが単純かつ大きな効果を挙げます。しかし、それだと元も子もないので、お金を掛けずに高速化を目指す方法を取り上げたいと思います。 読み込み速度を向上させる方法 当サイトで行っている高速化の施策を紹介していきます。主にGoogle AdSenseを使用していて、尚且つサイトを高速化したい人向けになります。 結論としては、「不必要な機能は削除する」というのがサイトスピードの向上で大事な要素になります。 1. 不要なプラグインの削除 まず、プラグインは必要最低限の物以外はなるべく減らすようにしましょう。インストールされているプラグインの数が多いと、読み込み速度が低速化する原因になりやすいからです。 わざわざプラグインを入れなくても、多機能なcocoonの設定でカバーできるところも多いです。また、アップデートされていないプラグインを無くすことで、後述する「PHPのバージョンを最新化する」ことも可能になります。 実際に、現在このブログで使用しているプラグインは以下の4つです。 インストールしているプラグイン一覧 インストールしているプラグイン一覧\rCategory Order and Taxonomy Terms Order EWWW Image Optimizer Flying Scripts Google XML Sitemaps プラグインを導入しないと実現できない、もしくは非常に手間が掛かるという機能に関してのみ厳選してインストールしています。例えば、今まで使っていたソースコードをハイライト表示させる「SyntaxHighlighter」系のプラグインはかなり重く、cocoonに搭載されているハイライト機能で充分だったのでアンインストールしました。 残ったのはスタンダードで有名なプラグインばかりになりました。一応各プラグインについてさらっと紹介します。 Category Order and Taxonomy Terms Order カテゴリー・タグを並び替える機能を追加できます。これらの並べ替え機能はcocoonには無い機能なので導入しています。機能的に特に必要なければインストールする必要はありません。 EWWW Image Optimizer 自動でアップロードした画像をwebp形式に変換してくれます（要設定）。画像のwebp形式は軽くてほぼ全てのブラウザで対応しているため効果が大きく導入推奨になります。 Flying Scripts こちらは「PageSpeed Insights」の「改善できる項目」→「使用していないJavaScriptの削減」の指摘の対策用プラグインになります。指定したJavaScriptを遅延読み込みさせることで、指摘の改善を見込めます。Google AdSenseやGoogle Analyticsを導入している方は導入推奨です。 プラグインの設定で、「使用していないJavaScriptの削減」で指摘されたURLを貼り付けましょう。Timeoutは「4s」辺りに設定すると丁度いいと思います。 Google XML Sitemaps XMLサイトマップ用のプラグインです。XMLサイトマップ作成はSEO面で効果があるので、基本的に導入推奨です。 2. 問い合わせフォーム用のプラグインを廃止する お問い合わせページの送信フォーム用のプラグインは「Contact Form 7」などが有名ですね。こちらは便利なのですが、プラグイン自体が重く導入すること速度が低下してしまいます。プラグインを廃止して、代わりに「Googleフォーム」を利用することでプラグイン無しで問い合わせ機能を作成します。 詳しい導入方法は割愛しますが、「お問い合わせフォーム Googleフォーム」などで検索すると色々とやり方が紹介されているので参考になります。 その他、コメント欄も似たような仕組みですので、サイトで使用していない場合は撤去を考えると良いと思います。 3. SNS系ボタン・タイムライン表示を消す 特に「X（Twitter）」のタイムラインに言えることですが、これをサイドバーなどで表示させると全ページでそれらを読み込むことになり、結果的に速度がかなり低下してしまいます。 表示が必要な投稿ページ以外はタイムライン表示を削除した方が速くなります。同様に、SNSのフォローボタンも必要ない場合を削除した方が良いです。 4. PHPの設定を最新化する PHPの設定を最新化することで速度向上が見込めます。WordPressをインストールしているレンタルサーバーの管理画面でバージョン変更ができます。 ここで注意したいことが、PHPの特定のバージョンに対応していないプラグインを導入した状態で、PHPのバージョンを上げてしまうとエラーが発生してしまうことがあります。アクセスすると「このサイトで重大なエラーが発生しました。」とのみ表示されます。 5. cocoon設定で高速化の設定を行う cocoonテーマを使用している場合は、「cocoon設定」→「高速化」で全ての機能にチェックをつけます。意図しない挙動が発生しない限り、基本的に全部にチェックを付けるのをおすすめします。 今回はページ読み込み速度の向上についてまとめました。サイトの高速化についてはいまだ模索中なところもあるので、随時更新していきたいと思います。 特にプラグインの整理で速度が大きく改善されたと感じたので、とりあえず見直してみるだけで違うと思います。 なにかしら参考になることがあれば幸いです。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/qualification-sc/",title:"【情報処理安全確保支援士】合格体験記【約30時間で合格】",date:"2022-08-10T00:00:00Z",body:"【情報処理安全確保支援士】合格体験記【約30時間で合格】 情報処理安全確保支援士試験を2022年4月（令和4年度春期試験）に受け合格しましたので、試験の対策・結果・感想などを合格体験記としてまとめたいと思います。 また、セキュリティの業務経験が無い方向けの試験対策方法も紹介していきます。 試験の概要 情報処理安全確保支援士試験（支援士試験）は平成28年まで実施されていた情報セキュリティスペシャリスト試験の後継試験になります。IPA試験の中で最高難易度のレベル4に位置付けられ、出題範囲はセキュリティ分野に特化した試験になっています。アルファベットでは「SC」とも略されます。 また、試験の大きな特徴として試験合格後に申請を行うことで情報処理安全確保支援士に登録することができます。但し、資格の維持にはお金が掛かり、講習の参加も必要になります。例え合格しても申請をしなくても良いので、登録していない合格者も多いです。 そもそも、セキュリティスペシャリストから名前が変わったことで、知名度があまり無いような気もします…。 試験の内、午前Ⅰ試験は「応用情報に合格」「高度試験に合格」「高度試験の午前Ⅰで6割以上」のいずれかを満たしていると、2年間試験の免除が可能になります（受験申し込み時に試験免除も申請しないといけないので注意）。 その他、試験の細かい形式については、公式のページもご覧ください。 筆者について 具体的な試験対策に入る前に、私のプロフィールや受験した理由などを紹介します。 プロフィール\r2021年からITエンジニアになり、受験時の4月で丁度2年目 業務系のシステム開発などに従事 専門的なセキュリティに関する業務経験は無し 応用情報技術者試験を2021年4月の試験で合格済み 応用情報を支援士試験受験の1年前に合格しており、午前Ⅰ試験は免除しました。 受験したきっかけは色々ありました。ざっと思いつくことを挙げます。 受験したきっかけ\r前からセキュリティ分野に興味があった IPAの高度試験の中で唯一、年2回受験でき難易度が比較的低い ベンダー資格に比べ受験料が7 会社から資格手当が出る IPA試験はITパスポート・基本情報・応用情報と受験してきたので、どうせなら高度区分を何かしら1つは持っていると格好がつくかなと思っていました。別に急いで受ける必要はありませんでしたが、応用情報の取得後2年間は午前Ⅰが免除になる為、早めに受験することにしました。 試験の対策 私が実際に行った試験対策（独学）をまとめています。対策に掛けた時間は午前が10～15時間、午後が約10時間といったところで、午前午後に掛けた時間は同じかやや午前対策の比重が大きいくらいだと思います。本当は試験本番までにもっと時間を掛けて勉強する予定ではありましたが、午後試験の分をあまり勉強できませんでした。 仕事のスケジュールで3月末に開発していたシステムのリリースだったため、残業が多くなってしまったことが大きいですね（言い訳ですが…）。 初回の受験ということもあり、とりあえず様子見というか、今回は試験の雰囲気を感じられればいいかなと考えていました。 午前試験の対策 午前Ⅰ試験は免除しているので午前Ⅱ試験の対策のみ行いました。午前Ⅱは4択の選択問題形式で、セキュリティに関する知識が求められます。 iパス～応用情報までの午前試験対策と同様、「過去問道場」でひたすら過去問の周回をやっていました。午前対策はこれのみで問題ありません。過去問道場はスマホでもできるので移動時間や暇な時にちょこちょこできるのも嬉しい点です。 本番の試験でも過去問と同じ問題が多く出るのはIPAの他の試験と同じですね。繰り返し解いて分からない問題を無くしていくことが大事です。私は直近の10回分を周回していました。1回分が25問なので10回分で250問。被っている問題も多いので、実際に勉強する量はもっと少ないです。間違った問題は解説をしっかり読んで重点的に復習していき、分からない問題は積極的に減らしていきましょう。 午後試験の対策 午後試験はセキュリティの広範な知識に加え、長文問題を読んで解答していく文章読解力が求められてきます。試験時間は午後Ⅰは大問2問解答で90分結構厳しいものがあるので、45分で区切りしっかり2問解ききれるように心がけましょう。午後Ⅱは午後Ⅰと比べて時間的な余裕はそこそこあります。 私は主に参考書を使って勉強していました。実際に使っていて良かった本が「情報処理安全確保支援士「専門知識＋午後問題」の重点対策」です。この参考書のおかげで受かったと言っても過言ではないです（特に午後試験で恩恵を感じました）。新版が出ているので、そちらを紹介します。 2024　情報処理安全確保支援士「専門知識＋午後問題」の重点対策\r4,070円～ amazon.co.jp 午後試験の対策はこの一冊でOKです。各分野に沿って関連するいくつかの過去問と解説が載っており、過去問を解きながら知識を身に着けることができます。「各章の過去問を解く」→「分からなかった箇所の解説をしっかり読んで理解する」といった流れがおすすめです。 試験本番でも、午後Ⅱ問2のSAML認証の認証の流れを問う記号問題など、参考書に書いてある図がほとんどそのまま出て点数を稼ぐことができました。あまり勉強できなかった割に恩恵を感じたので、この参考書をしっかり勉強すれば、割と余裕で合格できるんじゃないでしょうか。 問題の選択についてですが、出題数自体が少ないので得意な分野を選ぶ余地はあまりありません。基本的には何が出題されても解けるくらいの準備をしていくことが推奨されます。例外として、セキュアプログラミングに関する問題はプログラミングの経験者でないと解答が困難であり、習得には時間が掛かるため、未経験者は避けるのが無難だと思われます。 試験当日 試験会場は1年前に応用情報を受験した時と同じ会場でした。公共交通機関で行くのが若干面倒な立地で当日は車で行きました。20分前までに着けばいいかと思っていたら、付近でイベントでもあったのか何故か道がめちゃ混んでいて試験開始するギリギリの到着になりました。「遅刻しても試験受けられるっけ…？」とスマホで検索してみたら、どうやら試験開始30分以内なら遅刻しても受験できるとのこと。みなさんは余裕を持って会場に着くようにしましょう。 試験の入室可能時間 試験開始2分前くらいに試験室に入ったら、当然全員着席して開始を待ってる状態で、自席を探そうとしてたら中々見つからず室内を1分くらいうろうろしてしまいました…。他の受験生から「なんだこいつ…」と言った感じに見られてしまいました（汗）。 持ち物は受験票（顔写真を貼り付け）・筆記用具・時計・参考書・昼食でした。最悪受験票と筆記用具があれば受験はできます。受験票は絶対忘れないようにしましょう。私が受けた会場には前に時計がありました。場所によってはないこともあると思うので、腕時計も忘れず持っていきましょう。 受験者層は若い方もいるものの、応用情報の時より更に年齢層が上がっているなと感じました。50～60歳位だと思われる受験生もちらほら。あと女性の割合が応用情報は更に少なかったです。空席は応用情報よりは少なかったかな？ 午前Ⅱ試験 遅刻の影響で若干バタつきがあったものの、過去問道場を周回したおかげで解答はスムーズにできました。知らない問題は勘で解答しました。試験時間は40分で途中退出は不可です。ほとんどの人は時間が余ると思います。 昼食は行くときにコンビニで買ってきたおにぎりとチョコレート。食べた後は持ってきた参考書を読んでました。受験者の男性率が高まる分トイレは多少混むので、一応早めに行っておくと安心です。 午後Ⅰ試験 午後Ⅰでは問1（セキュアプログラミング）と問3（QRコード決済）を選択しました。午後は解答用紙の問題選択のマークを忘れると採点されないのでよく確認しましょう。 問1ではJavaのセキュアプログラミングが出題されました。たまたま昔研修で似たようなことをやったことがあり記憶を辿って解答。研修も意外と役に立ちますね。 問3ではQRコード決済に関する出題でした。この問題は知識が無くても問題文に沿って解くことができるので難易度は割と簡単な方でしょうか？国語の問題に近いところがあります。 時間はかなりギリギリでしたが、手応えは割と自信ありました。多分6割は超えたかなと思いました。 午後Ⅱ試験 午後Ⅱでは問2（Webサイトの認証）を選択。問1どちらを選択するかは結構迷いました。あやふやな所があり自信が無かったものの、認証のところは参考書でざっと勉強してたので問2を選び、これも参考書で読んだ記憶を辿って解答しました。 時間が結構余ってしまい、解答もとりあえず埋めたので15分くらい前に退出しました。手応えは「運が良かったらギリギリ6割超えてるかも…」くらいの微妙なものでした。 試験の結果 自己採点は解答速報を少し眺めた程度でちゃんとはやっていません。午前Ⅱは6割はいっていると仮定して、午後Ⅰが6.5割、午後Ⅱが5.5割くらいだと予想していました。 試験の結果は大体2か月後に発表されます。春試験の場合は6月末ですね。結構遅いです。合否はIPA公式のサイトで、合格者の受験番号の一覧が張り出されるのでそこで合否を確認できます。また、詳しい得点は成績照会のページでも見ることができます。閲覧には受験票に載っているパスワードが必要です。 別に落ちていようが致命的なデメリットが発生するとかはないんですが、なんだかんだ試験結果を見る時は少し緊張しますね。今回の得点は以下になります。 安全確保支援士試験の結果 午前Ⅱ試験が68点、午後Ⅰ試験が69点、午後Ⅱ試験が70点で合格でした。自信が無かった午後Ⅱが一番高かったのは意外。そして一番勉強してた午前Ⅱが低かったですね…。おそらく、記述の採点基準が割と緩くて、部分点が結構入っているっぽいですね。それに出題問題との相性が良かったことも大きかったです。 無駄に運が良いというか、地味に資格の一発合格が続いているのは驚きですね。資格手当が増えるのが嬉しい！（そんなに変わらないけど） 試験を受けた感想 試験に受かったことでITエンジニアとして成長できたか？と問われると微妙です。所詮は試験が解けるかどうかの知識を付け焼き刃で暗記しただけで、今の仕事にも試験勉強が約に立っていることは無いのは少し残念です。 ですが、改めてセキュリティに対する学習をしたことは良かったと思っています。どんな分野のエンジニアでもセキュリティに関する知見は必要不可欠ですしね。 ちなみにですが、今のところ支援士登録はする予定はありません。維持するのにお金や手間が掛かるのに対して、享受できるメリットが特に無さそうなので…。 まだ試験に合格したばかりですので、もしかしたら何か合格して良かったと思えるようになるかもしれません。合格のリターンはともかく、試験代含めコスパは悪くない試験なので興味がある方は是非受けてみて下さい。 問題の相性の良し悪しはどうしてもありますので、もし落ちてしまっても諦めずに受ければ絶対に受かる試験だと思います。 受験する方の参考になれば幸いです。以上で記事を終わりにします。 参考文献 情報処理安全確保支援士試験 | 試験情報 | IPA 独立行政法人 情報処理推進機構"},{url:"/dimzakki-mainroad/java-ceil-floor-round/",title:"【Java】小数点の切り上げ・切り捨て・四捨五入をする",date:"2022-08-04T00:00:00Z",body:"【Java】小数点の切り上げ・切り捨て・四捨五入をする JavaのMathクラスのceil・floor・roundメソッドでdouble型などの変数の小数点以下を丸めて整数にする方法を紹介します。 それぞれのメソッドの処理 それぞれのメソッドの機能について紹介します。 ceilメソッド:切り上げ ceilメソッドは小数の切り上げ（対象の数値以上の中で最も小さい整数値を返す）を行います。戻り値はdouble型で返されます。 ceilメソッドの書式例\r1Math.ceil(1.5); // 2.0が返ってくる\r引数がNaN、無限大、正または負の0、の場合は、引数と同じ値が返されます。 floorメソッド:切り捨て floorメソッドは小数の切り捨て（対象の数値以下の中で最も大きい整数値を返す）を行います。戻り値はdouble型で返されます。 floorメソッドの書式例\r1Math.floor(1.5); // 1.0が返ってくる\r引数がNaN、無限大、正または負の0、の場合は、引数と同じ値が返されます。 roundメソッド:四捨五入 roundメソッドは小数を小数第1位で四捨五入します。戻り値はint・long型で返されます。double型の場合はlong型で、float型の場合はint型の返り値になります。上2つのメソッドとは返り値の型が異なるので注意しましょう。 roundメソッドの書式例\r1Math.round(1.5); // 2が返ってくる\r引数がNaNの場合は0が返されます。 メソッドの使用例 それぞれのメソッドの使用例をサンプルコードで示します。小数第2位以下で四捨五入を行いたい時は、一度桁上げを行ってから四捨五入し、その後桁下げをする必要があります。 RealNumTest.java\r1public class RealNumTest { 2 public static void main(String[] args) { 3 double d1 = 0.5; 4 double d2 = 2.5; 5 double d3 = 2.4; 6 double d4 = 1.15; 7 8 // 小数点以下を切り上げする 9 System.out.println(d1 + &#34;の切り上げ:&#34; + Math.ceil(d1)); 10 System.out.println(-d1 + &#34;の切り上げ:&#34; + Math.ceil(-d1)); 11 12 // 小数以下を切り捨てする 13 System.out.println(d1 + &#34;の切り上げ:&#34; + Math.floor(d1)); 14 System.out.println(-d1 + &#34;の切り捨て:&#34; + Math.floor(-d1)); 15 16 // 小数第1位で四捨五入する 17 System.out.println(d2 + &#34;の四捨五入:&#34; + Math.round(d2)); 18 System.out.println(-d2 + &#34;の四捨五入:&#34; + Math.round(-d2)); 19 System.out.println(d3 + &#34;の四捨五入:&#34; + Math.round(d3)); 20 System.out.println(-d3 + &#34;の四捨五入:&#34; + Math.round(-d3)); 21 22 // 小数第2位で四捨五入する 23 System.out.println(d4 + &#34;の四捨五入(小数第2位):&#34; + ((double) Math.round(d4 * 10)) / 10); 24 } 25}\r実行結果が以下になります。 出力結果\r10.5の切り上げ:1.0 2-0.5の切り上げ:-0.0 30.5の切り上げ:0.0 4-0.5の切り捨て:-1.0 52.5の四捨五入:3 6-2.5の四捨五入:-2 72.4の四捨五入:2 8-2.4の四捨五入:-2 91.15の四捨五入(小数第2位):1.2\rそれぞれ小数点以下を丸めた整数に変換されました。 切り捨て・切り上げの覚え方ですが、ceilは「天井」という意味なので切り上げ、floorは「床」という意味なので切り捨てという風に覚えましょう。 以上で記事を終わりにします。 参考文献 Math (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/java-tostring-deeptostring-method/",title:"【Java】配列の中身を文字列に置換する【1次元・多次元配列】",date:"2022-07-01T00:00:00Z",body:"【Java】配列の中身を文字列に置換する【1次元・多次元配列】 JavaのArrayクラスのtoStringメソッドとdeeptoStringメソッドで配列の中身を文字列に置き換える方法を紹介します。 メソッドの書式 それぞれのメソッドの書式を以下に示します。 メソッドの書式\r1// toStringメソッドの書式例 2Arrays.toString(Object[] obj); 3 4// deepToStringメソッドの書式例 5Arrays.deepToString(Object[] obj);\rtoStringメソッドを使うことで配列を文字列に置き換えることができます。deepToStringメソッドでは多次元配列（2次元以上の配列）を文字列に置き換えることができます。 多次元配列とは、配列が入れ子構造になっている配列のことです。 メソッドの書式\r1// 1次元配列 2String[] str1 = { &#34;10&#34;, &#34;20&#34;, &#34;30&#34; }; 3 4// 2次元配列 5String[][] str2 = { { &#34;10&#34;, &#34;20&#34;, &#34;30&#34; }, { &#34;40&#34;, &#34;50&#34;, &#34;60&#34; } };\r引数がnullの場合はnullを返します。 メソッドの使用例 それぞれのメソッドの使用例をサンプルコードで紹介します。 ToStringTest.java\r1import java.util.Arrays; 2 3public class ToStringTest { 4 public static void main(String[] args) { 5 String[] str1 = { &#34;10&#34;, &#34;20&#34;, &#34;30&#34; }; 6 String[][] str2 = { { &#34;10&#34;, &#34;20&#34;, &#34;30&#34; }, { &#34;40&#34;, &#34;50&#34;, &#34;60&#34; } }; 7 String[] str3 = null; 8 9 // toStringでstr1,str2,str3を出力する 10 System.out.println(&#34;str1:&#34; + Arrays.toString(str1)); 11 System.out.println(&#34;str2:&#34; + Arrays.toString(str2)); 12 System.out.println(&#34;str3:&#34; + Arrays.toString(str3)); 13 // deepToStringでstr1,str2,str3を出力する 14 System.out.println(&#34;str1:&#34; + Arrays.deepToString(str1)); 15 System.out.println(&#34;str2:&#34; + Arrays.deepToString(str2)); 16 System.out.println(&#34;str3:&#34; + Arrays.deepToString(str3)); 17 } 18}\r実行結果が以下になります。 出力結果\r1str1:[10, 20, 30] 2str2:[[Ljava.lang.String;@4517d9a3, [Ljava.lang.String;@372f7a8d] 3str3:null 4str1:[10, 20, 30] 5str2:[[10, 20, 30], [40, 50, 60]] 6str3:null\r多次元配列をtoStringメソッドで出力すると、配列への参照が表示されます。 参考文献 Arrays (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/java-int-string-change/",title:"【Java】int型⇔String型の変換【推奨方法】",date:"2022-06-30T00:00:00Z",body:"【Java】int型⇔String型の変換【推奨方法】 Javaのint型とString型の変換の方法について、一番ノーマルで推奨されるやり方を紹介します。 int型→String型への変換方法 int型からString型へ変換するには、StringクラスのvalueOfメソッドを使います。書式は以下の通りです。 valueOfメソッドの書式例\r1String str = String.valueOf(num);\r変数numの中身を変数strに代入することができます。 String型→int型への変換方法 String型からint型へ変換するにはIntegerクラスのparseIntメソッドを使います。書式は以下の通りです。 parseIntメソッドの書式例\r1int num = Integer.parseInt(str);\r変数strの中身を変数numに代入することができます。なお、以下のようにint型に文字を入れようとするとNumberFormatExceptionのエラーが出ます。 parseIntメソッドの書式例\r1// NumberFormatExceptionエラーになる 2int num = Integer.parseInt(&#34;a&#34;);\rメソッドの使用例 上記の2つのメソッドの使用例をサンプルコードで示します。変数の型はClassオブジェクトのgetSimpleNameメソッドで確認します。このメソッドは参照型のみ扱われるため、int型の判定はObject型にキャストを行っています。 IntStringTest.java\r1public class IntStringTest { 2 public static void main(String[] args) { 3 String str1 = &#34;123&#34;; 4 int num1 = 321; 5 System.out.println(&#34;str1:&#34; + str1); 6 System.out.println(&#34;str1の型:&#34; + str1.getClass().getSimpleName()); 7 System.out.println(&#34;num1:&#34; + num1); 8 System.out.println(&#34;num1の型:&#34; + ((Object) num1).getClass().getSimpleName()); 9 10 // int→Stingへ変換 11 String str2 = String.valueOf(num1); 12 System.out.println(&#34;str2:&#34; + str2); 13 System.out.println(&#34;str2の型:&#34; + str2.getClass().getSimpleName()); 14 // Sting→intへ変換 15 int num2 = Integer.parseInt(str1); 16 System.out.println(&#34;num2:&#34; + num2); 17 System.out.println(&#34;num2の型:&#34; + ((Object) num2).getClass().getSimpleName()); 18 } 19}\r実行結果が以下になります。 出力結果\r1str1:123 2str1の型:String 3num1:321 4num1の型:Integer 5str2:321 6str2の型:String 7num2:123 8num2の型:Integer\r型変換がされていることが分かります。以上で記事を終わりにします。 参考文献 String (Java Platform SE 8 ) | Oracle Integer (Java Platform SE 8 ) | Oracle Class (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/java-random-password/",title:"【Java】ランダムな文字列（パスワード）を生成してみる",date:"2022-05-18T00:00:00Z",body:"【Java】ランダムな文字列（パスワード）を生成してみる Javaでランダムな文字列（パスワード）を生成するプログラムを書いてみます。 実装したいこと このプログラムで実現したいこととして、以下の3つの機能を実装してみたいと思います。 実装したいこと\r文字数を指定してランダムな文字列を生成する 使う文字種はアルファベット（小文字）を基本とする アルファベットの大文字と数字も使えるようにする プログラムの実装 実際に書いてみました。StringBuilderクラスでパスワードに使う文字種を提示して、Randomクラスでランダムに文字列を選びだして生成していきます。 実装したいこと\r【Java】Randomクラスで乱数を生成する【数値・真理値】 MakePassword.java\r1import java.util.Random; 2 3public class MakePassword { 4 5 /** 実行用mainメソッド */ 6 public static void main(String[] args) { 7 System.out.println(makePassword(10, true, true)); 8 } 9 10 /** パスワードを作成 */ 11 private static StringBuilder makePassword(int length, boolean uppercaseFlg, boolean digitFlg) { 12 StringBuilder lowercase = new StringBuilder(&#34;abcdefghijklmnopqrstuvwxyz&#34;); 13 StringBuilder uppercase = new StringBuilder(&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;); 14 StringBuilder digit = new StringBuilder(&#34;0123456789&#34;); 15 16 if (uppercaseFlg) { 17 lowercase.append(uppercase); 18 } 19 if (digitFlg) { 20 lowercase.append(digit); 21 } 22 23 StringBuilder password = new StringBuilder(); 24 25 Random rand = new Random(); 26 for (int i = 0; i &lt; length; i++) { 27 int num = rand.nextInt(lowercase.length()); 28 password.append(lowercase.charAt(num)); 29 } 30 31 return password; 32 } 33}\r実行結果の一例が以下になります。 出力結果（一例）\r1qcFnJWtL8B\rパスワードを生成することができました。 ランダムクラスを使うことで、ランダムパスワードが作れますね。追加機能なども考えてみたいです。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/java-islowercase-method/",title:"【Java】isLowerCaseメソッドで小文字かどうか判定する",date:"2022-05-04T00:00:00Z",body:"【Java】isLowerCaseメソッドで小文字かどうか判定する JavaのCharacterクラスのisLowerCaseメソッドを使って、文字が小文字のアルファベットかどうかか判定する方法を紹介します。 isLowerCaseメソッドの書式 isLowerCaseメソッドは、以下の様に記述します。 isLowerCaseメソッドの書式例\r1Character.isDigit(int i);\r戻り値の型はboolean型で、文字を比較して小文字であればtureそうでなければfalseを返します。 小文字かどうかの判定はCharacter.getType(文字)によって提供される汎用カテゴリ型がLOWERCASE_LETTERの時になります。 メソッドの使用例 実際に、メソッドの使用例をサンプルコードで示します。 IsLowerCaseTest.java\r1public class IsLowerCaseTest { 2 public static void main(String[] args) { 3 // それぞれ小文字かどうか判定する 4 System.out.println(&#34;LOWERCASE_LETTER:&#34; + Character.LOWERCASE_LETTER); 5 System.out.println(&#34;a の汎用カテゴリ型:&#34; + Character.getType(&#39;a&#39;)); 6 System.out.println(&#34;a のisLowerCase:&#34; + Character.isLowerCase(&#39;a&#39;)); 7 8 System.out.println(&#34;UPPERCASE_LETTER:&#34; + Character.UPPERCASE_LETTER); 9 System.out.println(&#34;A の汎用カテゴリ型:&#34; + Character.getType(&#39;A&#39;)); 10 System.out.println(&#34;A のisLowerCase:&#34; + Character.isLowerCase(&#39;A&#39;)); 11 12 System.out.println(&#34;DECIMAL_DIGIT_NUMBER:&#34; + Character.DECIMAL_DIGIT_NUMBER); 13 System.out.println(&#34;0 の汎用カテゴリ型:&#34; + Character.getType(&#39;0&#39;)); 14 System.out.println(&#34;0 のisLowerCase:&#34; + Character.isLowerCase(&#39;0&#39;)); 15 16 System.out.println(&#34;OTHER_LETTER:&#34; + Character.OTHER_LETTER); 17 System.out.println(&#34;あ の汎用カテゴリ型:&#34; + Character.getType(&#39;あ&#39;)); 18 System.out.println(&#34;あ のisLowerCase:&#34; + Character.isLowerCase(&#39;あ&#39;)); 19 } 20}\r実行結果が以下になります。 出力結果\r1LOWERCASE_LETTER:2 2a の汎用カテゴリ型:2 3a のisLowerCase:true 4UPPERCASE_LETTER:1 5A の汎用カテゴリ型:1 6A のisLowerCase:false 7DECIMAL_DIGIT_NUMBER:9 80 の汎用カテゴリ型:9 90 のisLowerCase:false 10OTHER_LETTER:5 11あ の汎用カテゴリ型:5 12あ のisLowerCase:false\r文字の汎用カテゴリ型がLOWERCASE_LETTERと一致した時にtrueが返ることが分かります。 isLowerCaseメソッドの使い方でした。以上で記事を終わりにします。 参考文献 Character (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/product-review-chair/",title:"【商品レビュー】ニトリのリカルド（オフィスチェア）が良かったので紹介",date:"2022-05-04T00:00:00Z",body:"【商品レビュー】ニトリのリカルド（オフィスチェア）が良かったので紹介 ニトリのリカルド（オフィスチェア）の商品レビューをしたいと思います。買ってから1ヶ月くらい経った使用感などをレビューしていきます。 オフィスチェアを買ったきっかけ なぜ、新しいイスが欲しかったのかというと、最近テレワークで自室のイスに座る時間が長かったからです。平日だと仕事で8時間近く座り、ゲームやPCを触る時間もあるという感じで、半日近く同じイスに座っていることになります。今まではAmazonで購入した5千円くらいのイスを使っていました。これ自体は悪くはないけど値段相応でした。今までも「新しいイスが欲しい」とは感じていました。 実際にニトリに行って実際に色々とイスに座ってみて、一番座り心地が良かったイスを買いました。そのイスが、「ワークチェア リカルド」です。なお、イス選びでは、実際に座ってみることがとても重要です。 この記事で紹介しているイスは確かにいい商品であるのですが、結局個人差があるので、ネットや口コミの情報だけを信じて買うと失敗する可能性があります。今回紹介する「リカルド」も、興味を持った方はニトリに行って、座って確かめてみるのを是非オススメします。 「リカルド」の外観 購入したのはブラック。楽天で購入し、お値段は丁度3万円でした。サイズは幅66cm×奥行72cm×高さ108cmです。 実際に使っているものの写真を載せます。 「リカルド」の正面画像 実際に使っているものの写真も上に載せました。普通のオフィスチェアより高級感ありますね。 実際に使用した感想を書いていきます。まず、一番言いたいことは、「座り心地が良い！」ということ。フカフカと包み込まれるような感触を感じます。これを使っていると、仕事で1日座りっぱなしでも肩が凝ったり腰が痛くなったりしません。通気性も良いので蒸れたりもないです。店舗で座ったイスと比較して、ちょっと固い感じもありましたが、店舗に置かれているものは色々な人にたくさん座られているので、イスがこなれていたのでしょう、購入した商品も使って入れば柔らかくなっていくと思われます。 機能としてはリクライニングも可能です。最大角度は135度になります。 組み立てについて イスの組み立てに関しては簡単でした。特に詰まることもなく、1人で15分程度で完成できました。組み立てたイス上部をキャスターに乗せるところは、1人でやると不安定でやりづらいので、誰かに手伝ってもらうと楽だと思います。説明書では2人での組み立てを推奨しています。 「リカルド」を継続使用した感想 「リカルド」を買ってから3年以上経ちました。耐久性は特に問題無し。強いて不満に感じることを挙げるとすると、キャスターの挙動がしっくり来ないことでしょうか。 テレワーク時は一日中このイスに座っていました。出社することもあるので、オフィスで普通のオフィスチェアに座っていることもありますが、やはり普通のオフィスチェアとの違いを感じざるを得ませんね。安いイス（固いイス）に長時間座っていると、お尻の骨が圧迫されるのか痛くなりますね。後、若干ですが肩こりもあるような気がします。短時間ならなんともないですが、長時間作業するときの負担の差ですね。ここは「リカルド」と普通のオフィスチェアとの大きな違いかなと感じています。 仕事で座らないと買った意味ないのかという話では無くて、家でゲームやブログを書いてる時はこのイスに座って作業していますし、仕事柄再びテレワークを行う可能性はあるため、良い買い物をしたという感想は変わりません。 今回はイスの「リカルド」を紹介しました。3万円でこの快適さはかなりの良コスパでした。しかし、気を付けたいのは、「コスパ以上に大事なことは自分に合っているかどうか」だと思います。そこで妥協すると結局後悔することになります。特に、イスに座っている時間が長い人は、自分に合ったイス選びが大切ですね。 皆さんも良い椅子ライフを！以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/java-deletecharat-method/",title:"【Java】deleteCharAtメソッドで文字列から文字を削除する方法",date:"2022-04-30T00:00:00Z",body:"【Java】deleteCharAtメソッドで文字列から文字を削除する方法 Javaで文字列から文字を削除するにはStringBuilderクラスとStringBufferクラスのdeleteCharAtメソッドを使えます。これらのメソッドの使い方を紹介します。 deleteCharAtメソッドの書式 deleteCharAtメソッドは以下の様に記述します。 deleteCharAtメソッドの書式\r1Char c.deleteCharAt(int index);\r文字の位置を数字で指定して、文字列からその文字を削除した文字列が返されます。文字の位置は最初が0になります。配列の添え字と同じですね。 数字に文字数より大きい数字を入力するとStringIndexOutOfBoundsExceptionのエラーが発生します。 StringBuilderクラスとStringBufferクラスの違いはスレッドセーフかどうかになります。StringBuilderクラスはスレッドセーフでない分、StringBufferクラスより処理速度が速いです 続いて、メソッドの使用例をサンプルコードで紹介します。 DeleteCharAtTest.java\r1public class DeleteCharAtTest { 2 public static void main(String[] args) { 3 // 文字列ABCDEから2の位置の文字を削除して出力する 4 StringBuilder str = new StringBuilder(&#34;ABCDE&#34;); 5 System.out.println(&#34;str:&#34; + str); 6 System.out.println(&#34;strの2の位置の文字を削除:&#34; + str.deleteCharAt(2)); 7 } 8}\r実行結果が以下になります。 出力結果\r1str:ABCDE 2strの2の位置の文字を削除:ABDE\r2行目では文字列「ABCDE」の位置2の文字である「C」が削除され「ABDE」が出力されています。 今回はJavaで文字列から文字を削除する方法について紹介しました。 似たメソッドに文字列から文字を取得するStringクラスのcharAtメソッドがあるので注意しましょう。 以上で記事を終わりにします。 参考文献 StringBuilder (Java Platform SE 8 ) | Oracle StringBuffer (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/java-localdate-period/",title:"【Java】LocalDateクラスで日付の期間を計算する方法",date:"2022-04-23T00:00:00Z",body:"【Java】LocalDateクラスで日付の期間を計算する方法 JavaのLocalDateクラスで日付の期間を計算する方法について紹介します。 関連記事\r【Java】LocalDateクラスで日付を加算・減算する方法 Periodクラスで日付の期間を計算する方法 Periodクラスのbetweenメソッドを使うことで2つの日付の期間を計算することができます。betweenメソッドは以下の様に記述します。 betweenメソッドの記述例\r1Period period = Period.between(LocalDate date1, LocalDate date2);\r変数に変数1と変数2の期間を代入しています。 また、getメソッドによって年・月・日を取り出すことができます。getメソッドはgetYears・getMounths・getDaysメソッドが存在します。 メソッドの使用例 実際に、メソッドの使用例をサンプルコードで示します。 LocalDateBetweenTest.java\r1import java.time.LocalDate; 2import java.time.Period; 3 4public class LocalDateBetweenTest { 5 public static void main(String[] args) { 6 LocalDate date1 = LocalDate.of(2020, 1, 1); 7 LocalDate date2 = LocalDate.of(2021, 8, 15); 8 System.out.println(&#34;date1:&#34; + date1); 9 System.out.println(&#34;date2:&#34; + date2); 10 11 // date1とdate2の期間を取得する 12 Period period = Period.between(date1, date2); 13 System.out.println(&#34;period:&#34; + period); 14 15 // priodを年、月、日に分割して出力する 16 System.out.println(&#34;periodの年:&#34; + period.getYears()); 17 System.out.println(&#34;periodの月:&#34; + period.getMonths()); 18 System.out.println(&#34;periodの日:&#34; + period.getDays()); 19 } 20}\r実行結果が以下になります。 出力結果\r1date1:2020-01-01 2date2:2021-08-15 3period:P1Y7M14D 4periodの年:1 5periodの月:7 6periodの日:14\rdate1とdate2の期間が出力されました。 ここで、出力結果の一行目が分かりづらくなっていますが、最初のPを飛ばし、「1Y(年)7M(月)14D(日)」の期間であるという意味を持ちます。 その下はそれぞれgetメソッドで分割して表示しています。 参考文献 LocalDate (Java Platform SE 8 ) | Oracle Period (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/java-localdate-addition-subtraction/",title:"【Java】LocalDateクラスで日付を加算・減算する方法",date:"2022-04-07T00:00:00Z",body:"【Java】LocalDateクラスで日付を加算・減算する方法 JavaのLocalDateクラスで日付の加算と減算を行う方法について紹介します。 関連記事\r【Java】LocalDateクラスで日付の期間を計算する方法 日付を加算・減算する方法 LocalDateクラスには、plusDaysメソッドやminusDaysメソッドといった日付を指定した分増やしたり減らしたりするメソッドが存在します。 書式については、以下の様に記述します。plusDaysメソッドを例に紹介します。 plusDaysメソッドの記述例\r1LocalDate localdate.plusDays(long l);\r上では、LocalDateクラスの変数に数字分の日にちを加算しています。 メソッドは日・週・月・年ごとにそれぞれpulsメソッドとminusメソッドがあります。 メソッドの使用例 それぞれのメソッドの使用例をサンプルコードで紹介します。 LocalDateTest.java\r1import java.time.LocalDate; 2 3public class LocalDateTest { 4 public static void main(String[] args) { 5 // 2021-01-01を生成する 6 LocalDate localdate = LocalDate.of(2021, 1, 1); 7 System.out.println(&#34;localdate:&#34; + localdate); 8 9 // localdateの2日後と3日前を出力する 10 System.out.println(&#34;localdateの2日後:&#34; + localdate.plusDays(2)); 11 System.out.println(&#34;localdateの3日前:&#34; + localdate.minusDays(3)); 12 13 // localdateの2週後と3週前を出力する 14 System.out.println(&#34;localdateの2週後:&#34; + localdate.plusWeeks(2)); 15 System.out.println(&#34;localdateの3週前:&#34; + localdate.minusWeeks(3)); 16 17 // localdateの2月後と3月前を出力する 18 System.out.println(&#34;localdateの2月後:&#34; + localdate.plusMonths(2)); 19 System.out.println(&#34;localdateの3月前:&#34; + localdate.minusMonths(3)); 20 21 // localdateの2年後と3年前を出力する 22 System.out.println(&#34;localdateの2年後:&#34; + localdate.plusYears(2)); 23 System.out.println(&#34;localdateの3年前:&#34; + localdate.minusYears(3)); 24 25 } 26}\r実行結果が以下になります。 出力結果\r1localdate:2021-01-01 2localdateの2日後:2021-01-03 3localdateの3日前:2020-12-29 4localdateの2週後:2021-01-15 5localdateの3週前:2020-12-11 6localdateの2月後:2021-03-01 7localdateの3月前:2020-10-01 8localdateの2年後:2023-01-01 9localdateの3年前:2018-01-01\rそれぞれ日付が加減されていることがわかります。 今回はJavaで日付の加算と減算を行う方法を紹介しました。以上で記事を終わりにします。 参考文献 LocalDate (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/java-mini-numberplace-1/",title:"【Java】ランダムなミニナンプレをプログラムで作ってみる",date:"2022-04-02T00:00:00Z",body:"【Java】ランダムなミニナンプレをプログラムで作ってみる Javaで4×4のミニナンプレをランダムに生成するプログラムを書いてみます。 関連記事\r【Java】ランダムな4×4の魔方陣を出力する ミニナンプレとは ナンプレはロジックパズルとして有名で馴染み深いものとして知られています。今回作るミニナンプレはナンプレを簡略化したもので、1～4の数字を使った4×4のパズルになります。下に、問題と解答の一例を示します。 $$ \\large\\begin{array}{|c|c|c|c|} \\hline 1 &amp; &amp; &amp; \\\\ \\hline 3 &amp; &amp; 1 &amp; 2 \\\\ \\hline 4 &amp; 3 &amp; &amp; 1 \\\\ \\hline &amp; &amp; &amp; 3 \\\\ \\hline \\end{array} \\to \\large\\begin{array}{|c|c|c|c|} \\hline 1 &amp; 2 &amp; 3 &amp; 4 \\\\ \\hline 3 &amp; 4 &amp; 1 &amp; 2 \\\\ \\hline 4 &amp; 3 &amp; 2 &amp; 1 \\\\ \\hline 2 &amp; 1 &amp; 4 &amp; 3 \\\\ \\hline \\end{array} $$ 縦と横の全ての列と中心で区切られた4マスのボックスに1～4の数字が全て入るように数字を当てはめます。 今回のプログラムを作成について、まず右側の完成した表から作っていき、そこから左側の問題となる表を求めたいと思います。 4×4のミニナンプレ表（完成表）を作成する 前回の記事で書いたプログラムを改変して使います。アルゴリズムとしては以下のような流れになります。 アルゴリズム\rArrayListに1～4の数字を格納し、shuffleメソッドでシャッフルしてから4×4の配列に4回分のArrayListを格納して仮の表を作る 仮の表が条件に一致するまで、その都度シャッフルを繰り返す 条件に一致した仮表が出来たら完成表として出力する アルゴリズムの詳細な部分は前回と被るところが多いので割愛します。 前回の魔方陣の時と違うところは、「全ての行・列・ボックスの合計が10である」「横の行については既にシャッフルによって完成しているので、縦の列とボックスのみ比較すれば良い」の2点です。縦の行とボックスはHashSetを使って数字を格納し、sizeメソッドを使ってサイズが4である（1から4全て使ってる）かチェックしました。 なお、ボックスの比較については、縦横が揃っていてボックスの4つの内どれか一つっでも条件を満たしていれば他の3つも自動的に条件を満たすため、左上のみ判定しています。また、前回と同様シャッフル回数測定のために変数countを設置しています。 実際にできたコードが下になります。 MakeMiniNumberPlace.java\r1import java.util.ArrayList; 2import java.util.Collections; 3import java.util.HashSet; 4import java.util.List; 5import java.util.Set; 6 7public class MakeMiniNumberPlace { 8 /** 1から16までを格納するArrayList */ 9 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 10 11 /** 魔方陣の数字を格納する配列 */ 12 int[][] array = new int[4][4]; 13 14 /** 重複チェック用のhashSet */ 15 Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;(); 16 17 /** シャッフル回数カウント用の変数 */ 18 int count = 0; 19 20 /** 実行用mainメソッド */ 21 public static void main(String[] args) { 22 MakeMiniNumberPlace mMiniNumberPlace = new MakeMiniNumberPlace(); 23 mMiniNumberPlace.execute(); 24 } 25 26 /** 魔方陣の作成 */ 27 private void execute() { 28 generateList(); 29 30 label: while (true) { 31 // 横の列を比較 32 for (int i = 0; i &lt; 4; i++) { 33 for (int j = 0; j &lt; 4; j++) { 34 array[i][j] = list.get(j); 35 } 36 Collections.shuffle(list); 37 count++; 38 } 39 40 // 縦の列を比較 41 hashSet.clear(); 42 for (int i = 0; i &lt; 4; i++) { 43 for (int j = 0; j &lt; 4; j++) { 44 hashSet.add(array[j][i]); 45 } 46 if (hashSet.size() != 4) { 47 continue label; 48 } 49 hashSet.clear(); 50 } 51 52 // 縦の列はOKなのでボックスの中身を比較 53 // 左上のボックスが条件を満たしていれば他のボックスも自動的にOK 54 hashSet.add(array[0][0]); 55 hashSet.add(array[0][1]); 56 hashSet.add(array[1][0]); 57 hashSet.add(array[1][1]); 58 if (hashSet.size() == 4) { 59 break; 60 } 61 } 62 63 showArray(); 64 } 65 66 /** listに1～4を格納しシャッフル */ 67 private void generateList() { 68 list.clear(); 69 for (int i = 1; i &lt;= 4; i++) { 70 list.add(i); 71 } 72 Collections.shuffle(list); 73 } 74 75 /** 配列を数表形式で出力する */ 76 private void showArray() { 77 for (int[] a : array) { 78 for (int i : a) { 79 System.out.printf(&#34;%3d&#34;, i); 80 } 81 System.out.println(); 82 } 83 System.out.println(&#34;シャッフル回数:&#34; + count); 84 } 85}\r実行結果の一例が以下になります。 出力結果（一例）\r1 2 3 1 4 2 4 1 3 2 3 1 2 4 3 4 3 4 2 1 5シャッフル回数:10688\r完成表が出力されました。countは5000～10000になることが多かったですね。前回よりシャッフル回数も格段に少ないことが分かります。こちらの方が条件が緩いので、完成表を求めるのに試行回数が少なく済んでいます。 ミニナンプレの問題を作るプログラム 次は、今回得た表からどうやってミニナンプレを作るか検討していきます。完成表から10個穴を開けるやり方で実装してみます。 実際にできたコードが下になります。 PunchMiniNumberPlace.java\r1import java.util.ArrayList; 2import java.util.Collections; 3import java.util.List; 4 5public class PunchMiniNumberPlace { 6 7 /** 魔方陣の問題を格納する配列 */ 8 int[][] originalArray; 9 10 /** 魔方陣の問題を格納する配列 */ 11 int[][] probArray; 12 13 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 14 15 /** 実行用mainメソッド */ 16 public static void main(String[] args) { 17 PunchMiniNumberPlace pMiniNumberPlace = new PunchMiniNumberPlace(); 18 pMiniNumberPlace.originalArray = new int[][] { { 1, 2, 3, 4 }, { 3, 4, 1, 2 }, { 4, 3, 2, 1 }, { 2, 1, 4, 3 } }; 19 pMiniNumberPlace.probArray = new int[4][4]; 20 pMiniNumberPlace.execute(); 21 pMiniNumberPlace.showArray(); 22 } 23 24 /** ミニナンプレの問題を作る */ 25 private void execute() { 26 // 0に置き換える箇所を決める 27 for (int i = 0; i &lt;= 15; i++) { 28 list.add(i); 29 } 30 Collections.shuffle(list); 31 32 for (int i = 0, x = 0; i &lt; 4; i++) { 33 for (int j = 0; j &lt; 4; j++) { 34 if (x == list.get(0) || x == list.get(1) || x == list.get(2) || x == list.get(3) || x == list.get(4) 35 || x == list.get(5)) { 36 probArray[i][j] = originalArray[i][j]; 37 } else { 38 probArray[i][j] = 0; 39 } 40 x++; 41 } 42 } 43 } 44 45 /** 配列を数表形式で出力する */ 46 private void showArray() { 47 for (int[] a : originalArray) { 48 for (int i : a) { 49 System.out.printf(&#34;%3d&#34;, i); 50 } 51 System.out.println(); 52 } 53 System.out.println(); 54 for (int[] a : probArray) { 55 for (int i : a) { 56 System.out.printf(&#34;%3d&#34;, i); 57 } 58 System.out.println(); 59 } 60 } 61}\r実行結果の一例が以下になります。 出力結果（一例）\r1 1 2 3 4 2 3 4 1 2 3 4 3 2 1 4 2 1 4 3 5 6 0 0 0 4 7 3 0 0 0 8 4 3 0 0 9 0 0 4 3\r完成表から10個のマスを0に変換した数表が出力されました。 ミニナンプレの問題を解くプログラム 次に、下の数表のように、ミニナンプレの空白の部分を0とした数列が与えられたとき、そこからミニナンプレを完成させるプログラムを完成させます。 11 0 0 0 1 2 3 4 23 0 1 2 → 3 4 1 2 34 3 0 1 4 3 2 1 40 0 0 0 2 1 4 3\r実際にできたコードが下になります。 CalcMiniNumberPlace.java\r1import java.util.HashSet; 2import java.util.Set; 3 4/** ミニナンプレを解くクラス */ 5public class CalcMiniNumberPlace { 6 7 /** 魔方陣の問題を格納する配列 */ 8 int[][] probArray; 9 10 /** 魔方陣の答えを格納する配列 */ 11 int[][] ansArray = new int[4][4]; 12 13 /** 重複チェック用のhashSet */ 14 Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;(); 15 16 /** 実行用mainメソッド */ 17 public static void main(String[] args) { 18 CalcMiniNumberPlace cMiniNumberPlace = new CalcMiniNumberPlace(); 19 cMiniNumberPlace.probArray = new int[][] { { 1, 0, 0, 0 }, { 3, 0, 1, 2 }, { 4, 3, 0, 1 }, { 0, 0, 0, 0 } }; 20 cMiniNumberPlace.execute(); 21 cMiniNumberPlace.showArray(); 22 } 23 24 /** ミニナンプレを解く */ 25 private void execute() { 26 for (int i = 0; i &lt; 4; i++) { 27 for (int j = 0; j &lt; 4; j++) { 28 if (probArray[i][j] != 0) { 29 ansArray[i][j] = probArray[i][j]; 30 continue; 31 } 32 } 33 } 34 int x = 1; 35 while (x != 0) { 36 x = 0; 37 for (int i = 0; i &lt; 4; i++) { 38 for (int j = 0; j &lt; 4; j++) { 39 // 縦 40 if (ansArray[i][j] == 0) { 41 ansArray[i][j] = getLastOne(ansArray[i][0], ansArray[i][1], ansArray[i][2], 42 ansArray[i][3]); 43 x++; 44 } 45 // 横 46 if (ansArray[i][j] == 0) { 47 ansArray[i][j] = getLastOne(ansArray[0][j], ansArray[1][j], ansArray[2][j], 48 ansArray[3][j]); 49 x++; 50 } 51 // 斜め 52 if (i == j &amp;&amp; ansArray[i][j] == 0) { 53 ansArray[i][j] = getLastOne(ansArray[0][0], ansArray[1][1], ansArray[2][2], 54 ansArray[3][3]); 55 x++; 56 } 57 if (i + j == 3 &amp;&amp; ansArray[i][j] == 0) { 58 ansArray[i][j] = getLastOne(ansArray[0][3], ansArray[1][2], ansArray[2][1], 59 ansArray[3][0]); 60 x++; 61 } 62 // ボックス 63 if (i &lt; 2 &amp;&amp; j &lt; 2 &amp;&amp; ansArray[i][j] == 0) { 64 ansArray[i][j] = getLastOne(ansArray[0][0], ansArray[0][1], ansArray[1][0], 65 ansArray[1][1]); 66 x++; 67 } 68 if (i &lt; 2 &amp;&amp; j &gt; 1 &amp;&amp; ansArray[i][j] == 0) { 69 ansArray[i][j] = getLastOne(ansArray[0][2], ansArray[0][3], ansArray[1][2], 70 ansArray[1][3]); 71 x++; 72 } 73 if (i &gt; 1 &amp;&amp; j &lt; 2 &amp;&amp; ansArray[i][j] == 0) { 74 ansArray[i][j] = getLastOne(ansArray[2][0], ansArray[2][1], ansArray[3][0], 75 ansArray[3][1]); 76 x++; 77 } 78 if (i &gt; 1 &amp;&amp; j &gt; 1 &amp;&amp; ansArray[i][j] == 0) { 79 ansArray[i][j] = getLastOne(ansArray[2][2], ansArray[2][3], ansArray[3][2], 80 ansArray[3][3]); 81 x++; 82 } 83 } 84 } 85 } 86 } 87 88 /** 3個の数字から残りの1つを求めるメソッド */ 89 private int getLastOne(int num1, int num2, int num3, int num4) { 90 hashSet.clear(); 91 hashSet.add(num1); 92 hashSet.add(num2); 93 hashSet.add(num3); 94 hashSet.add(num4); 95 if (hashSet.size() == 4) { 96 return 10 - num1 - num2 - num3 - num4; 97 } 98 return 0; 99 } 100 101 /** 配列を数表形式で出力する */ 102 private void showArray() { 103 for (int[] a : ansArray) { 104 for (int i : a) { 105 System.out.printf(&#34;%3d&#34;, i); 106 } 107 System.out.println(); 108 } 109 } 110 111}\r実行結果の一例が以下になります。 出力結果（一例）\r1 1 2 3 4 2 3 4 1 2 3 4 3 2 1 4 2 1 4 3\r完成された数表が出力されました。 今回はJavaでミニナンプレを作成してみました。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/java-float-double/",title:"【Java】浮動小数点数のfloat型とdouble型の違いとは?",date:"2022-03-27T00:00:00Z",body:"【Java】浮動小数点数のfloat型とdouble型の違いとは? Javaの小数を扱う変数型のfloat型とdouble型の違いについてまとめていきます。 float型とdouble型の違い どちらの型も、浮動小数点数を表します。2つの型の違いとして、値の範囲が挙げられます。 float型は32ビット単精度浮動小数点数であることに対し、double型は64ビット倍精度浮動小数点数になります。よって、double型の方がより広い範囲の数を扱うことができます。 小数を扱う場合、昔では使われるメモリの大きさが限られていた場合にfloat型が採用されることがありましたが、現在では基本的には範囲が広いdouble型を使われることが多いです。 float型の変数を宣言する時は、末尾にfかFを付けてfloat型であることを示す必要があります。 float型の変数宣言\r1float num = 1.0f;\r2つの型の範囲 2つの型の範囲をそれぞれ示します。 型 サイズ 範囲 float 32ビット（4バイト） \\(\\pm3.4028235\\times10^{38}\\) ~ \\( \\pm1.4\\times10^{-45}\\) double 64ビット（8バイト） \\(\\pm1.7976931348623157\\times10^{308}\\) ~ \\( \\pm4.9\\times10^{-324}\\) 2つの型を比べると、double型の方が取り扱う範囲が格段に広いことがわかります。 値の範囲を出力してみる 実際にそれぞれの値の範囲をサンプルコードで出力してみます。 DoubleFloatMaxMinTest.java\r1public class DoubleFloatMaxMinTest { 2 public static void main(String[] args) { 3 // double型の最大値と最小値 4 System.out.println(&#34;double型の最大値:&#34; + Double.MAX_VALUE); 5 System.out.println(&#34;double型の最小値:&#34; + Double.MIN_VALUE); 6 // float型の最大値と最小値 7 System.out.println(&#34;float型の最大値:&#34; + Float.MAX_VALUE); 8 System.out.println(&#34;float型の最小値:&#34; + Float.MIN_VALUE); 9 } 10}\r実行結果が以下になります。 出力結果\r1double型の最大値:1.7976931348623157E308 2double型の最小値:4.9E-324 3float型の最大値:3.4028235E38 4float型の最小値:1.4E-45\r先ほどの表と同じ結果が出力されました。 今回は今回はJavaの小数型の違いについてまとめました。以上で記事を終わりにします。 参考文献 Float (Java Platform SE 8 ) | Oracle Double (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/product-review-shure-aonic215/",title:"【SHURE AONIC 215】FPSで使用した感想【ゲーミングイヤホン】",date:"2022-03-09T00:00:00Z",body:"【SHURE AONIC 215】FPSで使用した感想【ゲーミングイヤホン】 ゲーミングイヤホンであるSHURE AONIC 215をゲーム（FPS）で使用した感想や、MixAmpのイコライザ設定などを紹介します。 「SHURE AONIC 215」の概要 「SHURE AONIC 215」は、いわゆる「SHURE掛け」で有名なイヤホンメーカーSHUREが出しているイヤホンのロングセラー商品となります。SHURE SE 215と同様の商品です。特徴として、イヤホン本体とケーブルが着脱式（リケーブル可能）であることが挙げられます。 今回購入した物は「SE215DYWH+UNI-A スペシャルエディション ホワイト : カナル型/マイク・リモコン付」になります。 SHURE シュア イヤホン AONIC 215 有線 マイク付き SE215DYWH&#43;UNI-A ホワイト 高遮音性 ゲーム ゲーミング スペシャルエディション カナル型 ワイヤレス変換可(別売) MMCX リケーブル プロ仕様 低音強化 配信 音楽 オーディオリスニング レコーディング 録音 楽器 在宅勤務 リモートワーク ケーブル長127 cm 【国内正規品/メーカー保証2年】\r16,836円～ amazon.co.jp 基本スペック 項目 詳細 メーカー SHURE 価格 13,000円～（変動有り） タイプ カナル型 接続端子 4極3.5mmプラグ 付属品には専用ケース、イヤーピースが数種類と、謎の棒（先端に針金みたいなものが付いている）があります。調べてみたところ、謎の棒はイヤーピースについた汚れを落とすクリーニング用の棒らしいです。 実際のプレイ環境や今まで使っていたイヤホンについて 私がプレイしている環境はPS5で、MixAmpも使用しています。少し前に書いたMixAmpの記事でも紹介しましたが、これまでは安めのイヤホンを使っていました。 関連記事\r【MixAmp】FPSでのアンプの重要性【Apexのイコライザ設定など】 このイヤホンは2000円以下の値段で、足音もしっかり聞こえてかなりコスパに優れた製品でしたね。耐久性にも優れていて、かれこれ2年くらいはつかっていました（強いて言えば装着感がちょっと微妙で耳からたまに取れるのが欠点でした）。 ここ最近「CoD:Warzone」で久しぶりにFPSに復帰して、流石に古くなったのか音質はいいのですが装着してる時にポロっと耳から外れてしまうようになり、新しく買い替えることにしました。折角なので、ちょっと高めの10,000円代くらいの製品がいいかなと思い、発売日が2011年と古いものの、評判も良さそうなSHURE AONIC 215を買いました。 実際にFPSをプレイした感想 外箱とイヤホン本体の写真です。外箱が円柱型でデカい。イヤホンの長さは1.2m程でそれほど長くないです。 「SHURE AONIC 215」の外箱 「SHURE AONIC 215」の外観 専用ケースの写真です。 「SHURE AONIC 215」の専用ケース 実際に「SHURE AONIC 215」を使用してFPSの「CoD:WARZONE」と「Apex Legends」をプレイしてみたので、使用感を書いていきます。「G30」と比較しながら感想になります。 まず、使用してみて感じた大きな違いは装着感と遮音性の高さです。イヤーピースがスポンジみたいになっており、しっかりとした装着感で外部の雑音をシャットアウトしてくれます。「SHURE掛け」も慣れれば気にならなそう。音質については、このイヤホンの周波数特性のせいか、銃声はかなり大きく聞こえるかな？といった感じです。足音の聞こえやすさはG30とそこまで大きく変わらないといった印象です。付属のマイクの性能は安物と比較してかなり良く、一緒にプレイしたフレンドからも「VCの声がクリアになった」と言われました。 しばらく使ってみました。「SHURE掛け」は最初は若干の違和感を感じましたが、しばらく使って慣れれば外れにくくていい感じです。その他で特に不調等はありません。 総合して、FPSをプレイする分には値段（13,000円）に見合った、問題無い性能（コスパ）だと思います。ロングセラー商品に見合った装着感、足音の聞こえやすさで、マイクの性能もなかなか良いです。リケーブルも可能である所もグッドですね。 FPSでイヤホン選びに困っている方は、ぜひ購入してみてはどうでしょうか。入門としては損はしない商品だと思います。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/java-identity-equivalence/",title:"【Java】変数における同一性と同値性の違いを解説",date:"2022-02-25T00:00:00Z",body:"【Java】変数における同一性と同値性の違いを解説 Javaの変数における同一性と同値性の違いについて、分かりやすくまとめてみたいと思います。 同一性とは 変数の同一性とは、その変数が同じインスタンスであることを指します。インスタンスを分かりやすく説明するのは難しいですが、クラスを設計図とするならば、インスタンスとはそれぞれ個性を持つ実体の様なものです。クラスのインスタンスを生成するというのは、言い換えれば設計図から実体を作るという意味合いを持ちます。 例えば、下のような変数str1、str2がある時、2つの変数は同じインスタンスを共有して参照しています。 変数の同一性\r1String str1 = &#34;ABC&#34;; 2String str2 = str1;\rつまり、この2つの変数は同一であると言えます。 付け加えると、Stringクラスは同じ文字列が代入された場合、同じ参照先が使い回されます。これは参照先が増えるのを防ぐためで、この仕組みをコンスタントプール（Constant Pool）と呼ばれています。 コンスタントプールにより下のような変数str3、str4は同じ参照先を参照しているので同一性を持ちます。 変数の同一性\r1String str3 = &#34;abc&#34;; 2String str4 = &#34;abc&#34;;\r同一性であるかを判定するのには、==演算子を使います。サンプルコードに同一性を判定するコードを書いてみます。 IdentityTest.java\r1public class IdentityTest { 2 public static void main(String[] args) { 3 // str1とstr2が同一であるか判定する 4 String str1 = &#34;ABC&#34;; 5 String str2 = str1; 6 System.out.println(&#34;str1とstr2の同一性:&#34; + (str1 == str2)); 7 // str3とstr4が同一であるか判定する 8 String str3 = &#34;abc&#34;; 9 String str4 = &#34;abc&#34;; 10 System.out.println(&#34;str3とstr4の同一性:&#34; + (str3 == str4)); 11 } 12}\r実行結果が以下になります。 出力結果\r1str1とstr2の同一性:true 2str3とstr4の同一性:true\rstr1とstr2、str3とstr4は同一であることがわかります。 同値性とは 同値性とは、インスタンスが持つ値の内容が同じであることを意味します。 変数の同値性\r1String str1 = new String(&#34;ABC&#34;); 2String str2 = new String(&#34;ABC&#34;);\r上のstr1とstr2はnew演算子で異なるインスタンスを生成して、「ABC」を代入しています。値自体はそれぞれ同じ文字列を代入しています。 よって、2つの変数は同一ではないが同値であると言えます。 同値性を判定するには、Objectクラスのequalsメソッドを使います。サンプルコードに同値性を判定するコードを書いてみます。 EquivalenceTest.java\r1public class EquivalenceTest { 2 public static void main(String[] args) { 3 String str1 = new String(&#34;ABC&#34;); 4 String str2 = new String(&#34;ABC&#34;); 5 // str1とstr2が同一であるか判定する 6 System.out.println(&#34;str1とstr2の同一性:&#34; + (str1 == str2)); 7 // str1とstr2が同値であるか判定する 8 System.out.println(&#34;str1とstr2の同値性:&#34; + str1.equals(str2)); 9 } 10}\r実行結果が以下になります。 出力結果\r1str1とstr2の同一性:false 2str1とstr2の同値性:true\r上の通り、同一性判定はfalseですが、同値性判定はtrueであることが分かります。 同一性と同値性の違い 上で述べた同一性と同値性の違いについてですが、これらは変数の型が基本データ型ではなく、参照型の場合のみ発生します。 基本データ型は同一性のみ比較される（同一性と同値性が一緒に扱われる）ので、基本データ型で同値性と同値性は違いは発生しません。 変数を比較する場合では、基本データ型では==演算子、参照型ではequalsメソッドを使えば良いということです。 今回は同一性と同値性の違いを簡単にまとめました。Java Silverの試験でも問われることが多いトピックなので、アウトプットとして解説してみました。以上で記事を終わりにします。 参考文献 Object (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/java-fizzbuzz/",title:"【Java】FizzBuzzを色々な方法で書いてみる",date:"2022-01-27T00:00:00Z",body:"【Java】FizzBuzzを色々な方法で書いてみる Javaでプログラムのアルゴリズム問題で有名なFizzBuzzを書いてみます。ノーマルな実装方法と、応用として拡張性を意識した実装方法を紹介します。 FizzBuzzとは FizzBuzzプログラムは、プログラミングを始めたばかりの人に出されることが多いアルゴリズムの問題です。初級者にとってはアルゴリズムの登竜門ですね。 私も、大学の頃C言語の授業で出された記憶があります。プログラミングを勉強している人は知っている人が多いのではないでしょうか。 FizzBuzzのルール\r1から100までの数字を画面に表示する 3の倍数のときは数字の代わりに「Fizz」と表示する 5の倍数のときは数字の代わりに「Buzz」と表示する 15の倍数のときは数字の代わりに「FizzBuzz」と表示する 今回は100まで表示させると出力結果が長くなってしまうので、20まで出力させてみます。 ノーマルな解答例 色々と解答方法があるかと思いますが、一番ノーマルな書き方で実装してみます。 FizzBuzzTest1.java\r1public class FizzBuzzTest1 { 2 public static void main(String[] args) { 3 for (int num = 1; num &lt;= 20; num++) { 4 // 15で割り切れる時FizzBuzzと出力する 5 if (num % 15 == 0) { 6 System.out.println(&#34;FizzBuzz&#34;); 7 } 8 // 3で割り切れる時Fizzと出力する 9 else if (num % 3 == 0) { 10 System.out.println(&#34;Fizz&#34;); 11 } 12 // 5で割り切れる時Buzzと出力する 13 else if (num % 5 == 0) { 14 System.out.println(&#34;Buzz&#34;); 15 } 16 // それ以外はそのまま出力する 17 else { 18 System.out.println(num); 19 } 20 } 21 } 22}\r実行結果が以下になります。 出力結果\r11 22 3Fizz 44 5Buzz 6Fizz 77 88 9Fizz 10Buzz 1111 12Fizz 1313 1414 15FizzBuzz 1616 1717 18Fizz 1919 20Buzz\rこのアルゴリズムではif文と%演算子を使って倍数の判定ができるかがポイントになります。その他、注意する点として倍数の判定の順番があります。最初に15の倍数判定をしないと、3もしくは5の倍数判定に通ってしまうため、ルールを満たさない結果が返ってきます。 拡張性を考えて実装してみる 上記の解答例だとノーマル過ぎて味気がありませんので、応用例としてルールの追加・変更に強いような実装方法を考えてみましょう。 例えば、条件を追加したり異なる条件にしたい時、上のコードではif文を適宜書き換えていけば実現できますが、いちいちif文の条件式を追加変更するのは少し面倒です。 コードの書き換えが簡単になるような実装にしてみます。 FizzBuzzTest2.java\r1import java.util.Collections; 2import java.util.Map; 3import java.util.TreeMap; 4 5public class FizzBuzzTest2 { 6 public static void main(String[] args) { 7 // 条件（倍数と文字列）の指定 8 Map&lt;Integer, String&gt; fizzbuzzMap = new TreeMap&lt;&gt;(Collections.reverseOrder()); 9 fizzbuzzMap.put(3, &#34;fizz&#34;); 10 fizzbuzzMap.put(5, &#34;buzz&#34;); 11 fizzbuzzMap.put(15, &#34;buzzfizz&#34;); 12 // 表示を行う 13 for (int num = 1; num &lt;= 20; num++) { 14 System.out.println(getString(num, fizzbuzzMap)); 15 } 16 } 17 18 // 倍数判定を行うメソッド 19 private static String getString(int num, Map&lt;Integer, String&gt; fizzbuzzMap) { 20 String str = String.valueOf(num); 21 for (int key : fizzbuzzMap.keySet()) { 22 if (num % key == 0) { 23 return fizzbuzzMap.get(key); 24 } 25 } 26 return str; 27 } 28}\r実行結果が以下になります。 出力結果\r11 22 3Fizz 44 5Buzz 6Fizz 77 88 9Fizz 10Buzz 1111 12Fizz 1313 1414 15FizzBuzz 1616 1717 18Fizz 1919 20Buzz\rこのコードではgetStringメソッドで倍数判定を行い、引数のTreeMapに倍数と表示したい文字列を格納しています。Collections.reverseOrder()を指定することで、TreeMapを自動でキーの降順に並び替えられます。ここでキーの降順に並び替えているのは、数字の大きい順に倍数判定を行わないと正しい判定がされないからです（15の判定時に3の倍数判定がされて「Fizz」が戻ってくるなど）。 条件を変えたい時はputメソッドの所を好きな物に書き換えるだけで良いので、最初のコードよりかはルール変更に強い実装にすることができました。 色々と実装方法はありますので、皆さんも気軽に挑戦してみましょう。以上で記事を終わりにします。 参考文献 TreeMap (Java Platform SE 8 ) | Oracle Collections (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/java-isdigit-method/",title:"【Java】isDigitメソッドで文字が数字かどうか判定する",date:"2021-12-15T00:00:00Z",body:"【Java】isDigitメソッドで文字が数字かどうか判定する JavaのCharacterクラスのisDigitメソッドを使って文字が数字かどうかを判定する方法とString型の文字列から全ての数字を抽出する方法についてまとめます。 isDigitメソッドの書式 isDigitメソッドは、以下の様に記述します。 isDigitメソッドの書式例\r1Character.isDigit(char ch);\r引数の文字を比較して数字（0~9のみで構成される）であればture、そうでなければfalseを返します。戻り値の型はboolean型です。 引数はchar型（もしくはint型）のみ適用され、String型やNULLを入れるとコンパイルエラーになります。 似たようなメソッドで、小文字のアルファベットかどうか判定するisLowerCaseメソッドがあります。 関連記事\r【Java】isLowerCaseメソッドで小文字かどうか判定する メソッドの使用例 isDigitメソッドの使用例をサンプルコードで紹介します。 IsDigitTest1.java\r1public class IsDigitTest1 { 2 public static void main(String[] args) { 3 4 // 0,Aがそれぞれ数字かどうか判定する 5 System.out.println(&#34;0の数値判定:&#34; + Character.isDigit(&#39;0&#39;)); 6 System.out.println(&#34;Aの数値判定:&#34; + Character.isDigit(&#39;A&#39;)); 7 8 // 全角数字とひらがなと空文字を判定する 9 System.out.println(&#34;０の数値判定:&#34; + Character.isDigit(&#39;０&#39;)); 10 System.out.println(&#34;あの数値判定:&#34; + Character.isDigit(&#39;あ&#39;)); 11 System.out.println(&#34; の数値判定:&#34; + Character.isDigit(&#39; &#39;)); 12 System.out.println(&#34;,の数値判定:&#34; + Character.isDigit(&#39;,&#39;)); 13 } 14}\r実行結果が以下になります。 出力結果\r10の数値判定:true 2Aの数値判定:false 3０の数値判定:true 4あの数値判定:false 5 の数値判定:false 6,の数値判定:false\r半角英数字の判定だけではなく、全角の数字や平仮名や空白文字に対しても数字かどうか判定されます。 文字列から全ての数字を検索する方法 通常はchar型の文字だけしか検索できないので、for文を使ってString型の文字列から含まれる全ての数字を検索するプログラムを作成してみます。 サンプルコードを以下に示します。String型をchar型に分割するために、toCharArrayメソッドを使用しています。 関連記事\r【Java】toCharArrayメソッドで文字列を配列に分割する IsDigitTest2.java\r1public class IsDigitTest2 { 2 public static void main(String[] args) { 3 String str = &#34;abc123def&#34;; 4 char[] c = str.toCharArray(); 5 int sum = 0; 6 System.out.println(&#34;元の文字列:&#34; + str); 7 8 for (int i = 0; i &lt; str.length(); i++) { 9 if (Character.isDigit(c[i])) { 10 System.out.println(&#34;数字:&#34; + c[i] + &#34; 場所:&#34; + (i + 1)); 11 sum++; 12 } 13 } 14 System.out.println(&#34;該当個数:&#34; + sum); 15 } 16}\r実行結果が以下になります。 出力結果\r1元の文字列:abc123def 2数字:1 場所:4 3数字:2 場所:5 4数字:3 場所:6 5該当個数:3\r文字列から全ての数字を抽出することができました。ただ、文字列を1文字ずつに分割しているため、123は1・2・3として出力されてしまいます。 今回はisDigitメソッドの使い方を紹介しました。以上で記事を終わりにします。 参考文献 Character (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/java-tochararray/",title:"【Java】toCharArrayメソッドで文字列を配列に分割する",date:"2021-11-13T00:00:00Z",body:"【Java】toCharArrayメソッドで文字列を配列に分割する JavaのtoCharArrayメソッドを使って、String型の文字列をChar型の配列に変換する方法についてまとめていきます。 toCharArrayメソッドの書式 toCharArrayメソッドは以下のように記述します。 toCharArrayメソッドの書式例\r1String str = &#34;hello&#34;; 2char[] cArray; 3cArray = str.toCharArray();\r変数strの文字列が1文字ずつ分割され、配列cArrayに代入されます。 toCharArrayメソッドの使用例 メソッドの使用例をサンプルコードで示します。 ToCharArrayTest.java\r1public class ToCharArrayTest { 2 public static void main(String[] args) { 3 String str1 = &#34;hello&#34;; 4 char[] cArray; 5 cArray = str1.toCharArray(); 6 for (char c : cArray) { 7 System.out.print(c); 8 } 9 System.out.println(); 10 11 String str2 = &#34;あいうえおかきくけこ&#34;; 12 cArray = str2.toCharArray(); 13 for (char c : cArray) { 14 System.out.print(c); 15 } 16 System.out.println(); 17 } 18}\r実行結果が以下になります。 出力結果\r1hello 2あいうえおかきくけこ\r変数cArrayにhelloとあいうえおかきくけこが1文字ずつ分割され、順番に格納されていることが分かります。アルファベットでも日本語でも同様の処理を実行します。 今回はJavaのtoCharArrayメソッドについて紹介しました。以上で記事を終わりにします。 参考文献 String (Java Platform SE 8 )"},{url:"/dimzakki-mainroad/qualification-javasilverse11/",title:"【Java Silver】合格体験記【約100時間で合格した勉強方法】",date:"2021-11-03T00:00:00Z",body:"【Java Silver】合格体験記【約100時間で合格した勉強方法】 Oracle Certified Java Programmer Silver SE 11 認定資格（Java Silver）を2021年10月に受け合格しましたので、試験の対策・結果・感想などをまとめます。 関連記事\r【ORACLE MASTER】試験の申し込みを格安で行う方法【OCJ-P】 【Java Silver SE11】試験対策用備忘録メモ【黒本ベース】 試験概要 まず、試験について軽く紹介します。 Java Silver試験はOracle社が提供しているベンダー資格「Oracle Certified Java Programmer」の1つであり、3段階のレベル（Bronze・Silver・Gold）の真ん中の難易度の試験になっています。 項目 詳細 出題形式 選択問題・CBT方式 出題数 80問 試験時間 180分 合格点 正答率63％以上 受験料 税込37,730円（2024/08/23時点）\r試験では言語の仕様を細かく理解しているかどうかが問われるため、実際に簡単なコードを書くことができる程度の知識が求められます。ちなみに、合格率は公表されていません。 なお、Silverでは受験資格は無く、事前にBronzeを合格する必要は無いので、いきなりSilverを受けても大丈夫です。 また、試験にはバージョンがあり、今回受験したバージョンは「SE11」で、試験番号は「1Z0-815」になります。 ベンダー資格特有ですが、受験料は35,000円以上と結構高いです。 受験のきっかけと申し込み まず私のプロフィールを簡単に紹介します。 プロフィール\r開発系のITエンジニア（1年目） JavaはITエンジニアになってから勉強を始めた 別言語だがプログラミング経験は有り 受験を決めたのは2021年8月くらいでした。何故、受験するかに至ったかというと、入社した会社で受験が奨励されていたからです。 内心「難しそうだし、受験料も高いな…」と思っていましたが、同期が皆受ける感じだったので、半ば仕方なくといった感じでした。 その上、面倒だったのが試験の申し込みが複雑で分かりづらかったことです。受験料支払いは、楽天でチケットを買って申し込みしました。これは試験代金が浮くので、結構ありがたかったです。 【ピアソンVUE専用】OracleピアソンVUE配信監督付き試験用受験チケット(電子チケット)\r38,995円～ rakuten.co.jp 試験の申し込みについてはこちらの記事にまとめてあります。 関連記事\r【ORACLE MASTER】試験の申し込みを格安で行う方法【OCJ-P】 試験勉強でやったこと 元々は9月末に受験する予定でしたが、勉強が思うように進まなかったので、1ヶ月延期し、10月末に受験しました。試験勉強は参考書メインでした。 この後に詳しく書きますが「黒本」と言われる参考書を購入し、コツコツ3周程やりました。総勉強時間は計100時間前後と言ったとこでしょうか。 当時は研修でテレワークだったこともあり、ダラダラとやっていたので、100時間フルに勉強したかと言うとそうでもなく、実質は時間に見合わない勉強量だったかもしれません。 参考までに、私が分かりにくかった所を備忘録としてまとめました。 関連記事\r【Java Silver SE11】試験対策用備忘録メモ【黒本ベース】 試験本番 試験は10月末の土曜日の午前に受けました。地元では試験を開催してなかったので、都内の少し遠いテストセンターに予約をしました。初めて行く場所だったのでちょっと迷いましたが、なんとか遅刻せずに到着。身分証明書が2点必要なので気を付けましょう。 試験前にスコアレポートに載せる顔写真を撮影してもらいます。受付の人も丁寧に案内してくれました。私のコンディションの方はというと、正直対策がおろそかで、体調も本調子ではなかったです。当日の行きの電車では1時間程度、黒本の6章と7章を復習していました。 更に、試験が始まって1時間くらいして、お腹が猛烈に痛くなってしまいました…。流石に我慢できないくらい痛かったので途中退出してトイレに行きました。試験問題も良く分からない微妙な問題が多く出てきて「落ちたかも…」と不合格が頭をよぎりました。 幸い黒本で知っている問題はいくつか出てたので、分かるものはちゃんと答えてそれ以外の微妙なものはなんとなくで解答しました。受かってるか全く分からない手応えで、試験終了時はお祈りしながら終了ボタンを押しました。 試験結果 試験結果（スコアレポート）は試験終了時にPCの画面に出ます。またCertViewのサイトにログインすると同じ物を見ることができます。実際のスコアレポートを下に載せておきます。 Java Silverの試験結果 正解率65%で合格でした。試験の合格点が63%なので、かなりギリギリでした…。コンディションが万全で無かったのもそうですが、油断せずにもうちょっと集中して勉強しておけば良かったなって感じです。 試験の難易度と対策について 試験の難易度についてですが、完全未経験の場合だと結構しんどいと感じました。試験内容が言語の細かい仕様が問われ、意地悪な問題も多かったと思います。ある程度経験がある人ならそれ程大変ではないかと思います。 次に試験対策についてです。他サイトでも同様のことが言われていますが、Java Silver合格には参考書で問題を解いていくことが一番だと思います。有名どころな参考書は3冊（黒本・紫本・白本）があります。 この中で一番おすすめな参考書は黒本（表紙の色が黒いので黒本）と言われる「徹底攻略Java SE 11 Silver問題集[1Z0-815]対応」です。どれか一冊のみ使うつもりなら黒本を選択しましょう。 徹底攻略Java SE 11 Silver問題集[1Z0-815]対応\r3,740円～ amazon.co.jp 黒本は試験問題に近い形式の問題とその解説をテーマごとにまとめた問題集になっています。試験本番でも黒本で解いた問題が出題されていたので、黒本をやり込むことが合格への近道でしょう。 黒本に対して紫本は教科書的な内容になっており、プログラミング経験が無いJava初心者向けの参考書と言えます。白本は黒本と同じく問題集です。「一問一答形式」となっており解説も図解で分かりやすい参考書ですが、問題の難易度がやや低めでありネットでも黒本の方が評判が良いので、まず黒本を優先したいです。黒本の問題が分かりにくいという方は、先に白本から買ってもいいかもです。 黒本の使い方としては、基本的にはどんどん問題を解いていきましょう。Java Silverは言語の細かい部分を聞いてくるので、解くには知識が必要です。各章を周回して苦手なところを克服し、最後に総仕上げ問題を解きましょう。総仕上げ問題は試験と同じ80問になっているため、本番と同じ3時間で解き時間配分を意識しておくと良いです（実際に3時間フルで掛かることはないかと思いますが）。 私も、最初は各章ごとで半分も解けませんでした。1日に1章くらいのペースで3周くらいやり続け、間違えた問題の解説をしっかり読んで3周くらいすれば解けるようになったので、繰り返しが大切です。 今回はJava Silverの合格体験記をまとめました。Java自体、触れるようになったのは7月からだったので、Javaを勉強し始めてから約4ヶ月で合格ということになりますね。 私は試験直前の勉強時間が少なく、勉強が足りなかった感がありますが、しっかり黒本の内容を理解していれば合格することは難しくないでしょう。 振り返って見ると、Javaの勉強になったのは紛れもない事実だし、受験して良かったと思います。取るように言ってくれた会社にも感謝しています。 その後、Java Goldまで取得することができました。 関連記事\r【Java Gold】合格体験記【約3か月で合格した勉強方法】 試験を受ける方の参考になれば幸いです。以上で記事を終わりにします。 参考文献 Java SE 11 Programmer I (1Z0-815-JPN) 試験 | Oracle University"},{url:"/dimzakki-mainroad/javasilver-se11-application/",title:"【ORACLE MASTER】試験の申し込みを格安で行う方法【OCJ-P】",date:"2021-10-28T00:00:00Z",body:"【ORACLE MASTER】試験の申し込みを格安で行う方法【OCJ-P】 IT資格のORACLE MASTERとJava資格（OCJ-P）の試験を割引価格で申し込む方法と、試験結果を確認する方法についてまとめます。 なお、受験形式はテストセンターでCBT方式での受験を想定しています。 必要なアカウント（Oracle・ピアソンVUE）の登録方法 試験の申し込みと結果の確認をするにはOracleアカウントとピアソンVUEアカウントの2つのアカウントに登録する必要があります。登録方法については別の記事で紹介しています。 関連記事\r【IT資格】OracleアカウントとCertViewアカウントの登録方法 割引価格でチケットの購入をする方法 試験のチケットはOracleの公式ページからでも購入できますが、楽天で受験チケットを買うと、2,000円以上安く受験することができます。また、楽天ポイントもついてくるため更にお得です。 チケットは下記URLから購入できます。 【ピアソンVUE専用】OracleピアソンVUE配信監督付き試験用受験チケット(電子チケット) 【ピアソンVUE専用】OracleピアソンVUE配信監督付き試験用受験チケット(電子チケット)\r38,995円～ rakuten.co.jp 主な対応試験 試験番号 試験名 1Z0-085-JPN ORACLE MASTER Bronze DBA 1Z0-071-JPN ORACLE MASTER Silver SQL 1Z0-082-JPN ORACLE MASTER Silver DBA 1Z0-083-JPN ORACLE MASTER Gold DBA 1Z0-815-JPN Java Silver SE11 1Z0-816-JPN Java Gold SE11 Java Bronzeの場合 なお、Java Bronze（1Z0-818-JPN）については受験料が上記の試験と異なるので、以下のチケットが対象になります。 【ピアソンVUE専用】OracleピアソンVUE配信監督なし試験用受験チケット(電子チケット) 【ピアソンVUE専用】OracleピアソンVUE配信監督なし試験用受験チケット(電子チケット)\r15,103円～ rakuten.co.jp 主な対応試験 試験番号 試験名 1Z0-818-JPN Java Bronze 試験の予約を行う方法 今回は、「Java Silver SE11」の申し込みを例として行ってみます。試験名は「1Z0-815-JPN: Java SE 11 Programmer I」になります。 チケットを購入するとチケット番号が記載されたメールが来るので、その番号を使って試験の予約を行います。私は購入後、1時間ほどでメールが届きました。 チケット番号が記載されたメール 次に試験の予約を行います。下記URLから予約を行いましょう。 Oracle University | CertView 「Login to CertView」をクリックし、先程作ったOracleアカウントでサインインしましょう。 試験の予約方法1 右側のメニューの「Language」から日本語に切り替えることができます。 試験の予約方法2 メニューから「ピアソンVUEサイト」をクリックすると、試験の予約サイトである「ピアソンVUE」へ遷移します。 試験の予約方法3 こちらも、左側のメニューの「Language」から日本語に切り替えることができます。 試験の予約方法4 「試験の表示」から試験を検索します。 試験の予約方法5 「テストセンター」を選択すると、認定プログラムのポリシーの画面になります。「同意する」をクリックしましょう。試験会場の選択画面になります。 試験の予約方法6 会場と日時を選択すると受験コードの入力画面になります。ここに先ほどのコード（メールに記載されているチケット番号）を入力しましょう。 試験の予約方法7 コードを入力後代金の合計が0円になり、このような画面になるのを確認したら「次へ」をクリックします。 試験の予約方法8 最終確認画面になるので予約内容に間違いがないか確認して「予約内容の確定」をクリックします。これで試験の予約が完了しました。予約内容のメールが送られてきます。 試験結果の確認方法 試験終了時には画面に結果（スコアレポート）が表示されます。また、試験終了後にスコアレポートが欲しい場合はWebで入手することができます。試験後にWebでスコアレポートを見るには「CertView」のサイトからアクセスすることができます。 CertViewのメニューから「試験結果」の下にある「ピアソンVUEの試験結果」をクリックするとスコアレポートを見ることができます。過去に受けた試験についても閲覧可能です。 合格証明書の確認方法 また、会社から奨励金等を受け取るには合格証明書が必要になるかと思います。試験の合格証明書も「CertView」のサイトから入力することができます。 CertViewのメニューから「資格情報」をクリックして合格証明書をダウンロードすることができます。こちらも過去に受けた試験についても閲覧可能です。 合格証明書に関しては、試験を受けてからすぐアクセスできないこともあり、一日程度時間が掛かる場合があります。 今回はOracleマスター・Javaの資格試験の受験料を、割安価格で申し込む方法を紹介しました。受験予定の方はぜひ利用してみて下さい。以上で記事を終わりにします。 参考文献 試験申し込みと受験 | オラクル認定資格制度"},{url:"/dimzakki-mainroad/java-method-function/",title:"【Java】メソッドと関数の違いについて考えてみる【C言語】",date:"2021-10-19T00:00:00Z",body:"【Java】メソッドと関数の違いについて考えてみる【C言語】 プログラミングにおけるメソッドと関数との違いについて、JavaとC言語を例にして考えたいと思います。 例えば、C言語では特定の処理のことを関数と呼びますが、Javaではメソッドと言われていますね。関数、メソッドとは一体何なのか考えてみます。 メソッドとは メソッド（method）とは何なのでしょうか？意味を調べてみます。 メソッドとは、オブジェクト指向プログラミングにおける、特定のクラスやオブジェクトに属する、特定の処理をひとまとまりにしたサブルーチンのことである。「method」という単語は、一般的な英単語としては「手段」「方法」などを意味する。 特に、Javaのように、全てのサブルーチンが何らかのクラスに属するプログラミング言語でメソッドという言葉が使われる。1 Javaには様々なメソッドが用意されています。具体的な例を挙げると、System.out.println(&quot;hello java&quot;);のようなSysout文はメソッドになります。 また、メソッドを新しく作りたい時は以下のように記述します。Javaのmainメソッドもその名の通りメソッドの一部になります。 メソッド\r1アクセス修飾子 戻り値の型 メソッド名(引数の型 引数) { 2　// 処理 3} 4 5public static void main(String[] args) { 6　// 処理 7}\r関数とは 関数（function）とは数学でよく使われる単語ですよね。メソッドとは何が違うのでしょうか？意味を調べてみます。 関数とは、入力された値に対してある決まった内容の計算を行い、入力された値に応じた処理結果を返す、数式、あるいは命令の集まりのことである。 プログラミング言語などにおいては、使用頻度の高い処理手続きは関数としてあらかじめ用意されていることが多い。関数に入力する値は「引数」と呼ばれる。引数は、関数の種類によっては数値でなく文字列などが使用される場合もある。2 試しにJavaで例を挙げてみます。 FunctionTest.java\r1public class FunctionTest { 2 public static void main(String[] args) { 3 int i = square(5); 4 System.out.println(i); 5 } 6 7 public static int square(int num) { 8 return num * num; 9 } 10}\r上のコードの出力結果は25になります。 ここで関数はsquareですね。引数に5が渡されて2乗される処理が行われ、その結果である25が返されています。 しかし上にもある通り、squareメソッドを新しく定義して記述しているため、これはメソッドとも言えます。 結局メソッドと関数は同じ？ メソッドとは上の引用にもある通りオブジェクト指向型言語において、オブジェクトの一部として定義されている関数のことであるということです。 Javaはオブジェクト指向型言語であるため、関数という呼び名の代わりにメソッドの呼び名が使われています。つまり、メソッドと関数は同じものとして扱われるということです。 ここまで、メソッドと関数の違いについてまとめてみました。以上で記事を終わりにします。 IT用語辞典バイナリ:メソッド&#160;&#x21a9;&#xfe0e; IT用語辞典バイナリ:関数&#160;&#x21a9;&#xfe0e;"},{url:"/dimzakki-mainroad/java-sudoku-1/",title:"【Java】数独に使われる魔方陣を出力する",date:"2021-10-06T00:00:00Z",body:"【Java】数独に使われる魔方陣を出力する Javaで数独に使われる9×9の魔方陣をランダムに出力するプログラムを作成してみます。 関連記事\r【Java】ランダムな4×4の魔方陣を出力する 数独魔方陣の特徴 作成する数独の9×9の魔方陣の特徴についてまとめます。 数独の魔方陣の特徴\r縦と横の全ての列で1~9の数字が1つずつ使われる 3×3のブロックに1~9の数字が1つずつ使われる 数独の魔方陣はこんな感じの数表です。 $$ \\large\\begin{array}{|c|c|c|c|c|c|c|c|c|} \\hline 7 &amp; 2 &amp; 9 &amp; 3 &amp; 6 &amp; 4 &amp; 1 &amp; 5 &amp; 8 \\\\ \\hline 6 &amp; 1 &amp; 5 &amp; 9 &amp; 2 &amp; 8 &amp; 3 &amp; 7 &amp; 4 \\\\ \\hline 3 &amp; 4 &amp; 8 &amp; 7 &amp; 1 &amp; 5 &amp; 6 &amp; 2 &amp; 9 \\\\ \\hline 4 &amp; 9 &amp; 3 &amp; 2 &amp; 8 &amp; 1 &amp; 7 &amp; 6 &amp; 5 \\\\ \\hline 8 &amp; 6 &amp; 1 &amp; 5 &amp; 9 &amp; 7 &amp; 4 &amp; 3 &amp; 2 \\\\ \\hline 2 &amp; 5 &amp; 7 &amp; 4 &amp; 3 &amp; 6 &amp; 9 &amp; 8 &amp; 1 \\\\ \\hline 1 &amp; 7 &amp; 2 &amp; 8 &amp; 4 &amp; 3 &amp; 5 &amp; 9 &amp; 6 \\\\ \\hline 9 &amp; 3 &amp; 6 &amp; 1 &amp; 5 &amp; 2 &amp; 8 &amp; 4 &amp; 7 \\\\ \\hline 5 &amp; 8 &amp; 4 &amp; 6 &amp; 7 &amp; 9 &amp; 2 &amp; 1 &amp; 3 \\\\ \\hline \\end{array} $$ プログラミングで作ってみる 上の画像のような数表をランダムで出力するプログラムを作成します。 基本的な作り方のアルゴリズムは以下の通りです。重複のチェックはHashSetを使いました。 アルゴリズム\r出来上がった数表を格納する配列arrayを宣言する 1~9の数字が入ったArrayListを作りシャッフルし、arrayに格納する（これが横の行の1つになる） 縦の列に重複しないようにArrayListをarrayに格納していく　重複したら格納せずもう一度シャッフルしていくを繰り返す 同時に3×3のブロックも重複がないかチェックする　重複したらその都度やり直す サンプルコードを以下に示します。 MakeSudoku.java\r1import java.util.ArrayList; 2import java.util.Collections; 3import java.util.HashSet; 4import java.util.List; 5import java.util.Set; 6 7public class MakeSudoku { 8 /** 数独の数字を格納する配列 */ 9 int[][] array = new int[9][9]; 10 11 /** 1から9までを格納するArrayList */ 12 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 13 14 /** 重複チェック用のhashSet1 */ 15 Set&lt;Integer&gt; hashSet1 = new HashSet&lt;&gt;(); 16 17 /** 重複チェック用のhashSet2 */ 18 Set&lt;Integer&gt; hashSet2 = new HashSet&lt;&gt;(); 19 20 /** 実行用mainメソッド */ 21 public static void main(String[] args) { 22 MakeSudoku makeSudoku = new MakeSudoku(); 23 makeSudoku.execute(); 24 makeSudoku.showArray(); 25 } 26 27 /** 数独の作成 */ 28 private void execute() { 29 for (int i = 1; i &lt;= 9; i++) { 30 list.add(i); 31 } 32 Collections.shuffle(list); 33 34 for (int i = 0, j; i &lt;= 8;) { 35 int u = 2, v = 2; 36 if (i == 5) { 37 u = 5; 38 } 39 40 for (j = 0; j &lt;= 8;) { 41 array[i][j] = list.get(j); 42 for (int x = 0; x &lt; i; x++) { 43 hashSet1.add(array[x][j]); 44 } 45 if (hashSet1.contains(array[i][j])) { 46 hashSet1.clear(); 47 break; 48 } 49 if (i == u &amp;&amp; j == v) { 50 hashSet2.add(array[u - 2][v - 2]); 51 hashSet2.add(array[u - 2][v - 1]); 52 hashSet2.add(array[u - 2][v]); 53 hashSet2.add(array[u - 1][v - 2]); 54 hashSet2.add(array[u - 1][v - 1]); 55 hashSet2.add(array[u - 1][v]); 56 hashSet2.add(array[u][v - 2]); 57 hashSet2.add(array[u][v - 1]); 58 hashSet2.add(array[u][v]); 59 if (hashSet2.size() != 9) { 60 hashSet2.clear(); 61 i -= 2; 62 j = 0; 63 break; 64 } 65 v = 5; 66 67 } 68 j++; 69 70 hashSet1.clear(); 71 hashSet2.clear(); 72 } 73 if (j == 9) { 74 i++; 75 } 76 77 Collections.shuffle(list); 78 } 79 } 80 81 /** 配列を数表形式で出力する */ 82 private void showArray() { 83 for (int[] a : array) { 84 for (int i : a) { 85 System.out.printf(&#34;%3d&#34;, i); 86 } 87 System.out.println(); 88 } 89 } 90}\r実行結果の一例が以下になります。 出力結果（一例）\r1 7 3 2 1 4 9 5 6 8 2 5 1 6 3 8 2 9 7 4 3 8 4 9 7 6 5 3 2 1 4 4 2 5 6 9 8 1 3 7 5 6 9 3 4 1 7 8 5 2 6 1 7 8 5 2 3 4 9 6 7 2 8 7 9 5 4 6 1 3 8 9 6 4 2 3 1 7 8 5 9 3 5 1 8 7 6 2 4 9\r条件を満たす数表が出力されました。条件を満たすまでシャッフルを繰り返すので、出力されるまでちょっと時間がかかります。 今回は数独の数表を作るところまで完成しました。 完全にランダムで条件を満たすか当てはめていってるので、処理に時間がかかっているところが問題点ですね。その部分を処理を減らすことも考えていきたいです。 この記事では時間がなくてできませんでしたが、数独の問題を作る機能も実装したいと思います。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/qualification-ip-merit/",title:"【ITパスポート試験】iパスのメリットって？【受験料が高い？】",date:"2021-09-25T00:00:00Z",body:"【ITパスポート試験】iパスのメリットって？【受験料が高い？】 ITパスポート試験（iパス）の受験料が2022年4月の試験から7,500円に値上がりした件について、試験を受けるメリットはなにか考えてみました。 関連記事\r【ITパスポート試験】合格体験記【約2週間で合格】 【基本情報技術者試験】合格体験記【約50時間で合格】 受験料が値上がりした理由 iパスだけではなく、情報処理技術者試験の12種及び情報処理安全確保支援士試験の受験料が一律で5,700円から7,500円に引き上げられました。7,500円って結構大きな額ですよね。5,700円と比べて一気に高額になったような気がします。 受験料が値上がりした理由は、情報処理推進機構（IPA）によると以下の理由だそうです。 近年の試験問題の印刷・運搬費用、会場借料等の値上がりや、新型コロナウイルス感染症対策として求められる、試験会場における座席間隔の確保や検温・消毒等の実施、一部試験区分のコンピュータ試験化などを行う中で、試験実施に要する実費が増加し、現行の受験手数料との乖離が生じていました。こうした状況を踏まえ、今後も安定的に試験制度を運営する観点から受験手数料の額が見直され、「情報処理の促進に関する法律施行令の一部を改正する政令（令和3年7月16日閣議決定）」により、「7,500 円」に改定されました。1 要約すると新型コロナの対応・CBT方式の費用の増加が値上がりの理由みたいです。まあ、理由としては分からなくもないですね。 iパスのメリットを考える では、具体的な「iパスを取得するメリット」ってなんでしょう？ 少なくとも、IT業界においてはiパスの効力はほとんど無いと言っていいと思います。なぜなら初級資格のため、IT業界においての専門性・希少性が低いからです。iパスを持っていても業界での就活・転職活動で評価されることはほぼありません。 私は開発系のITエンジニアとして働いていますが、iパスの話題に遭遇したことは一度もありませんでしたし、資格自体は業務に影響与えることはありませんでした。 しかし、iパスを取得する意味が全くないとは言えないです。一番ありがちなのが、報奨金や資格手当を会社が出してくれるパターンです。これは手放しで取得する理由になりますね。 それ以外にiパスを取る意義を挙げるとするならば、基本情報・情報セキュリティマネジメント等の、上位の情報処理資格を取得する手助けになることだと考えています。私も基本情報を取る前に先にiパスから受験しました。ここで、IT業界では「基本情報・応用情報は有用な資格ではない」という意見もありますよね。これについては同意するところではありますが、話が脱線するのでここでは触れません。 実際に体験して感じたことですが、iパス対策で勉強したことは基本情報を受験する中で確かに役立ちました。基本情報などの上位資格を目指す時に初めてリターンが返ってくる資格だと思います。文字通り、上位資格へのパスポートという訳です。 その他のメリットとしては高校生が取得すれば進学で有利になる可能性があることですね。大学の推薦入試などで優遇してくれる学校があるみたいです2。言い換えれば、大学以上では意味が薄くなってしまうということです。 これまで、基本情報を取りたい人がiパスを受験することは無意味では無いと言いました。しかし、ここで受験料の値上げが重くのしかかります。 結論としては「どうせ単体では意味を成さない資格に、受験料を7,500円も払う意味ってあるんだろうか…？」というのが正直な思いです。 確かにiパスの知識は基本情報で役立ちます。ただ基本情報から受験をして受かることが難しいということでもないです。よって、基本情報を目指している人が7,500円を払ってiパスを取るのはコスパが悪いというのが私の結論です。 今回はiパスを受ける意味について思ったことを書きました。 「基本情報の前にiパスを取ろうかな」と思っている人は、申し込みをする前に一考してみるといいかもしれません。考えた末に取りたいと思った人は、1回の受験でサクッと合格できたらそれが一番良いですね！以上で記事を終わりにします。 情報処理技術者試験 受験手数料の改定について | IPA 独立行政法人 情報処理推進機構&#160;&#x21a9;&#xfe0e; 情報処理技術者試験 活用事例 | 情報処理推進機構&#160;&#x21a9;&#xfe0e;"},{url:"/dimzakki-mainroad/c-language-compiler/",title:"学習用C言語開発環境について【おすすめ学習サイトも紹介】",date:"2021-09-24T00:00:00Z",body:"学習用C言語開発環境について【おすすめ学習サイトも紹介】 C言語の初学者にコードエディターと、コンパイル機能が付いたフリーソフトの「学習用C言語開発環境」を紹介したいと思います。 「学習用C言語開発環境」の特徴や使い方についての解説と、C言語の学習におすすめなWebサイトについても紹介したいと思います。 フリーソフト「学習用C言語開発環境」について 「学習用C言語開発環境」は学習用にC言語を学びたい人向けに、必要最小限な機能だけを実装しているソフトです。 「学習用C言語開発環境」の特徴\r軽量で設定の必要がなく、インストールすればすぐ使える 学習に必要なコードエディターとコンパイル機能がメインでその他の機能は必要最小限 エラーメッセージが日本語に対応している プログラミングを始める人がつまづきやすい、面倒な環境構築をすることなく学習できるのは大きな利点ですね。 簡単にプログラミングを書いてコンパイルすることができるツールには、オンラインサイトの「paiza.io」があります。paiza.ioはオンラインのブラウザ上でプログラムを実行するサイトなので、オフライン環境で使うことができないという欠点があります。 関連記事\r【初心者向け】ブラウザ上でプログラムを書く方法【環境構築不要】 「学習用C言語開発環境」はパソコン上で実行するため、オフライン環境でも実行することができます。 「学習用C言語開発環境」の使い方 ソフトのダウンロードは以下のサイトから行えます。 学習用Ｃ言語開発環境 | 苦しんで覚えるC言語 学習用Ｃ言語開発環境 | 窓の杜 ソフトをインストールして実行すると、すぐエディタ画面になるので自由にコードを書くことができます。 「学習用Ｃ言語開発環境」の画面1 「学習用Ｃ言語開発環境」の画面2 左上の方にある「プログラムの実行」をクリックすることで、コマンドプロンプトの画面が立ち上がり実行結果が表示されます。 画像では、インストールしたものより、文字のフォントの大きさをいじって大きくしています。文字のフォントの大きさは「ツール」→「エディタ設定」→「フォント設定」で設定することができます。画像では文字サイズを12にしました。 使ってみた感想としては「とにかく軽い！」でした。余計な設定もしなくていいので、入門用としては最適だと感じました。 もっと手軽にプログラミングしたい人向け:ブラウザ版 「学習用Ｃ言語開発環境」の開発者さんの公式ページにはブラウザ上で動作する「ブラウザで動く C言語実行環境」も用意されています。こちらタブレットやスマホでも動作するので、更にお手軽にプログラミングしてみたい方におすすめです。また、オフラインでも動作するのも大きなメリットです。 C言語の学習におすすめなサイト JavaなどのWeb系のオブジェクト指向型言語等を学ぶためのサイトは「Progate」が有名ですね。しかし、CはWeb系のプログラミング言語ではないため、ProgateではC言語には対応していません。 そこで、個人的におすすめしたい学習用のサイトを紹介したいと思います。私がおすすめする学習用のサイトは上記のソフトを開発した方が作成している「苦しんで覚えるC言語」というサイトです。C言語について、初心者向けにプログラムの書き方から、基本的な機能を各章に分かれて順を追って解説されているので、無料で一から始める人におすすめできるような内容になっています。 各章ごとに練習問題も載っているため、「学習用Ｃ言語開発環境」で練習問題のプログラムを組むことで実践的に学習を進めていくことができます。 今回は「学習用Ｃ言語開発環境」と「苦しんで覚えるC言語」について紹介しました。どちらも、これからC言語を学習したい方にはとてもおすすめです。是非使用を検討してみて下さい！ 余談ですが、実は筆者が最初に触れた言語がC言語でした。大学が電気工学系だったので、ハードよりな感じだったので、組み込みに強いC言語が授業で扱われていました。なので少し思い入れがあります（仕事では使っていませんが…）。そういえば、基本情報技術者試験もプログラミングの選択問題をC言語で受験しましたね。Cはプログラミング言語の中では比較的難しく、敷居が高いイメージがあります。しかし、最初にC言語に慣れてしまえば他の言語を習得するハードルが下がるのではないかと思います。頑張ってものにしちゃいましょう！以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/qualification-javasilverse11-measures/",title:"【Java Silver SE11】試験対策用備忘録メモ【黒本ベース】",date:"2021-09-23T00:00:00Z",body:"【Java Silver SE11】試験対策用備忘録メモ【黒本ベース】 Java Silver SE11の受験にあたって、ややこしかった点を備忘録としてまとめたメモです。個人的に分かりにくかったところをピックアップしています。 なお、内容のカテゴライズは、Java Silverの参考書である「徹底攻略Java SE 11 Silver問題集[1Z0-815]対応」（黒本）の章に準拠しています。 関連記事\r【Java Silver】合格体験記【約100時間で合格した勉強方法】 【ORACLE MASTER】試験の申し込みを格安で行う方法【OCJ-P】 第1章:Javaの特徴とJavaプログラムの作成 Javaの特徴 Javaのデータには参照型と基本データ型がある Javaの開発環境 Java SE11での開発環境の変更点 AppletおよびWeb Startが削除された 32ビットWindows版バイナリが提供されなくなった クラスのインポート import文\r1import パッケージ名.*;\rimport文を使用してインポートが必要となるクラス 自クラスとは異なるパッケージのクラス java.langパッケージ以外のパッケージのクラス パッケージ パッケージ\r1package パッケージ名;\rパッケージの目的は、名前空間の提供・アクセス制御・クラスの分類の3つ 他パッケージのクラスを利用する場合、import文を定義し、利用するクラスのインポートを行うこと、利用するクラスがpublicクラスであることが必要 パッケージ宣言されていない無名パッケージ（デフォルトパッケージ）のクラスは同じ無名パッケージのクラスからしかアクセスできない mainメソッド 処理を始めるメソッドのことをエントリーポイント（mainメソッド）という 引数名以外は変更できない publicとstaticをつける mainメソッド\r1public static void main(String[] args) {// {String... args}も可能 2 // 処理 3}\rJavaコマンド Javaプログラムを実行するにはJavaコマンドを使う Javaコマンド\r1java Sample 2java Sample.java\r第2章:基本データ型・文字列操作 識別子の命名規則 識別子（変数名）は予約語を使えない default、ifなど 識別子は数字から始められない 識別子で記号はアンダースコア_と通貨記号$のみ使える 整数リテラル アンダースコア_は先頭と末尾と記号の前後にはつけられない 整数リテラル\r1int a = 123_456; // OK 2int b = _123; // NG\rint型 int型での10進数以外は以下の様に表す 進数 接頭辞 2進数 0b... 8進数 0... 16進数 0x... var型 var型では、データ型を特定できないものはコンパイルエラーになる 配列の初期化式もエラーになる var型\r1var a; // エラー 2var b = {1,2}; // エラー\rvar型はローカル変数のみ使える フィールド変数や引数変数には使えない var型は変数を同時に宣言できない var型\r1var a = 1, b = 2; // エラー\rStringBuilderクラス StringBuilderクラスのオブジェクトは参照情報になるため、比較しても同一の参照値が参照される 第3章:演算子・判定構造 型変換 byte型は-128~127の範囲を扱う 浮動小数点数はdouble型がデフォルト float型\r1float f = 1.0; // floatだとコンパイルエラーになる\r同値性と同一性 同値性はインスタンスは異なるが同じ値をもっていること new演算子を使う時は新しいインスタンスが作られる 同一性は同じインスタンスを参照していること switch文 case式の特徴 caseで指定できるのは定数式 long・double・float・boolean型はcase式に使えない case値はfinal宣言された変数かリテラルを使う break文がないとその下のcaseとdefaultも実行される 第4章:制御構造 for文 for文の初期化文に複数の変数を宣言するときは、同じ型でなければならない 初期化文内で宣言した変数はfor文の外では使えない 条件文を複数書くときは論理演算子（&amp;&amp;・||）で記述する カンマ,は使えない do-while文 do-while文でdoの中カッコ{}を省略した場合、その下には1文しか記述できない 第5章:配列の操作 配列型変数 配列型変数の宣言時の特徴 大かっこ[]はデータ型の後ろだけではなく変数の後ろにも記述できる 配列型変数の宣言時には要素数は指定できない 配列の初期値 値を代入せずに生成すると初期値になる 変数型 初期値 byte/short/int/long 0 float 0.0f double 0.0d char '\\u0000'(空文字) String null boolean false 第6章:インスタンスとメソッド リテラル nullは変数が何も参照してないことを表す 空文字&quot;&quot;は文字数0のStringクラスのオブジェクトを表す ガベージコレクション インスタンスの参照が無くなった時点でガベージコレクションの対象になる staticフィールド・staticメソッド staticフィールドはインスタンスを生成しなくても使える staticフィールドにアクセスするにはクラス名.メソッド名と書く staticメソッドは、staticフィールドとstaticメソッドにしかアクセスできない オーバーロード オーバーロードを行うには同一クラス内に引数の数・型・順番が異なるメソッドを定義する必要がある 変数名は関係なし 可変長引数 可変長引数はint... numの様に記述する 可変長引数は最後の引数でなければならない return文 return文の後ろの処理は実行できない コンストラクタ コンストラクタのルール コンストラクタには戻り値の型は記述できない インスタンス生成時（new演算子）に呼び出される アクセス修飾子の制限は無い 初期化子{}を使うことでオーバーロードされた全てのコンストラクタで共通の処理を行える 初期化子の処理が最初に実行される インスタンス生成時（new演算子）に呼び出される コンストラクタを省略した時はデフォルトコンストラクタが定義される コンストラクタから別のコンストラクタを呼び出すときはthisを使う thisで呼び出す時は最初に記述する アクセス制御 アクセス修飾子は以下の4つ 修飾子 内容 public 全てのクラスからアクセスできる protected 同じパッケージか、継承してるサブクラスからアクセス可能 なし 同じパッケージのクラスからアクセス可能 private クラス内からアクセス可能 カプセル化 カプセル化はフィールドをprivate、アクセスするためのメソッドをpublicにする 第7章:クラスの継承、インターフェース、抽象クラス 継承 コンストラクタとprivateなフィールド・メソッドは継承しても引き継がない スーパークラス コンストラクタを呼び出してオブジェクトを生成する際には、スーパークラスのコンストラクタを呼び出す必要がある コンストラクタ呼び出しが明記されてなくてもコンパイル時にsuper();の呼び出し処理が先頭行に暗追加される インターフェース インターフェースは自動的にpublicで修飾される インターフェースに実装を記述するにはデフォルトメソッドを使う デフォルトメソッドにはdefault修飾子を付ける サブインターフェイスなどで、デフォルトメソッドの処理内容を変えたい時にはオーバーライドを使う インターフェイスはインスタンス化できない 抽象クラス 抽象クラスはインスタンス化できない オーバーライド メソッドの名前と引数（型・数・順番）は同じである必要がある 戻り値の型は同じかサブクラス型である アクセス修飾子は同じかより緩いもの 型変換 型が違う時は型変換をする必要がある 型変換\r1A a = new B(); 2B b = (B) a;\r第8章:関数インターフェース、ラムダ式 ラムダ式 ラムダ式の引数は関数インターフェースのメソッドの引数と一致させる必要がある データ型の指定は省略できる 引数を受け取らないメソッドの時は引数を省略できる ローカル変数と同名の変数は引数に宣言できない {}で囲まれている時は複数処理が書けるがreturn文とセミコロン;が必要 ()は省略できる ラムダ式\r1Algo a = (name) -&gt; { return &#34;ABC&#34;; }; 2Algo a = (name) -&gt; &#34;ABC&#34;; 3Algo a = name -&gt; &#34;ABC&#34;;\rラムダ式の外のローカル変数にアクセスするときには、変更されない変数（実質的にfinalな変数）である必要がある 関数型インターフェース 関数型インターフェースの4種類の特徴 種類 メソッド 説明 Consumer&lt;T&gt; void accept(T) 引数を受け取り処理する、結果は戻さない Supplier&lt;T&gt; T get() 引数を受け取らず、結果だけ返す Predicate&lt;T&gt; boolean test(T) 引数を受け取って、それを評価する Function&lt;T,R&gt; R apply(T) 引数を受け取って、指定された型の結果を返す 第9章:API Listコレクションのメソッド List.of()メソッドで作成されるリストは変更不可能となるため、要素の追加や削除を行うと例外が発生する Mathクラスのメソッド floor()メソッドでは、引数がNaN・無限大・0・-0の時、引数と同じ値が返される ArrayListクラスのメソッド　ArrayListクラスの特徴 要素数を自動的に増やすことができる 重複した値を扱える スレッドセーフではない 値にnullを追加できる removeメソッド実行後に読み出すと例外になる Arraysクラスのメソッド compare()メソッドは二つの配列を比較し、0（同じ時）・負（第1配列の方が小さい）・正（第2が小さい）を返す 第10章:例外処理 try-catch文 例外が発生したらすぐにcatchブロックに移る catch文が複数ある場合で到達不可能なコードになる時はコンパイルエラーになる try-catch-finally文 finally処理は例外の有無にかかわらず実行する try-catch-finallyの順番を変えることはできない（コンパイルエラーになる） 第11章:モジュールシステム モジュールシステムの概要 内部APIの想定してない使用を防げる カスタムランタイムを構成できる コンパイル時と実行時の両方で必要になるモジュールを認識できる 厳密なカプセル化が可能 モジュール記述子 module-info.javaのファイル名で作成する module ファイル名{}で宣言する プログラムコードのルート階層に配置する モジュール型プロジェクト jdepsコマンドはクラスファイルの依存関係をパッケージレベルかクラスレベルで表示することができるアナライザ jdepsコマンド\r1jdeps --check\rモジュール型アプリケーション モジュール化されたアプリケーションをコンパイルするには、モジュールの検索パスを指定するオプションが必要 モジュールの検索パスを指定するオプション\r1-p 2 3--module-path\r他にもディレクトリ配下のモジュールを一括してコンパイルするオプションがある モジュールを一括してコンパイルするオプション\r1--module-source-path\rモジュールグラフ 各モジュールはjava.baseモジュールには明示されていなくても暗黙的に依存する モジュール型JDK 観測可能なモジュールが検索される順番は、ルート→コンパイル→アップグレード→システム→アプリケーション"},{url:"/dimzakki-mainroad/qualification-ap-book/",title:"【応用情報技術者 合格教本】おすすめの使い方【商品レビュー】",date:"2021-09-22T00:00:00Z",body:"【応用情報技術者 合格教本】おすすめの使い方【商品レビュー】 応用情報技術者試験（応用情報）の参考書「応用情報技術者 合格教本」について、内容のレビューとおすすめの使い方について書いていきます。 関連記事\r【応用情報技術者試験】合格体験記【約30時間で合格】 「合格教本」の特徴 「応用情報技術者 合格教本」は「応用情報技術者試験」の定番とも言える参考書です。その特徴をまとめていきます。 令和06年【春期】【秋期】 応用情報技術者 合格教本\r3,278円～ amazon.co.jp 「合格教本」の大きな特徴は試験範囲を網羅していることです。試験対策には過去問道場とこの本一冊で十分だと思います。午前試験の範囲はほぼ全て網羅されていますが、午後試験についても一通り試験範囲が網羅されているのも特徴です。特に、午後で文系問題を選択する人には十分な解説量だと思います。 解説についてはややお固い印象を受けますが、その分しっかりと深いところまで解説がなされています。ページの左側にはコラムが載っていて解説の助けになります。また文章だけでは無く、図も多いですね。各章末には「得点アップ問題」が付いています。 また、単元毎に午前で出るか午後で出るか項目の横の部分に書かれているので、対策時にどちらの試験問題に出題されるかが分かりやすいです。 「合格教本」の特徴\r試験範囲のほぼ全てがカバーされている 解説も細かく内容が深い 午前と午後どちらで出題されているか分かりやすい 私は紙の本タイプのものを購入していましたが、持ち運びのことなどを考えると電子書籍版を購入するのも手です。700ページ超の書籍なのでここら辺は自分の好みで選択して良いと思います。 また、巻末の方に午前と午後の過去問が載っていますが、過去問については過去問道場のサイトが一番使い勝手が良いです。使うことは無いと思います。 「合格教本」の使い方 「合格教本」の使い方として、最初にお伝えしておきたいことがあります。試験対策において、この本を最初から読んでいく必要はありません。 理由は、内容が細かく多いので読む量が多くなってしまうからです。内容が深い分あまり重要な知識でないことも書かれているので全部やっていくと時間が掛かり非効率です。まあ、実際に全て丸暗記できたら余裕で合格できるんでしょうが、そんなことが出来る能力があるならもっと難しい試験をやった方が良さそうですね。 基礎知識が無いまま読むと書いてある内容が細かい分、理解し難い（または理解に時間が掛かる）箇所が多いのであまり効果的な勉強法とは言えません。また、過去問演習が出来るアプリをダウンロードできるようですが、私は過去問道場を使っていたので利用しませんでした。 これは他の参考書についても言えることですが、1周読むだけで合格できるような参考書は存在しません。応用情報の試験対策で一番重要なことは「過去問演習」です。問題を解いて知識を体得することが最も効率的な方法であり、参考書はそのプロセスを助けるために存在しています。 ではどういった使い方がおすすめかと言うと、「過去問道場などで問題演習をしていく中で1つの部分を重点的に学びたい時に使う」やり方がおすすめです。 「合格教本」のおすすめな使い方\r過去問道場などで過去問を解いていく 解説が理解できない部分、自分が重点的にやりたい部分をこの本で調べる 苦手だと感じた分野は章末の「得点アップ問題」にも取り組む 上記のサイクルを繰り返し行うことで効率良く知識を深めることができます。 この方法は午前試験、午後試験の両方の対策でおすすめな方法です。巻末には索引もあるので、知りたい用語についてはこちらから調べることができます。 試験本番にも持っていくのがおすすめ これは実体験からおすすめしたいことですが、試験本番で（特に午後試験の直前に）この本を見直すと得点アップに繋がると思います。午後試験の直前に「情報セキュリティ」の章を見直していました。情報セキュリティの問題は必答であり、用語を聞いてくる問題が出題されるので、試験が始まる前に確認すると良いと思います。 実際に受験し合格した試験（令和3年春試験）では、情報セキュリティの大問で「DNSキャッシュポイズニング」という用語を書かせる問題が出題されました。偶然にも、直前にこの本を見直したことで正答することが出来ました。 今回は「応用情報技術者 合格教本」のレビューとおすすめな使い方について紹介しました。 参考書では特に試験直前に見直しができるのでおすすめです。また、参考書を読むことより問題演習を繰り返していくことが合格への一番の近道です。演習は忘れずにやっていきましょう。 気になった方は是非参考にしてみて下さい。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/qualification-fe-pm-selection/",title:"【基本情報技術者試験】科目B試験のおすすめ対策法",date:"2021-09-17T00:00:00Z",body:"【基本情報技術者試験】科目B試験のおすすめ対策法 基本情報技術者試験（基本情報）の科目B試験のおすすめの対策法について紹介していきます。 なお、2023年4月から試験制度が変わり、今までの午後試験は科目B試験に置き換わったので注意が必要です。 関連記事\r【基本情報技術者試験】合格体験記【約50時間で合格】 科目B試験の内容について 科目B試験では20問出題され、全問に解答する必要があります。また、出題分野はアルゴリズム・プログラミングが16問とセキュリティが4問の2分野のみになります。試験時間は100分です。 分野 問題数 アルゴリズム・プログラミング 16問 セキュリティ 4問 科目B試験の合格点は1,000点満点中600点以上になりますが、配点はIRT（項目応答理論）方式で行われるので詳細は公開されていません。また、出題数20問中の1問が今後の試験の評価用の問題のため、採点に含まれません。 今までの午後試験では各分野から選択する方式だったので、形式が大きく変わったと言えます。出題分野もアルゴリズム・プログラミングの比重が大幅に上がりました。 科目B試験の対策 ここから、具体的な科目B試験の対策方法についてまとめていきます。 科目A試験での基礎知識を定着させる まず、前提として科目A試験での情報セキュリティ・アルゴリズムとプログラミングの分野の対策をしっかり行うことが重要です。科目B試験は科目A試験より難易度が高まるので、基礎知識が身に付いていないと効率的な対策が難しくなります。 試験で使われるプログラム言語の仕様を把握する 実際の試験問題で使われるプログラム言語の仕様は、公式1で公開されていますので、対策を始める前に見ておくと頭に入りやすいです。 基本的にはif文、for文、while文など馴染み深い構文なのでプログラムに慣れている人はすぐに理解できると思います。 公式のサンプル問題を解く 公式が公開している科目B試験のサンプル問題2がありますので、問題に慣れるためにも事前に解いておきましょう。 なお、『基本情報技術者試験ドットコム』でもサンプル問題のページ3同様の問題と解説が掲載されているので、そちらで勉強することも可能です。 アルゴリズムとプログラミングは紙に書いて解く プログラミングの問題では、プログラムの動きを正確に理解できないと解答を選ぶことができませんので、プログラムの動きをトレースする能力が必要です。 画面上だけで動きをトレースするのは難しいため、メモを用いてプログラムを読み解く方法がおすすめです。特に、配列の中身や処理の順序などは書かないとミスしやすいです。 本番でもメモはできるので、ちゃんとメモする癖をつけておきましょう。 本番時の時間配分も決めておく 大体でいいので、本番を迎える前に時間配分を決めときましょう。全体で100分で20問なので、1問5分を基準として計算しておくと良いです。 ただ、アルゴリズム・プログラミングはプログラムをトレースする必要があるので、時間は多めに取りたいです。 その上で、過去問演習の内から決めておいた時間配分を意識して解きましょう。アルゴリズムなどは問題に時間を掛けて理解することは大事ですが、本番前には想定の時間内に解くようにしたいです。 基本情報の午後の選択問題についてまとめました。アルゴリズム・プログラミング対策をしっかり固めておく必要があるので、そちらを重点的に勉強していくことが近道です。 以上で記事を終わりにします。 試験で使用する情報技術に関する用語・プログラム言語など | 独立行政法人情報処理推進機構&#160;&#x21a9;&#xfe0e; 基本情報技術者試験　科目Bのサンプル問題 | 独立行政法人情報処理推進機構&#160;&#x21a9;&#xfe0e; 基本情報技術者 サンプル問題 | 基本情報技術者試験ドットコム&#160;&#x21a9;&#xfe0e;"},{url:"/dimzakki-mainroad/qualification-fe-kayanoki/",title:"【栢木先生の基本情報技術者教室】おすすめの使い方【商品レビュー】",date:"2021-09-15T00:00:00Z",body:"【栢木先生の基本情報技術者教室】おすすめの使い方【商品レビュー】 基本情報技術者試験（基本情報）の参考書「イメージ&amp;クレバー方式でよくわかる 栢木先生の基本情報技術者教室」（栢木先生の基本情報）について紹介します。 主に内容のレビューと勉強時の使い方について書いていきます。 関連記事\r【基本情報技術者試験】合格体験記【約50時間で合格】 「栢木先生の基本情報」とは? 「栢木先生の基本情報技術者教室」は基本情報試験の最も定番の参考書の1つです。定番の参考書では「キタミ式イラストit塾 基本情報技術者」（キタミ式）と双璧をなす1冊ですが、こちらはより読みやすさ（理解しやすさ）を重視したコンセプトの参考書になっています。 令和06年 イメージ＆クレバー方式でよくわかる かやのき先生の基本情報技術者教室\r1,848円～ amazon.co.jp キタミ式イラストIT塾 基本情報技術者 令和06年 (情報処理技術者試験)\r2,420円～ amazon.co.jp 私が基本情報を受験した時は「栢木先生の基本情報」を使いました（キタミ式は知り合いが持っていたのを見させてもらったぐらいです）。 「栢木先生の基本情報」の特徴 この本の特徴は大きく分けて以下になります。 「栢木先生の基本情報」の特徴\r初学者向けに分かりやすさを重視した文章と内容になっている 単元毎に出題頻度が示されている 内容は科目A試験のものがメインになっている 中身はこんな感じです。緑を基調とした目に優しい色合いです。 内容は分かりやすく、「～とくれば～」といった注釈が多く入っていて、知識の整理がしやすいようになっています。イラストも多く入っており、堅苦しさがないですね。 また、この参考書の大きな特徴は目次と表題にその単元の出題頻度が載っていることです。頻出の分野は押さえておきたいです。 内容は科目A試験の出題範囲をまんべんなくカバーしています。科目B試験については、アルゴリズムやプログラミング言語の部分はあまりカバーされていないので気を付けましょう。 表紙カバーを取ると抹茶みたいな濃いめの緑一色でシンプルな感じですね。カバーを取って初めて気づいたんですが、カバーの裏に「重要用語虎の巻」という、出題されそうなの重要単語とその意味がまとめて印刷されています。試験直前に使えそうなので、カバーは取っておいた方が良さそうです。これは気付かなかった人が結構いそうな気がしますね…。 購入の際は最新版を買いましょう 1つ注意点ですが、購入する際は最新年度版を買いましょう。 実は、私は「栢木先生の基本情報」を2冊持っています。1つはブックオフで買った平成25年度版（￥210で買いました）で、もう1つは人から貰った令和3年度版です。この2冊を比較してみると、内容が大きく異なっていることが分かります。総ページ数も、H25年度版は455ページなのに対し、R3年度版は527ページとボリュームも違います。 途中から最後年度の本を手に入れたこともありますが、古い参考書の方は結局ほとんど読まずに試験を終えました。今両者を比較してみると、セキュリティの章などは書いてある内容が大分増えていますね。反対に情報基礎理論などは書いてある内容があまり変わっていません。 ITは日々新しい情報がアップデートされていく分野であり、特にセキュリティ分野などは技術の進歩により試験で扱われる事柄も変化していることから、なるべく新しい情報が載っている参考書を使用した方がよいでしょう。「安物買いの銭失い」とは良く言いますが、古い本を中古で買っても結局活用せずに無駄になってしまうので使うなら新しいバージョンをおすすめします。 「栢木先生の基本情報」と「キタミ式」はどちらがおすすめ？ 私は「栢木先生の基本情報」をおすすめします。なぜなら合格するための情報がしっかりカバーされているからです。 両者を比較してみると「キタミ式」がボリュームでは勝っていますが、『栢木の基本情報』の内容が劣っている訳では無く、むしろ必要な知識がシンプルに効率良く書かれていると感じました。対してキタミ式は量が多くてごちゃごちゃしている印象です。 参考書としては、内容が分かりやすく持ち運びもしやすい「栢木の基本情報」が優秀であると感じました。 「栢木先生の基本情報」の使い方 参考書の使い方として、最初にお伝えしておきたいことがあります。参考書を最初から全部読んでいく必要はありません。この方法だと終わるまでに時間と労力がかかり過ぎるので非効率です。 過去問道場などで問題を解きつつ、問題の解説でどうしても分からないところがあった時に参考書でそこだけ読む（参考書の確認問題を解く）というやり方がおすすめです。 最初からテキストを読み始めるのは推奨しません。 解いた方が良い問題 個人的には「基礎理論」の章や「ネットワーク技術」の章の「IPアドレス」の単元はこの参考書の確認問題で勉強することをおすすめします。 計算問題が多いので、しっかり問題を解いて慣れることが大切です。 今回は「イメージ&amp;クレバー方式でよくわかる 栢木先生の基本情報技術者教室」についての紹介でした。特に未経験者の方にはおすすめの参考書です。 余談ですが、この参考書のことをずっと柏（かしわ）木先生だと思ってました。栢（かやの）木って読むんですね…。 とても使いやすい本なので、参考書選びの際は是非参考にしてみてください。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/qualification-ap-pm/",title:"【応用情報技術者試験】午後の選択問題のおすすめを紹介",date:"2021-09-14T00:00:00Z",body:"【応用情報技術者試験】午後の選択問題のおすすめを紹介 今回は応用情報技術者試験（応用情報）の午後の選択問題について、個人的におすすめな選択問題の分野を紹介します。 関連記事\r【応用情報技術者試験】合格体験記【約30時間で合格】 【IT資格】iパス・基本情報・応用情報を4ヶ月で合格した体験談 応用情報の午後試験について 応用情報の午後試験は、長文問題が11問出題され、その中から5問を選択して解答する形式になっています（問1の情報セキュリティは必須）。 必須問題 情報セキュリティ 選択問題（10問から4問を選んで解答する） 経営戦略 システムアーキテクチャ ネットワーク データベース 組み込みシステム開発 情報システム開発 プログラミング プロジェクトマネジメント サービスマネジメント システム監査 午後試験は100点満点で、合格点は60点、1つの大問につき配点は20点です。単純な暗記だけでも通用する午前試験とは違い、文章の読解力と回答に必要な記述力が求められています。 ちなみに、試験時間は150分なので、単純計算で大問1問につき30分ずつの時間があると計算できます。 おすすめな選択問題 情報セキュリティは必須として、その他の選択問題は基本的に自分の得意分野から選ぶことがスタンダードな方法です。選択問題は4問解く必要がありますが、本番の問題が難しい可能性もあるので予備でもう1分野入れて5分野くらいを対策しておくといいでしょう。 特に得意分野が思いつかない方向けに、私見ですが各分野のおすすめ度を紹介していきます。 プログラミング（おすすめ度:★★★★☆） プログラミングが得意な人は選択するのがおすすめです。記述ではありますが、基本と比べてもそこまで難易度は上がっていません。 基本情報でアルゴリズムとプログラミング言語を得点源にしてた人には特におすすめです。ただ、問題でハマると時間をたくさん掛けてしまいがちなのでタイムマネジメントに注意。 ストラテジ・プロマネ・サーマネ・経営戦略（おすすめ度:★★★★☆） ストラテジ・プロジェクトマネジメント・サービスマネジメント・経営戦略辺りのいわゆる文系問題は比較的おすすめと言えます。 知識な必要な理系問題とは少し違い、国語的な問題が多いため理系問題と比べて全体的に難易度が低く必要な知識量と勉強量も少ない傾向にあると言えます。 ネットワーク・情報システム開発（おすすめ度:★☆☆☆☆） ネットワーク・情報システム開発は個人的にはおすすめできません。この2つの分野は過去問でも全体的に難しいので避けた方が無難だと思います。ネットワークは得意な人なら選択するのはアリだと思います。 ちなみに、筆者は本番で情報システム開発を選んでそこだけ爆死しました…。 組み込みシステム開発（おすすめ度:★★★☆☆） その名の通り組み込み系の経験者向けな分野になります。過去問では各回通して計算問題が多い印象です。 出題される計算問題自体は、それ程難しい問題は無さそうな感じですが、トータルで考えると回によって難易度の差が激しいので、得点が安定するかといったといったら微妙だと思います。 データベース（おすすめ度:★★★☆☆） データベースは仕事でSQLを使っている人などにはおすすめしたいですが、そうでないという人にはあまりおすすめできません。SQLの構文など暗記することが多いので対策に時間が掛かってしまいます。 SQL自体は普遍的な物ではあるので、これからの為に覚えてしまうというのもアリかもしれませんね。 システムアーキテクチャ（おすすめ度:★★★☆☆） システムアーキテクチャは回によって傾向が代わり、ネットワークに近い問題だったり、データベースに近い問題だったりと出題範囲が広いのが特徴です。また、稼働率などの計算問題も多い印象ですね。特段おすすめはできませんが、行けそうなら選択しても良いとは思います。 実際に試験で選択した分野 実際に試験を受けた時は、午後試験では情報セキュリティ・システムアーキテクチャ・組み込みシステム・情報システム・システム監査を選択しました。あまり午後の対策は出来なかったものの、結果は60点でギリギリ合格でした。 やはりシステム監査で得点を稼げたのが合格に繋がっていたと思います。逆に、情報システムでは問題が分からな過ぎて足を引っ張ってしまいました。 今回は応用情報の午後試験の選択問題についてまとめてみました。選択問題では、特にシステム監査は他の分野に比べてとても簡単です。選択問題に迷っている方は是非選択することをおすすめします。 結局のところ、得意分野が無いという方は情報セキュリティ + オール文系問題で対策していくのが一番時間を掛けずに合格率が高いと思いました。 以上で記事を終わりにします。 参考文献 応用情報技術者試験 | IPA 独立行政法人 情報処理推進機構"},{url:"/dimzakki-mainroad/game-ps5-mixamp-hdmiadapter/",title:"【PS5】MixAmpをASTRO HDMIアダプターで使う方法",date:"2021-08-19T00:00:00Z",body:"【PS5】MixAmpをASTRO HDMIアダプターで使う方法 PlayStation 5にMixAmpをHDMIアダプターを使って接続する方法について紹介します。 関連記事\r【MixAmp】FPSでのアンプの重要性【Apexのイコライザ設定など】 【DualSense Edge】PS5でApexをプレイした感想【MixAmp】 PS5には光デジタル端子が無い MixAmpはFPS等の音声が重要であるゲームに威力を発揮するデバイスです。また、MixAmpは光デジタル端子を使うことでフルに性能を発揮します。光デジタルケーブルは信号を送信する際のノイズ・劣化が少ないので音質に優れるという特徴があるからです。MixAmpを光デジタル端子を使うメリットとして以下の利点があります。 光デジタル端子を使うメリット\rミキシング機能でゲーム音とVC音の音のバランス調整ができる イコライザーが使用できる Dolbyサラウンドに対応している MixAmpは光デジタル端子を使わないと性能を発揮できません。しかし、PS5には光デジタル端子がありません。つまり、残念ながらPS5にはそのままMixAmpは接続できないということです。一応USBだけで直刺し接続はできますが、ゲーム音とVC音を個別に調整出来ませんし、音質も悪くなってしまいます。 PS5とMixAmpをそのまま繋げる場合の配線 実際に、PS5でUSB接続でMixAmpを使ってみましたが、PS4で光デジタルケーブルを使ってプレイした時より音の聞こえ加減が悪いので、音質面での違和感が凄い。また、ゲーム音とVC音の個別の調整もできません。どのようにしたら使えるのか…。ちゃんと使えるようにするには、光デジタルをアダプターでHDMI接続に変換する必要があります。 どのように接続するかというと、「Logicool G ASTRO Gaming HDMI アダプター」と呼ばれる機器を使います。これ一つでMixAmpとPS5を接続できます。 Logicool G ASTRO Gaming HDMI アダプター for PS5 PS4 ミックスアンプ 用 オプティカル 光デジタル オーディオ SPDIF 音声分離 AHS-HDMIADP 国内正規品\r15,980円～ amazon.co.jp 流石にMixAmpが使えないのはストレスなので、HDMIアダプターを買ってみることにしました。 HDMIアダプターを繋げてみる HDMIアダプターの外観はこんな感じです。 HDMIアダプターの外観 HDMIアダプターは結構小さいです。MixAmpの半分もありません。本体に付属する配線はHDMIケーブル・電源用USBケーブルの2本です。 HDMIアダプターの接続 実際に、PS5とMixAmpにHDMIアダプターを接続してみましょう。配線を分かりやすく図にするとこんな感じです。 PS5とMixAmpをHDMIアダプターで繋げる場合の配線 HDMIアダプターにPS5からのHDMIケーブルとMixAmpからのHDMIケーブルを接続して、アダプターとモニターをHDMIケーブルで結ぶ感じです。 そこまで複雑な配線では無いですね。自分もすぐ接続できました。しかし線が多くなり、適当に繋げると絡まってごちゃごちゃしやすいので注意。 ちゃんと聞こえるようになったか少し不安でしたが、元通りに聞こえるようになりました。これでFPSでもしっかり足音聞こえるので安心です！ PS5本体の設定＆外部スピーカーへの出力 PS5本体の設定は以下の箇所を確認すればOKです。 PS5本体の設定\r「サウンド」→「マイク」→「入力機器」→「USBヘッドセット（Astro MixAmp Pro）」 「サウンド」→「音声出力」→「出力機器」→「USBヘッドセット（Astro MixAmp Pro）」 「サウンド」→「音声出力」→「ヘッドフォンへの出力」→「ボイスチャット音声」 画面では以下の通りになります。 PS5本体の設定1 PS5本体の設定2 また、3.5mm端子対応の外部スピーカーを繋げてそこへ音声を出力したい場合は、MixAmpにあるstream端子に3.5mm端子を差し込めば出力されるようになります。 今回はHDMIアダプターでMixAmpとPS5を接続してみました。PS5でもアンプがちゃんと使えて超便利でした！数少ない欠点としては配線が複雑になりやすい所でしょうか。 HDMIアダプターの価格はそれほど高くないので、PS5とMixAmpを持っている人はぜひ購入を検討ください。 以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/blog-access-problem/",title:"【ロリポップ】「このサイトにアクセスできません」の解決方法",date:"2021-08-17T00:00:00Z",body:"【ロリポップ】「このサイトにアクセスできません」の解決方法 先日、「DNS_PROBE_FINISHED_NXDOMAIN」エラーによりアクセスできなくなってしまってました。その後復旧できたので、原因（ドメイン認証）と対処法について書きます。 突然「アクセスできません」と表示された 2021年8月15日の夕方頃、このサイトのトップページにアクセスしたら「このサイトにアクセスできません」と表示されました。 当時、このサイトには立ち上げたばかりで、大体1日に1回くらいの頻度でアクセスしていました。つまり、前日にはアクセスできたのに、唐突にアクセス不可能になってしまったということです。エラー画面のスクリーンショットはしてなかったので画像は無いですが、下の画像のような感じです。 エラーの画像（イメージ） 特に前ぶれもなくアクセスできなくなったので驚きでした。表示されていたメッセージは「DNS_PROBE_FINISHED_NXDOMAIN」でした。このエラーは、DNSに関するエラーで、NXDOMAIN（Non-Existent Domain）は存在しないドメインであるということです。 サーバーかドメインの契約期間切れで、このようなエラーが発生することはありますが…。どちらも契約したばかりなので、そんなことはありません。なにか別の原因があるようです。 原因は「ドメイン認証」だった 「何もしてないけど…なんだ？？」とネット検索で調べてたら見つけました。「ドメインの認証」を行ってなかったのが問題でした。「インターネットが何もしてないのに壊れた！」というのは大体利用者側に落ち度があることが多いのですが、今回も例に漏れず自分のせいですね。要するに、何もしてなかったことが理由でした。 当時、このブログのドメインは「ムームードメイン」で取得したものでした。ドメインの新規取得時に、ドメインの情報認証を期限までにやっていないと、ドメイン利用制限になってしまい、サイトにアクセスできなくなるようです。認証をしないといけないドメインは、「ccTLD （カントリーコードトップレベルドメイン）」を除く全ドメインになります。 また、ドメイン認証はムームドメインだけでは無く「お名前.com」でドメインを取得した人も同じく必要です。 メールのURLで認証する メールの受信フォルダに「【重要】[お名前.com] ドメイン 情報認証のお願い」という件名のメールが来ているので、メール内のURLにアクセスすることで解決します。 ドメイン認証の案内メールの画像です。こちらのリンクから承認を行います。 ドメイン認証の案内メールの画像 先ほどのメールから認証を行った後に通知されるメールの画像です。 ドメイン認証後の通知メールの画像 私はこのサイトのドメインを「ムームードメイン」で取得しましたが、メールの件名では「お名前.com」になっているので見落としてました。メール内のURLにアクセスすることで認証が完了するので、その10分後くらいに復旧しサイトにアクセスできるようになりました。認証の完了の通知メールも来ます。 これでアクセスが復活しました！無事復活して良かったです。 基本的にこのエラーでは「DNSが停止された」か「DNSの設定が変更された」かのどちらかが原因なので、設定をいじってなくアクセス出来なくなったら単に何かの理由でDNSが停止されたということになりますね。 ブログを開設したのは初めてで、完全に下調べ不足でした…。似たような記事もいっぱいあったので、私と同じように見逃してる人は多そうです。 特に、ブログ始めたての人はドメイン認証には気を付けましょう！ 以上で記事を終わりにします。 参考文献 ドメイン情報認証の対応方法 | ムームードメイン"},{url:"/dimzakki-mainroad/game-mixamp-apex-equalizer/",title:"【MixAmp】FPSでのアンプの重要性【Apexのイコライザ設定など】",date:"2021-08-14T00:00:00Z",body:"【MixAmp】FPSでのアンプの重要性【Apexのイコライザ設定など】 今回はゲーミングデバイスのMixAmpについて紹介します。FPSでの音の重要性と、強くなるためにおすすめなアンプやゲーミングイヤホンについて元FPSガチ勢が語りたいと思います。 私のFPS遍歴について 私はFPS元ガチ勢です。なぜ元が付くかというと、今は社会人となりゲームする時間が減ったのでエンジョイ勢にジョブチェンジしたからです。 FPS自体は中学生時代からやっていて、一番FPSをプレイしてたのは大学時代でしたね。昼夜問わず一日中やっていたこともありました。当時は他にこれといった趣味が無かったのもありますが…。つまり、FPSのキャリアとしては10年近いということになりますね。 主にやっていたゲームは「Call of Duty」シリーズです。普通の対人戦（マルチプレイ）をやってました。それと協力モードであるゾンビモードもやりこんでいました。ゾンビモード面白いですよね。 また当時の流行りに乗って「Apex Legends」もシーズン8からやり始めました（とは言えやり始めたのが大学の卒業間近で忙しかったこともあり、あまりやりこんでいたとは言えませんが…）。 戦績紹介 ゲームの戦績がこんな感じです。とりあえず今起動できるのが「CoD:BOCW」と「Apex」くらいなのでそれらを貼ります。ちなみに使用デバイスはPS4（PS5）の純正コントローラーです（PS5でもPS4の純コン使ってます）。 「CoD:BOCW」の戦績 BOCWの戦績です。キルレが2.7で平均よりそこそこ高いと思います。BOCWは野良か2~3パでやることが多かったです。BOCWは何故か人気無いみたいですが、個人的には普通に面白かったです。2月くらいになってAPEXやり始めてからこちらはやめちゃったので、今はやってませんが…。FPSをプレイして来ての戦績のピークがこの「CoD:BOCW」と1作前の「CoD:MW」に辺りになるかなと思います。 次にApexの戦績紹介です。こちらは人気になった途中から参戦したことや、ソロで適当に遊んでることが多いのでApexのキルレは大したことないです。参考までに良かった時のマッチの戦績を貼ります。 「Apex」の戦績1 「Apex」の戦績2 1枚目がジブラルタルで「爪痕（20キル以上）」と「ダブハン（4000ダメージ以上）」のバッジを同時に取った時の画像です。始めたてのシーズン8の頃はジブラルタルばっか使ってました。今たまにやる時はバンガロールとか使ってますかね。爪痕はジブだけですが、ダブハンはブラハ・バンガ・レブナントも持ってます。 2枚目はバッジの「チームワーク10」を取った時のスクショです。このバッジは全員10キル以上しないといけないので大変難しいです。一緒にプレイしてくれたフレンドに感謝ですね。 しかし、特別自分にFPSのセンスがあった訳では無く、むしろセンスはあまり無い方に思っています。人より長くやってる分、経験的なのがあるってだけですね。逆に言えば、プレイ時間を積めば殆どの人が誰でもこのレベルかもしくはそれ以上に達すると言えます。（多くの人は毎日何時間もゲームをプレイできる程、暇ではないですが…）そして、もう1つの重要な要素がデバイス等のプレイ環境です。ここから本題に入います。 FPSやバトロワゲーにおいての音の重要性 そろそろ本題に入ります。FPSで一番重要なのはエイム・立ち回りなんですが、そんなのは一朝一夕で得ることは難しい。その次くらいに重要なのが音（足音・銃声）です。 足音や銃声が聞こえれば敵がいることが分かりますし、こちらからだけ足音が聞こえていれば先手を打つことが可能です。特にAPEXのようなワンライフのバトロワでは敵の位置を知ることが重要な要素になってくるので、足音を聞けるかどうかは非常に大事です。 もちろんゲーム内設定とかはありますが、基本的にデバイス面の効果が大きいです。ブラウン管テレビでプレイしたら不利になるのと同じですね。 足音を聞くために必要なもの より足音を正確に聞くために必要なデバイスは「ヘッドセット（イヤホン）」・「アンプ」の2つです。 アンプというのは音の増幅器です。例えば、イコライザ設定で足音の周波数のみを集中して増幅し、足音をしっかり聞けるようになります。今回紹介するのは一番有名で評判の良い「ASTRO Gaming MixAmp Pro TR」になります。 Logicool G ASTRO Gaming MixAmp Pro ミックスアンプ ゲーミングアンプ MAPTR-002 ゲーミングヘッドセット 用 オーディオミキサー PS5 PS4 PC 対応 音声バランス調整 Dolby Audio 光デジタル端子 アンプ ゲーミングミキサー MAPTR 国内正規品\r15,036円～ amazon.co.jp ヘッドセットはゲーム音声・VCを聞くためのヘッドホンまたはイヤホンと、マイクが一体になったマイク付きイヤホン・ヘッドホンのことです。こちらは性能・価格はピンキリで、ゲーム用のいい奴だと軽く1~2万円やそれ以上します。アンプはMixAmpが15,000円くらいです。 一番いいのは良いヘッドセットとアンプをどっちも買うことです。しかし、両方揃えたら安くても30,000円くらい掛かります。プロでもないのにゲームのデバイスにそんなにお金を掛ける意味…。お金のない学生がそんなにデバイスに散在はできませんよね。 ここでおすすめしたいのが、高いヘッドセットを買うよりも先にMixAmpを買うことです。何故かは次で説明します。 ちなみに、この記事を書いた時点ではMixAmpと2,000円くらいのイヤホンを使ってます（現在使ってるイヤホンについては、コスパが結構良くておすすめなので、記事最後に紹介します）。 MixAmpを優先する理由 続いて、ヘッドセットよりMixAmpを優先すべき理由をいくつか分けて書いていきます。 1.ヘッドセットは失敗する可能性がある ヘッドセットは色々種類がありすぎて正直どれを選べばいいかわかりません。なので事前に自分でネットとかで調べて買うことになると思いますが、失敗する可能性があります。 例えば、「思ったよりも音質がイマイチだった…」「マイクの性能が良くなかった…」「装着感が悪い…」等々。高いお金を払って買ったのにハズレだったら勿体無いです。 2.性能の良いゲーミングイヤホンは高い ヘッドセットよりイヤホンが良いという方は一定数いると思います。私も、ヘッドセットは着けてると熱くなるのでイヤホンを使ってます。重さもヘッドセットよりだいぶ軽いので、首が疲れません。 ただ、小型化されてる分ヘッドセットよりも性能に対する値段が高いです。ある程度の性能を求めると、数万円以上するものがザラにあります。 3.MixAmpは安めのイヤホンでも劇的に変わる 新しくヘッドセット等を買わなくても、MixAmpを繋げてイコライザを設定しただけで劇的に音が聞こえるようになります。 当時、5,000円くらいのイヤホンでプレイしていましたが、 MixAmpを接続したらめちゃくちゃ聞こえるようになりました。遠くの足音だけではなく敵の方向もバッチリ分かります。なのでヘッドセットは後回しにしても問題ありません。 4.MixAmpは買い替える必要がない ヘッドセットは長時間の着用による劣化や断線による故障などが付き物なので、定期的に買い替える必要があります。反対に、MixAmpは買い替える必要ないです。1つ買えばずっと使えます。 その他に、オフゲーや音楽鑑賞にも使えますね。 MixAmpを買ったとき感じたこと 私がMixAmpを買ったのは2020年でした。当時やってたのは「CoD:Warzone」というバトロワゲーです。バトロワって死んだら終わりなので音が凄く重要です。 よくいきなり横や後ろから撃たれて雑魚死してたので、音の重要性を認識したのが買うきっかけになりました。エイムの方はこれ以上伸びない（ていうかボット撃ちとかの練習が嫌いなのであまり時間を掛けたくない）と感じてたので、デバイスで底上げしようとしたんですよね。 イヤホンは5,000円くらいだったので、そこまで期待はしてなかったのですが、使ってみたら想像の倍くらい良く聞こえたのでびっくりしました。イコライザの方も色々調べて設定したら更に聞こえるようになりました。アンプ本体もそんなにベタベタ触らないので綺麗だし、故障とかもありません。また、ゲーム音声とVC音声の音量を右のツマミで調整できるのも地味に便利です。 Apexのおすすめイコライザ設定 次に、私が使ってるおすすめのイコライザ設定を2種類紹介します。一応Apex用ですが、CoDをプレイしてる時も使用してた設定です。まず1つ目です。 MixAmpのイコライザ設定1 中心周波数（Hz） レベル 帯域幅（×CF） 95 3 - 406 2 2 783 -1 2 3901 2 1.5 6339 3 - Warzoneの時に設定してからそれ程変えてないはずですが、総合的に聞きやすいのでAPEXでもそのまま使っています。いわゆるスマイリー（smiley:上下に比べ真ん中の周波数の増幅レベルが小さい設定）と言われてるものになります。音を増幅しすぎるとキンキンするのでやや抑えめですが、足音の音と方向はしっかり聞こえます。 次に2つ目です。 MixAmpのイコライザ設定2 中心周波数（Hz） レベル 帯域幅（×CF） 95 5 - 406 -5 2 783 7 2 3901 7 0.5 6339 1 - これはYouTubeで紹介されていた設定です。確かに音は大きくなりますが、銃声などがキンキンして長時間やると耳に負担が掛かりそうなのであまり使ってません。足音優先したい方向けです。 PS5とPS4 Slimを使っている方は注意 PS5やPS4 Slimを使っている方は、光デジタル端子がないので、別途光ケーブルを使うためのHDMIアダプターが必要なので気を付けましょう。下の記事にアダプターを使う方法についてまとめています。 関連記事\r【PS5】MixAmpをASTRO HDMIアダプターで使う方法 今回はFPSで足音を聞くことと、MixAmpの重要性についてまとめました。気になった方はぜひ購入することをおすすめします！（マジで快適にプレイできます）私の経験談からでもApexのハンマーとかが取りやすくなります。是非使ってみてください。 余談ですが、私が使っているおすすめのマイク付きゲーミングイヤホンのレビュー記事を紹介します。 関連記事\r【SHURE AONIC 215】FPSで使用した感想【ゲーミングイヤホン】 結構長々と書いてしまいましたが、参考になれば幸いです。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/qualification-ap-pass/",title:"【応用情報技術者試験】合格体験記【約30時間で合格】",date:"2021-08-12T00:00:00Z",body:"【応用情報技術者試験】合格体験記【約30時間で合格】 応用情報技術者試験の令和3年度春期試験に合格しましたので、試験の対策・結果・感想などを合格体験記としてまとめたいと思います。 また、基本情報を飛ばして応用情報を受けるのはアリかについて個人的な意見を書きました。 試験概要 応用情報技術者試験は情報処理技術者試験の区分ではレベル3に分類されています。 基本情報よりさらに1つ上のレベルの試験ですね。一般的な資格の中では難関資格ともいわれています。 試験形式と同じく、午前試験と午後試験と別れています。それぞれ小問形式と大問形式で試験時間はどちらも150分間です。合格点は午前・午後の両方で60％以上の正答率が必要です。一見、基本情報とよく似ている形式に思えますが、基本情報とは大きく異なる点があります。 それは、午後が記述式であるという点です。大問が11問出題され、その中から5問（情報セキュリティは必須）を選択し解答します。 記述式であるため解答しづらいことに併せて、問題の難易度も全体的にレベルアップしています。 また、筆記試験であり日時と会場が指定されているので、場所日時に関してもCBT方式の基本情報とは違いますね。 合格までの流れ 次に、受験までの流れと結果を書いていきます。 試験を受けるまで 応用情報については受験を決めたのが基本情報を受けたすぐ後だった記憶があります。 会社からのノルマは達成しましたが、基本情報が筆記試験からCBT方式の試験に変わったことから、どうせ受けられるしと基本情報の上位の試験である応用情報技術者試験（応用情報）を4月に受けました。 「絶対に取ろう！」と思っていた訳では無く、「IT業界なら持っておいた方が得・受験費用も他の2つと同じ5700円である・試験日も4/18と近い」などいった、大したことない理由で受けました。やったことのない記述の筆記試験だったし、秋にもう一回受けようって気持ちの記念受験だったんですね。 上に書いた通りモチベーションはそんなになかったことや、4月から社会人になり前ほど時間が取れなかったこともあり、期間は約2ヶ月と空きましたが勉強量自体は基本情報の時より少なかったと思います。 恐らく総勉強時間は20~30時間くらいですかね。明らかに勉強不足でした。午後の選択問題は事前にある程度分野を絞って決めていました。 試験本番 試験日は日曜だったので家族に車で送ってもらいました。試験会場はデカいホールみたいなところでした。 会場は1000人くらい入る大部屋に机がズラッと並んでいて、大学入試の時を思い出しました。私の席は一番後ろの席だったので、後ろから周りが良く見えたんですが、受験者の年齢層は基本情報よりぐっと上がっていて、社会人風の方が多かったですね。左前の方に座っているおじさんが独り言をブツブツ言ったり、一人で笑ったりしていたのが印象的でした…。ただ、欠席してる机もそこそこいました。午後になるとそれより減って結構空きが見えてました。 午前試験は過去問も多く1時間ちょいくらいで解答し終わったので早めに退出しておにぎりを食べたり休憩してました。また午後の試験になるまで持参した参考書でセキュリティの章を見直してました。 午後試験ではセキュリティ・システムアーキテクチャ・組み込みシステム・情報システム・システム監査を選択しました。本当は情報システムではなくプログラミングを選択する予定でしたが、一見して難しそうだったので、アドリブで情報システムに変えたのですが、それが失敗でした。全然分からなかったので適当に回答してしまいました。 後日、自己採点した時では情報システムは殆ど不正解でした。やっぱプログラミングにしとくべきだったかと後悔。合計点もざっくりと採点して55～58点くらいだったので落ちてると思っていました。 試験結果 下に試験結果を載せます。 応用情報の結果 午前が75点、午後が60点でした。午後が超ギリギリでした…。正直、受かってると思ってなかったのでビックリしましたね。記述問題の部分点とかがあったのかもしれません。こんなんで受かってもいいのか？と思ったかもしれませんが、合格は合格なので気にしないことにします。 応用情報合格への勉強方法 ここから、午前と午後について勉強方法をそれぞれ解説していきます。前提として、基本情報に合格済みかまたは基本情報に合格できる程度の知識量がある人を想定しています。そうでない方は、まず基本情報の勉強から始めることをおすすめします。 勉強時間はどのくらい必要？ ネットで検索すると、応用情報に受かるには未経験からで500時間であるという意見が多いようですね。基本情報を合格する知識があれば、合格するには200時間からというのが一般的と言われていますがどうなんでしょう。 私の意見になりますが、200時間からというのはちょっと盛ってる気がします。私の場合基本情報を持っていて、応用の勉強は30時間くらい（午前午後の比率は半々）しかやってませんでした。本番では午後がギリギリで受かったので、運が良かった部分が大きい気がしますが、基本情報を持っている人は多くて100時間以上勉強すれば十分受かるレベルに達すると思います。 後、午後試験は運が絡んでくるので、単純に勉強時間を増やせば確実に受かるという訳ではない気がします。 午前・午後の勉強時間の配分 午前よりは午後の勉強を重視すべきだと思います。午後は記述なのである程度の慣れが必要です。私も午後の勉強をおろそかにして点が低かったので、もっと午後の問題を解くべきでした。 午前試験で合格点を取れる見込みができたら早めに午後の勉強に取り掛かりましょう。合計で100時間対策に費やすとしたら、午前と午後で40時間:60時間くらいの比率が良いでしょう。 午前試験は過去問道場をやり込む 午前試験に関しては基本情報と同じなのですが「応用情報技術者過去問道場 | 応用情報技術者試験ドットコム」で過去問をひたすら回すのが一番早いです。基本情報と似た問題が多いので、問題にはそれ程詰まらないと思います。そんなに古い過去問を解く必要はないので、直近から10回分くらいを解くのが良いでしょう。正答率は8割くらいを目指して、到達したら午後の勉強をしましょう。 おすすめのテキストについてですが、私は「応用情報技術者 合格教本」を使っていました。以下の記事で詳しい内容について紹介しているので是非参考にしてください。 令和06年【春期】【秋期】 応用情報技術者 合格教本\r3,278円～ amazon.co.jp 関連記事\r【応用情報技術者 合格教本】おすすめの使い方【商品レビュー】 この本は範囲を一通り網羅していることと、見出しごとに午前で出るか午後で出るかマークが書いてあるので分かりやすいです。本番でも持っていき、午後が始まる直前にセキュリティの章を見直してました。 問題を解きつつ、問題の解説でどうしても分からないところがあった時に参考書でそこだけ読む、というやり方がおすすめです。 なお、最初からテキストを読み始めるのは推奨しません。時間が掛かるので非効率です。 午後試験の選択問題と勉強方法 午後試験の勉強を始める前に選択問題を事前に選択しておきましょう。全分野を勉強するのは非効率です。関連記事で主観ではありますが、おすすめな選択問題を紹介します。 関連記事\r【応用情報技術者試験】午後の選択問題のおすすめを紹介 おすすめの勉強方法は過去問演習が一番です。幸い、過去問道場には午後試験の過去問も掲載されています。わざわざ過去問の問題集を買う必要はありません。ここで、過去問は印刷して解いた方がいいです。本番に近い環境でやれるので練習になります。 情報セキュリティと事前に選んだ分野を、少なくとも直近10回分くらいは解いておきましょう。ついでに時間配分も意識しましょう。2時間半で大問5つなので、1つの大問は30分で解けるといいですね。 受験時の注意 続いて、受験時に注意したいことを書きます。 午前試験 解き終わって見直ししたら早めに退出しましょう。実質午後が本番なのでできたら早めに退出して、良さげな休憩場所を確保してご飯を食べて備えましょう。 一通り過去問道場をやっていれば労せず時間内に解き終わります。最後まで試験会場にいる意味はありません。早めに退出できればその分多めに休憩することもできるので、その時間で午後の最終確認などをできれば余裕を持って午後に臨めます。 午後試験 午後試験の注意するポイントは時間配分と問題の選択です。 試験を通して時間配分に気を付けましょう。詰まっても30分経過したらすぐに次の問題にいくことをおすすめします。どうせ大問1つで20点しかないので、選択した問題を全部解かないと点は伸びません。 試験終了する10分くらい前には問題を選択する箇所をちゃんと確認しましょう。選択間違いなどで点を落として不合格になるのは勿体無いです。意外と見落とすのでちゃんと確認することが大切ですね。 基本情報を受けずに応用情報はあり？ ネットでは、「基本情報を受けずに応用情報受かった！」という話を見ることも多いです。実際基本情報を受けずに応用情報を狙っている人はいるかと思いますが、私はアリだと思います。 基本情報はアルゴリズムとプログラミングの配点は50点と非常に高いので、苦手な人にはキツイですよね。 応用情報はプログラミングが必須ではないので、選択問題を文系問題でいけば、合格することは十分可能だと思います。ただ、午前問題への対策に時間が掛かるということがデメリットになりそうですね。午前は基本情報と関わりが深いので、飛ばすとなると午前をしっかり勉強することが必要ですね。 ここまでが応用情報合格攻略法になります。 私が受けた時やって良かったことは、午後の選択問題を事前に決めて勉強したことと、本番の午前で早めに退出したことです。逆に、反省点は勉強する時間が少なかったことです。 ギリギリの合格なのであまり大きいことは言えないのですが、参考になれば幸いです。以上で記事を終わりにします。 参考文献 応用情報技術者試験 | 試験情報 | IPA 独立行政法人 情報処理推進機構"},{url:"/dimzakki-mainroad/qualification-fe-pass/",title:"【基本情報技術者試験】合格体験記【約50時間で合格】",date:"2021-08-11T00:00:00Z",body:"【基本情報技術者試験】合格体験記【約50時間で合格】 基本情報技術者試験を2021年2月に受け合格しましたので、試験の対策・結果・感想などを合格体験記としてまとめたいと思います。 試験の概要 基本情報技術者試験は情報処理技術者試験の区分ではレベル2に分類されています。レベルとしてはITパスポート試験の1つ上の試験ということになります。 試験は科目A試験と科目B試験と別れています。試験形式は選択式で、試験時間は科目A試験は90分間、科目B試験は100分間です。合格点は科目A・科目Bの両方で60％以上の正答率が必要です。 なお、試験の形式は新たに改訂されたものですので、詳細は公式のページ1を参考にしてください。 また、試験はCBT形式で実施されているので、会場を選んで、好きな日時に受験することができます。科目Aと科目Bは続けて受験する必要があり、別日に受験することはできませんので注意してください。 基本情報合格までの流れ 次に、基本情報技術者試験（基本情報）について試験までの流れと結果について書いていきます。 試験を受けるまで iパスに合格した後から、基本情報の勉強をちゃんとやり始めました。基本情報の受験日は2月17日だったので、勉強期間は丁度1ヶ月ですね。 iパスと比べて期間は倍の長さですね。同じく一日1~2時間くらいは勉強したので、総勉強時間は大目に見積もって50時間くらいだと思います。 試験本番 基本情報はCBT方式で、好きな日程に受けられたので平日に受験しました。また、2回受けに行くのは面倒だったので午前試験と午後試験は同日に受けました。試験会場では学生風の受験者に混じってスーツを着たおじさんが何人かいたのが印象的でした。何の資格を受けていたかは分かりませんが…。 午前試験では隣のパソコンで受けてた子が凄い速さでマウスをカチカチクリックしてて、1時間くらいで即退出してたので、私もつられて1時間10分くらいで退出してしまいました。皆さんは早く終わってもちゃんと見直しをしましょう。 午後試験の時間まで1時間程度インターバルが空いていたので、試験会場近くのマックで午後試験の最後の見直しをやってました。（必ず解く予定の情報セキュリティ、アルゴリズム、プログラミング言語（C言語）の内容） 午後試験は100%受かる自信はなかったのでちょっと緊張しましたね。いざ試験が始まると時間に追われるので緊張してたのは試験開始直前まででしたが…。いざ始まってみると、情報セキュリティとアルゴリズムが比較的簡単だったので余裕が持てました。 試験結果 実際に受けるまで自信はあまりなかったのですが、なんだかんだ危なげなく合格できました。 結果を下に載せます。 基本情報の結果（午前） 基本情報の結果（午後） 画質が悪くて申し訳ないです。データがスマホのスクショにしかありませんでした…。午後の問2～問5から2問選んで解答するところは、何が出題されたか公表するのは良くないらしいので、念のため伏せておきます。選択したプログラミング言語はC言語です。 午前が86.25点で、後日送られてきた成績通知書のはがきによると午後が78.00点で合格でした。iパスより好成績ですね。基本情報は筆記試験からCBT方式になって合格率がかなり上がったようなので、その影響かも？ 合格に必要な勉強時間について 次に、合格に必要な勉強時間について私が経験したことをベースに考えていきます。 一般的な意見では100~200時間必要？ ネット検索で調べると、良くある意見として「初学者の場合は100~200時間必要」という主張が多いようです。また「経験がある場合は50時間以上」という話も目にします。 色々なサイトで同じようなことが書かれていますね。これって本当でしょうか? 200時間をゲームに換算すると、そこそこのプレイ時間になります。毎日欠かさず2時間やっても100日（3か月以上）掛かる計算です。正直これはちょっと盛ってると思います。 それともテキストを最初から読むとか非効率なことをやって合計で200時間掛かるという意味でしょうか？ 実際に基本情報に使った時間 私が受けた時はiパスに合格してから基本情報を受けるまでの期間は1ヶ月でした。 プログラミング経験者（C言語が少しできました）だったのでアルゴリズムとプログラミングを対策する時間は浮きました。（1から勉強する時間が浮いたという意味で、過去問演習はちゃんとやっています） 正確に時間を測ってはいませんでしたが、毎日コツコツやってはいました。1日1.5時間はやったと仮定して総勉強時間は45時間程度です。45時間というと短めに見えますね。これにはある理由があります。 比較的短時間で合格することができた理由の1つに「CBT方式の導入による試験の易化」が考えられます。 関連記事\r【基本情報】CBT方式導入から合格率が上がった話【受かりやすい?】 結論 私の40時間という数字をベースに考えてみましょう。プログラミング未経験者として、アルゴリズムと表計算の習得にプラス計50時間使ったとしても100時間掛かりません。 100時間で受かる水準に持っていくとして「初学者は科目A試験で40時間、科目B試験で60時間対策に使えば受かる」というのが私の結論です。 プログラミングができる人はもっと短い時間で合格基準に達するでしょう。私の勉強時間をベースに考えて経験者の場合は、40~50時間が必要な勉強時間だと考えます。 基本情報合格への勉強方法 科目Aと科目Bについてそれぞれ解説していきます。対策の順番は科目A→科目Bの順がおすすめです。先に科目Aをしっかり対策することで、科目Bも楽になるからです。 科目A・Bの勉強時間の配分 勉強する配分はあまり偏らない方が良いと思います。理由として「科目Aをしっかり対策しないと科目Bにも影響する」「科目Bはアルゴリズム・プログラミング言語を対策しないと受からない」の2つが挙げられます。 先程も述べましたが、まず科目Aの対策を終わらせてから科目Bの対策に取り掛かる方法がおすすめです。 科目A試験は過去問道場をやり込む 科目A対策では「基本情報技術者過去問道場 | 基本情報技術者試験ドットコム」で過去問をひたすら回しましょう。過去問道場は無料サイトですが、問題と解説がかなり充実しています。 そんなに古い過去問を解く必要はないので、直近から10回分くらいを解くのが良いでしょう。間違えた問題を復習してできるように理解することが大事です。最終的な正答率は8割くらいを目指しましょう。科目Bの勉強時間を確保するためにも、8割くらいの完成度に達したら次のステップへ移行します。 テキストについてですが、必ずしも合格に必須なアイテムではないと思います。（参考書無しで過去問道場のみで合格している人もいます）しかし、特に未経験者の場合では勉強したことがごちゃごちゃになって整理が難しい部分があるため、知識の整理のために参考書を買うのは悪いことではないです。 私は参考書で「栢木先生の基本情報技術者教室」を使いました。一番評判が良いので、買うとしたらこれがおすすめです。この参考書についての詳しいレビューと使い方は別記事で紹介しています。 令和06年 イメージ＆クレバー方式でよくわかる かやのき先生の基本情報技術者教室\r1,848円～ amazon.co.jp 関連記事\r【栢木先生の基本情報技術者教室】おすすめの使い方【商品レビュー】 科目B試験:選択問題と時間配分を決め方 科目B試験の対策については、別記事にまとめています。 関連記事\r【基本情報技術者試験】科目B試験のおすすめ対策法 受験時の注意 さいごに、受験する際に注意することを書きます。 試験は時間厳守なので早めに行く 当たり前と言ったら当たり前なのですが、私も時間にルーズでギリギリを攻めたくなる人間なので、似たような人のために書きました。 CBT方式なのでよく分からんビルの中が試験会場になったりしていることが多いです。迷ったりするかもしれないので早めに行きましょう。 試験本番で気を付けたいこと 見直しはちゃんとすること。解き終わったら見直しはしっかりしましょう。選択肢のクリックミスや問題の勘違いなどケアレスミスは意外とあります。 しかし、過去問で対策をしっかりした人なら時間内に解き終わる可能性が高いので、早めに終えるのもありです。 また、科目Bは時間配分に注意しましょう。時間が押してるならいったん中断して次にいきましょう。問題ごとの切り替えが大切です。 焦って解けなくなると大変です。冷静に6割以上を確保しに行きましょう。 以上が基本情報合格攻略法になります。 究極的に言えば、科目A・Bどちらも60点丁度でも合格します。言い換えると4割は落とせるので気負わずにいきましょう。自分の実力が発揮できないと合格するのは大変ですからね。 私のやり方が参考になれば幸いです。以上で記事を終わりにします。 参考文献 基本情報技術者試験 | 試験情報 | IPA 独立行政法人 情報処理推進機構 情報処理技術者試験における出題範囲・シラバス等の変更内容の公表について | 情報処理推進機構&#160;&#x21a9;&#xfe0e;"},{url:"/dimzakki-mainroad/qualification-ip-pass/",title:"【ITパスポート試験】合格体験記【約2週間で合格】",date:"2021-08-10T00:00:00Z",body:"【ITパスポート試験】合格体験記【約2週間で合格】 ITパスポート試験を2021年1月に受け合格しましたので、試験の対策・結果・感想などを合格体験記としてまとめたいと思います。 また、基本情報技術者試験を受ける前に、ITパスポート試験を受けるのは有効かどうか、意見を書いています。 試験概要 iパスは情報処理技術者試験の区分では、一番下のレベル1に分類されています。ITを志す人は試験名の通り、この資格をパスポートとしてより上の資格にチャレンジしていきましょうという意味合いがあるようです。 項目 詳細 出題形式 選択問題・CBT方式 出題数 100問 試験時間 120分 合格点 600点以上（1,000点満点） 受験料 7,500円 試験は小問形式（4択問題）の形式の100問となっており、出題範囲はストラテジ・マネジメント・テクノロジの3分野で構成されています。合格点は「全体の正答率60%以上」かつ「各分野で正答率30%以上」の正答率が必要です。試験時間は120分で、試験はCBT方式となっており、好きな日時と会場を選んで受験することができます。 出題範囲はストラテジ・マネジメント・テクノロジと幅広い範囲で一見身構えそうですが、問題1つ1つの難易度自体はそんなに難しくありません。 iパス合格までの流れ 次に、実際の私の受験までの流れと結果を書いていきます。 iパスを受けるまで 2020年の基本情報の試験は新型コロナウイルスの影響により延期され、受験日を選べるCBT方式に変更していたため、21年の2月から3月の間に受験することにしました。逆算してITパスポートを1月に受けることにしました。 大学では卒業研究があったため、試験勉強を始めた時期は10月くらいからです。とは言っても基本情報の勉強を少しだけやった程度で、正月からiパスの対策を本格的に行いました。過去問演出をメインに1日1~2時間くらいは勉強したので、勉強期間は2週間で、総勉強時間は20時間くらいでしょうか。 iパスの試験本番 iパスを受験した日は1月16日でした。CBT方式で、まわりの受験生は高校~大学の学生ばかりでしたね。 試験を受けた感想として、受ける前は「まあ勉強はしたしイケるっしょ（余裕）」な感じで臨みましたが、問題の最初の方に知らない単語（シラバスの新しい内容）ばかり出てきて少し動揺しました。新シラバスの新出内容はほぼ対策してなかったので仕方ないですね。 試験問題の後ろの方は知っている問題が多かったので少し安心し、時間を30分程残して解き終わりましたが、自信の無い問題の見直しなどで試験時間はフルに使いました。 iパスの試験結果 試験の終了と同時に試験結果が表示されました。試験は無事合格でした。スコアレポートが別に見れるので下に載せます。 ITパスポート試験の試験結果 結果は正答率72％で合格でした。この試験の対策は約2週間だけなので余裕なのかと思えますが、出題範囲が被っている基本情報の勉強をしてた上での正答率70％なので微妙ですね…。 ITパスポート合格への勉強方法 ここから、iパス攻略へ向け必要な勉強時間や勉強法などについてまとめていきます。 誰でも受かる試験って本当なの？ よくネット等では「iパスは誰でも受かる！」「落ちる方がおかしい！」みたいな意見を目にすることが多いです。実際のところどうなんだろうと思ってる人はいるはずです。 上の様な風潮は半分正解で半分間違いです。正確にはiパスは勉強すれば誰でも受かるです。タイプとしては自動車免許の学科試験に近いです。あれはいくら頭が良かろうと、勉強してないと普通は解けないですよね。 「ノー勉で受かった」などと言っている人は、元々学校などで情報系の知識を身に着けていたというだけで、知識を持ってない人がノー勉で受かる資格ではないことは認識しておきましょう。 試験に落ちてしまった人はもれなく勉強していないか、効率の悪い方法を取っているかのどちらかです。そして、効率の良い勉強方法は何か？というと、答えは過去問を繰り返し解くことになります。詳しくはこれから説明していきます。 必要な勉強時間はどれくらい? 私の場合、基本情報の勉強は少しやっていた状態で、iパスの対策をしたのは約2週間でしたが合格しました。1日に平均1時間以上は勉強したので、勉強時間は大体20～25時間は費やしたと思います。 上の方で少しプログラミングができると言いいましたが、プログラミングのスキルはこの試験に関係ありません。大学は理系（工学系）でしたが、勉強に対して不真面目だったので殆ど知識0から始めたようなものでした。 つまり、同じやり方で対策すれば、知識0の人でも20～30時間程度で受かるようになります。毎日30分～1時間勉強するとしたら、1ヶ月~2ヶ月くらいの期間で合格ラインに達しますね。 確実に受かる対策法 「ITパスポート試験過去問道場」などの過去問を扱っている媒体で問題をひたすら周回しましょう。過去問道場は無料サイトですが、過去問とその解説がかなり充実しています。 わざわざ試験対策に参考書等のテキストは買わなくていいです。何故なら、参考書を読むより過去問を解いた方が時間も掛からず断然効率が良いからです。 本番の試験でも過去問そのままや類題が多く出るので、合格するには過去問演習が一番です。間違えた問題の解説を理解し、できるまで繰り返し復習して頭に定着させていきましょう。過去問道場の出題範囲で「おすすめ」をチェックして、そこの問題をしっかり解けるようになれば合格は余裕です。合格するには過去問道場で正答率8割くらいは欲しいですね。出題範囲は広く浅いため、出題される問題は全て理解できるように解いていくことを推奨します。 そもそも、私は勉強があまり好きでは無いので、分厚い参考書などは読みたくありませんし、実際読めません。なるべく楽に合格できる方法を取ったらこのやり方に落ち着きました。一見効率が悪いようにも見えますが、これが受かるための一番の方法です。 シラバスの新単語について シラバスとは、iパスの試験範囲の詳細を示した文書のことで、ここから試験問題が出題されます。シラバス自体はIPA（試験を運営している団体）の公式ホームページにも公開されており、誰でも入手することが可能です。シラバスのPDFファイルは公式ページから参照することができます。 このファイルは「これを読めば出題範囲が分かる」という文書ではありますが、結構ボリュームがある文書で、つらつらと用語名が書いてあり、全部読んで理解するとなると大変労力が掛かります。また載っているのは単語ばかりで、単語ごとの意味までは書いていないため、PDFだけ読んでもあまり意味はありません。過去問演習などで単語の意味を理解する必要があります。 この文書に出てくる新出単語は文字通り新しい用語なので、過去問では扱っていない内容であり、単純な過去問演習だけでは触れることのない内容になっています。しかし、シラバスで新しく出た用語は試験本番で出題される可能性が高いので、過去問演習とは別にしっかり抑えておくと得点アップに繋がります。 新単語についても頭に入っていれば得点アップに繋がるので余裕がある人は覚えておきましょう。シラバスの対策については別記事にまとめてあります。 計算問題は捨てずに解くべき 計算問題については、ネットで検索してみると「計算問題は全部捨てて受かりました！」といった記事等がヒットします。しかし、計算問題だからといって無条件に全部捨てるべきではないと思います。 計算問題の中に解き方を知っていれば誰にでも解けるような問題はあります。これらを捨ててしまうのはもったいないです。例えば、簡単な計算問題の例を挙げると「損益分岐点」や「稼働率」の問題は簡単です。これらの問題は解法を覚えておきましょう。 上記の様に、計算問題でも解き方を覚えておけば簡単に解ける問題はいくつかあります。そのような問題はスルーせずに解くことが合格への近道になると思います。 解法を覚えるためには過去問道場などで解いた時に、解説をしっかり読んで理解することが大切です。 試験本番で気を付けること 本番の試験ではいきなり知らない問題が出てくる可能性が高いです。実際に受けた時にも初っ端で知らない問題が出題されました。この試験に限らず、新しい問題は初っ端に出てくる印象があります。 ここで大事なのは焦らないことです。分からない問題は飛ばしていけばすぐに知ってる問題に出くわすので落ち着きます。ちゃんと過去問道場やれば余裕で合格できます！どんだけ過去問道場をやれるかがカギです。 基本情報の前にiパスを受けるのはアリ？ 私見ですが、iパスを基本情報の前に受けることは有効だと思います。このやり方がおすすめなのは、基本情報の午前問題の知識が全くない人です。学校等で情報分野を勉強していて、基本情報の午前問題がある程度解けるという方は、iパスをスルーして基本情報に向けて勉強することをおすすめします。 その理由は、iパスが初級者向けの資格だからです。IT系の知識が全くない人が基本情報を受験するとなったとき、先にiパスを取ることで基本の午前試験への基礎固めになります。逆に言えば、既に一定の知識がある人には必要ありません。 iパスと基本情報は問題が被っていることが多く、基本情報の問題を解く時に「iパスでやったやつだ！」となることが少なくありません。しかし、iパス特有の問題というのも存在するので学んだことが全て活かせる訳ではない、というのは覚えておきましょう。 なので、「基本情報を勉強しているけど内容が難しくて分からない」人は先にiパスからやるのも手です。iパスで身に着けた知識は無駄にはならないと思います。 また、基本情報ではiパスで出てくる計算問題（例えば2進法の計算など）ができないと、基本情報の問題には太刀打ちできません。そうなると合格が非常に厳しいので、iパス対策をする中で出題される計算問題はマスターするようにしたいです。 いざ基本情報の対策を始めた時に、1からやって苦労するよりか、早い内に苦手意識を克服しましょう。 今回はITパスポート試験の攻略方法についてまとめました。受験者の参考になれば幸いです。以上で記事を終わりにします。 参考文献 ITパスポート試験 | 試験情報 | IPA 独立行政法人 情報処理推進機構 【ITパスポート試験】試験内容・出題範囲"},{url:"/dimzakki-mainroad/eclipse-line-problem/",title:"【Eclipse】赤線や緑線が出る問題の原因と解決方法【カバレッジ】",date:"2021-08-09T00:00:00Z",body:"【Eclipse】赤線や緑線が出る問題の原因と解決方法【カバレッジ】 今回はEclipseでソースコードが赤線や緑線でハイライトされる現象に関する備忘録になります。 突然出現した赤と緑のハイライト EclipseはJavaの有名なIDEで、使ってる方も多いと思います。Eclipseは多機能でなんでもできますが、それ故に知らない機能が多すぎて大変ですよね。 以前、Eclipseを使っている時に、ソースコードに赤線と緑線のハイライトが出るようになって困ったことがありました。実際のスクリーンショットが以下になります。 赤と緑の線が出現した時のスクリーンショット ソースコードが赤や緑になって結構見辛いです。見づらい以外に支障はなかったですが、いかんせん不便です。一応、このハイライトが出ている時にソースコードに何か入力すれば消えます。 特に何かやったという記憶はないので原因が分からず、しばらく画面と悪戦苦闘していました。 原因はカバレッジ 色々調べていたら、原因はカバレッジであることが分かりました。 解消方法は「カバレッジ」のタブを開き、「セッションの除去（バツマークのアイコン）」をクリックしたら消えました。小さいので見え辛いですが、以下の画像だと左下の赤枠で囲ったところにバツマークがあります。 「セッションの除去」の場所 どうやらいつの間にかにカバレッジが実行されてたみたいですね。カバレッジというのは使ったことがなかったので全然知りませんでした。これはテストケースを検証する時に使う機能ですね。コードの分岐が網羅されているか色分けで確認することができます。 カバレッジとは\rカバレッジとはテストの網羅率のことを表します。ここでは、緑は「テストが指示を実行したこと」を、黄色は「テストが指示を実行したが、全ての条件が網羅されてないこと」を、赤は「テストが指示を実行していないこと」を指します。\r上の画像で言うと、mainメソッドをまだ実行していなかったので、赤のままになっていたということになります。 カバレッジはalt + shift + E + Jのショートカットで実行される様ですね。気づかずにやってたかもしれません。 当時は、EclipseをJavaの勉強で使っている程度なので、カバレッジ機能は使ったことがありませんでした。開発の仕事でEclipseを使用している方は、単体テスト等で使っていることがあるかもしれませんね。 同じくEclipse初心者で同じ問題で困っている人はいるかも知れないので、お役に立てたら幸いです。以上で記事を終わりにします。 参考文献 Source Code Annotation | Eclipse Help"},{url:"/dimzakki-mainroad/java-fibonacci-sequence/",title:"【Java・JavaScript】フィボナッチ数列を出力する",date:"2021-08-07T00:00:00Z",body:"【Java・JavaScript】フィボナッチ数列を出力する JavaとJavaScriptでフィボナッチ数列を出力してみます。また、フィボナッチ数列と黄金比との比較もしてみます。 フィボナッチ数列とは フィボナッチ数列は以下のような数列のことを指します。 $$ 0,1,1,2,3,5,8,13,21,34,\\ldots $$ この数列 \\(F_{n}\\) は、1番目を \\(F_{0}=0\\) 、2番目を \\(F_{1}=1\\) として、それ以降は1つ前と2つ前の数字を足した数字 $$ F_{n+2}=F_{n}+F_{n+1}\\ \\small(n\\ge0) $$ になります。 ここで、フィボナッチ数列の隣同士の数字の比は、数列の項が後ろになればなるほど黄金比と呼ばれる \\(1\\colon\\frac{1+\\sqrt{5}}{2}\\) に近似されるという特徴があります。 Javaでフィボナッチ数列を出力する では、配列とfor文を使ってフィボナッチ数列を10番目まで出力させてみましょう。今回、配列を出力させるのにArraysクラスのtoStringメソッドを使っています。 フィボナッチ数列の比と黄金比との差も求めてみましょう。sqrtメソッドを使って黄金比を出し、指定した数列の項の比との差を求めます。メソッドについては以下の記事にまとめています。 関連記事\r【Java】sqrtメソッドで平方根（ルート√）を求める方法 実際のコードが以下になります。 FibonacciSequence.java\r1import java.util.Arrays; 2 3public class FibonacciSequence { 4 5 /** フィボナッチ数列を格納する配列 */ 6 private long[] array; 7 8 /** 黄金比 */ 9 private static final double gold = (1 + Math.sqrt(5)) / 2; 10 11 /** フィボナッチ数列の比と黄金比との差 */ 12 private double difference; 13 14 /** 実行用mainメソッド */ 15 public static void main(String[] args) { 16 FibonacciSequence fSequence = new FibonacciSequence(); 17 fSequence.getFibonacciSequence(5); 18 System.out.println(Arrays.toString(fSequence.array)); 19 System.out.println(&#34;黄金比との差:&#34; + fSequence.difference); 20 fSequence.getFibonacciSequence(10); 21 System.out.println(Arrays.toString(fSequence.array)); 22 System.out.println(&#34;黄金比との差:&#34; + fSequence.difference); 23 } 24 25 /** 26 * フィボナッチ数列と黄金比との差を取得 27 * 28 * @param num 出力する数列の長さ 29 */ 30 private void getFibonacciSequence(int num) { 31 if (num &lt; 3) { 32 num = 2; 33 } 34 array = new long[num]; 35 // 配列の1番目と2番目に0と1を格納する 36 array[0] = 0; 37 array[1] = 1; 38 // 3番目以降に1つ前と2つ前の数字を足した数字を入れる 39 for (int i = 2; i &lt; num; i++) { 40 array[i] = array[i - 1] + array[i - 2]; 41 } 42 difference = gold - ((double) array[num - 1] / (double) array[num - 2]); 43 } 44}\r出力結果が以下になります。 出力結果\r1[0, 1, 1, 2, 3] 2黄金比との差:0.1180339887498949 3[0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 4黄金比との差:-0.0010136302977241662\rプログラム上でも、先ほど説明した数列と同じものが出力されたことがわかります。今回は比較のため引数は「5」、「10」の2回出力結果を出しました。出力結果を見ると、数字が大きい程、黄金比との差が小さくなることがわかります。 JavaScriptでフィボナッチ数列を出力する JavaScriptで書いた場合だと以下の様になります。 fibonacciSequence.js\r1function fibonacciSequence(num) { 2 let array = new Array(num); 3 array[0] = 0; 4 array[1] = 1; 5 for (let i = 2; i &lt; num; i++) { 6 array[i] = array[i - 1] + array[i - 2]; 7 } 8 const gold = (1 + Math.sqrt(5)) / 2 9 const difference = gold - array[num - 1] / array[num - 2]; 10}\r入力した数値の長さのフィボナッチ数列と黄金比との差を返すツールのようなものを作成してみました。入力可能数値は最大50となっており、それ以上の数値を入力した場合でも50として計算させています。 計算ツール\r数列の長さを入力（最大50まで）: 計算処理実行 数列: 黄金比との差: 実行結果はJavaのものと同じになることも分かります。 今回はJavaとJavaScriptでフィボナッチ数列を出力してみました。 フィボナッチ数列は自然界にも現れることの多い不思議な数列です。「花びらの枚数」だったり「気管支の枝分かれ」にもフィボナッチ数列と関わりがあるようです。 プログラミングでフィボナッチ数列を表現する問題は、プログラミング初級者向けに良く見られるのでまとめてみました。以上で記事を終わりにします。 参考文献 フィボナッチ数 | Wikipedia"},{url:"/dimzakki-mainroad/qualification-fe-cbt/",title:"【基本情報】CBT方式導入から合格率が上がった話【受かりやすい?】",date:"2021-08-06T00:00:00Z",body:"【基本情報】CBT方式導入から合格率が上がった話【受かりやすい?】 基本情報技術者試験のCBT方式の導入から大幅に上昇した合格率について、試験のデータなどから考察してみます。 関連記事\r【基本情報技術者試験】合格体験記【約50時間で合格】 合格率の高さについて まず、上昇した合格率について試験のデータ（統計情報）から見ていきたいと思います。 合格率の大幅上昇 「情報処理推進機構の統計情報 | 情報処理推進機構」によると、各回毎でバラつきはあるものの、近年の基本情報の合格率は22～28%を推移していたようです。合格者数は12000～15000人くらいを推移しています。 しかし、CBT方式に移行した令和2年試験には48.1%、令和3年試験は40.7%と合格率が20%もアップしています。合格者数もかなり増えていることがわかります。 基本情報技術者試験の合格率の変遷をまとめてみました。 年度 受験者数 合格者数 合格率(合格者数/受験者数) H20年～R1年 - - 22～28% R2年 52,993 25,499 48.1% R3年 85,428 34,734 40.7% R4年 101,620 38,033 37.4% R5年 133,732 57,278 47.1% R6年 101,620 54,501 40.8% 多少の上下はあるものの、CBT方式の導入前より大きく高い合格率となっています。 試験が簡単になったのか 一見すると、20％も合格率が上がったのだから試験が簡単になったんだろうと思われますよね。 実際のところはどうなのでしょうか？私も2月にCBT方式で受験して合格したのですが、今までの過去問と比較しても、問題の難易度自体は過去問と比べて難しい訳では無いという印象があります。 それに加えて、午後試験の改定により試験が総合的に楽になったというのは大きな一因であると思います。 高い合格率の理由を考察してみる 私なりに合格率が上昇した理由を、CBT方式という面から考察してみました。 方式変更の変わり目なので難しい問題を出さなかった 私が受けた感想では、難しい問題は出てなかったという印象です。特にアルゴリズムはやっていた過去問より簡単に感じました。私が解いていた最近の試験のアルゴリズムの方が難しかった気がします。試験方式の変更により、問題難易度を上げることを避けたのではないかと思います。 逆に言えば、合格率が上昇していることから、合格率を下げるために徐々に問題の難易度を上げていく可能性も考えられます。 午後試験の問題数の減少 令和2年の改定により、選択問題の回答数が4問から2問へ減少しました。そのかわりにアルゴリズムとプログラミングの必須問題の配点が上昇しました。 選択問題が少ない分他の対策に掛けられる時間も増え、大問1つにかけられる時間が増えたことにより、点数が取りやすくなったと考えられます。しかし、アルゴリズムとプログラミングの配点が合わせて50点になったので、プログラミング系の問題が苦手な人には厳しい試験になったとも言えます。 応用情報と併願受験ができる 今までの筆記試験での基本情報では、応用情報と受験日は同日なので併願受験が出来ませんでした。 CBT方式に変わったことで、応用情報と並行して受けられるようになり、受験者のレベルが上がったことが合格率の上昇の理由の1つであると思います。 これから基本情報は難化していくか？ 可能性は否定できません…。試験の合格率が下がっているのであり得る話です。更に、新たに試験の出題形式も変更されます。1 しかし、私は基本情報の合格率を下げていくことが正しいとは思えません。多くの受験者は基本情報を取ることがゴールという訳では無いですよね。エンジニアで基本情報を持っているからといって、仕事で大きく優遇されることはあまりないでしょう。 基本情報というのは受かったら応用情報や高度試験へとステップアップするためにあると思っているので、今くらいの難易度でいいのではないかと思ってしまいます。 この記事では基本情報の合格率に着目してみました。最後に言いたいことは、合格率が爆上がりしたということは、IPAのさじ加減でこのまま下がっていくこともあり得るということです。 勉強しなくても受かるというのは勘違いですので気を付けましょう。でも合格率の高さから今が受け時であるのは事実なので、早めにに取得を目指すといいかもです！ 以上で記事を終わりにします。 情報処理技術者試験における出題範囲・シラバス等の変更内容の公表について | 情報処理推進機構&#160;&#x21a9;&#xfe0e;"},{url:"/dimzakki-mainroad/game-ps5-apex/",title:"【DualSense Edge】PS5でApexをプレイした感想【MixAmp】",date:"2021-08-03T00:00:00Z",body:"【DualSense Edge】PS5でApexをプレイした感想【MixAmp】 PlayStation 5で「Apex Legends」をプレイしてPS4と比較した感想と、DualSense Edgeを使用した感想について書いていきます。 PlayStation 5(CFI-2000A01)\r78,800円～ amazon.co.jp PS5の外観 まず、PS5の外箱と外観から紹介していきます。サイズは47×42×17cmとそこそこ大きいです。丁度PS4（CUH-1200A）の外箱も家にあったので、500mlペットボトルと並べて比較してみました。PS4の箱より一回り大きいですね。早速PS5本体を設置してみます。 PS5の外箱 PS5の外観 そして、本体の横と正面からの画像です。 配線とか汚いですがご了承ください。PS5はでかくて置き場所がないので縦置きの横向きにしました。ディスク挿入が出来なさそうな配置ではありますが、自分はソフトはダウンロード版しか買わないので問題なし。 縦置き用スタンドも同梱されているので、スペースが無い人は縦置きが簡単でおすすめですかね。必要な配線も電源コードとHDMIケーブル（＋LANケーブル）とそんなに本数は多くないです。 あと、仕様として〇ボタンと×ボタンの機能がPS4と反対になり、決定とキャンセルが入れ替わっています。PS4でも洋ゲーとかはそうなっているゲームもありましたが、PS5はデフォルトで変わってます。 APEXをプレイした感想 PS4でもプレイしていた「Apex Legends」をやってみました。とは言えこのゲームはあんまりやってなかったのでプチ復帰な感じです。 実際にやってみての良いところと悪いところの感想を書いていきます。 画質がPS4より綺麗でフレームレートも高い 画質はPS4のAPEXより綺麗ですね。フレームレートも60FPS固定（自分は常時59）です。PS4だとたまに50くらいに落ちてしまうことがあるので、PS5はフレームレートが安定してると言えます。 フレームレートが安定しているせいか、敵に弾が当たりやすい感じがします。 PS5の性能的には120FPS出るみたいですが、Apex側が対応してない様です。今後対応版がリリースされるのに期待ですね。 PS4のコントローラーでプレイ可能 自分はPS4純正コントローラーでずっとプレイしているのですが、APEXでもPS4の純正コントローラー（DS4）でプレイ出来ます。PS5にUSBケーブルをつなげる必要がありますが、自分は特に繋いでて困らないので良かったです。 DS4でやりたかった理由は、右スティックにフリーク「KontrolFreek FPSフリーク Vortex」のオレンジ色を付けているので、フリーク付きのコントローラーでやりたかったこと、PS5のコントローラー（DualSense）が壊れやすいという話を知り合いから聞いていたことの2つです。 要するに貧乏性なのでDS4を使いつぶしたいって感じです（笑） ファンの音がすごく静か PS4ではAPEXなどの高負荷のゲームをやるとファンの音が凄かったのですが、PS5は無音です。ほとんど音がしません。 まあFPSをする時にはイヤホンを付けているので体感では違いは分からないのですが、スピーカーでやるゲームとかだと利点になりますね。 コントローラーにマイクミュートのスイッチが付いている これは今まで気付かなかったことなのですが、コントローラーのPSボタンの下に小さくVCのミュートスイッチが付いてます。ボタンを押せばマイクがミュートになるので、マイクのオンオフが簡単で便利ですね。 MixAmpがそのままでは使えない（デメリット） PS5には光ケーブル端子が無いので、HDMIアダプターを買わないとMixAmpの光ケーブルが使えません。仕方ないので、一旦昨日はアンプ無しでやりましたが、無いとなんだか違和感が凄いですね…。音があまり良く聞こえませんでした。折角アンプを持っているので、アダプターも買いたいと思います。 後日、実際にアダプターを購入してPS5に接続してみましたので別の記事にまとめました。 関連記事\r【PS5】MixAmpをASTRO HDMIアダプターで使う方法 感想まとめ MixAmpの接続以外で特に不満に感じたことはありませんでした。後はAPEXで120FPSに対応すればもっと楽しめそうです。 かなり久しぶり（1ヶ月ぶりくらい？）にAPEXをやりましたが楽しかったですね。ランクマいったんですがそこそこ戦えました。糞エイムでも弾が敵に良く当たります。イイ感じに一位になれたので記念にスクショを撮りました。 久しぶりのApexランクマッチ ランクと言っても復帰勢でプラチナランクではありますが、アンプが使えたらもっと上手く立ち回れそうですね。 DualSense Edgeを使用した感想 追記になりますが、背面ボタン付きコントローラーの「DualSense Edge」も購入しましたので、この記事で併せて紹介したいと思います。 【純正品】DualSense Edge ワイヤレスコントローラー(CFI-ZCP1J)\r33,211円～ amazon.co.jp DualSense Edgeの外箱 DualSense Edgeの外観 このコントローラーは純正品ながら、背面ボタンが使えることが一番の特徴ですね。また、ボタンのマッピングやトリガー・スティックの調整が設定できるのも大きな利点だと思います。スティックの交換ができる所もグッド。 ちょっと特殊かもしれませんが、個人的なおすすめの背面ボタンの設定は、背面ボタンにR3・L3を設定することですね。こうすることによりスティック押し込みをする必要がなくなり、スティック寿命を伸ばすことができます。背面ボタンはハーフドーム型が押しやすいかなと思います。 通常コントローラーと比べてのデメリットについてはほぼありませんが、強いて言えば重量が若干増していることぐらいですね。 価格は少し高いものの、通常コントローラーが1万円することを考えると、買う価値は充分にあるかなと思います。もう普通のコントローラーには戻れませんね。 要約すると「PS5とDualSense Edgeが凄い！」という話でした。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/contact/",title:"お問い合わせ",date:"2021-08-03T00:00:00Z",body:"お問い合わせ 当サイトへのお問い合わせページです。以下のお問い合わせフォーム（Googleフォーム）にて受け付けております。 お問い合わせフォーム 以下のフォームからお問い合わせ下さい。 読み込んでいます…"},{url:"/dimzakki-mainroad/privacy-policy/",title:"プライバシーポリシー",date:"2021-08-03T00:00:00Z",body:"プライバシーポリシー 「Dim雑記」（以下「当サイト」）のプライバシーポリシー・免責事項を次の通り記載します。 個人情報の利用目的 当サイトでは、お客様からのお問い合わせ等を通じて、お客様の氏名、メールアドレス等の個人情報をご提供いただく場合があります。 取得した個人情報は、必要な連絡のみに利用させていただくもので、これらの目的以外では利用いたしません。 個人情報の第三者提供 当サイトでは、お客様からお預かりした個人情報を、個人情報保護法その他の法令に基づき開示が認められる場合を除き、ご本人様の同意を得ずに第三者に提供することはありません。 Cookie（クッキー）について Cookie（クッキー）とは、お客様のサイト閲覧履歴を、お客様のコンピュータにデータとして保存しておく仕組みです。 当サイトでは、広告配信やアクセス解析のためにCookieを使用しています。Cookieによりブラウザを識別していますが、特定の個人の識別はできない状態で匿名性が保たれています。Cookieの使用を望まない場合、ブラウザからCookieを無効に設定できます。 また、当サイトは、Amazon.co.jpを宣伝しリンクすることによってサイトが紹介料を獲得できる手段を提供することを目的に設定されたアフィリエイトプログラムである「Amazonアソシエイト・プログラム」の参加者です。 広告配信サービスについて 当サイトでは、第三者配信の広告サービスを利用して広告を掲載しています。 第三者配信事業者は、ユーザーの興味に応じたパーソナライズ広告を表示するためにCookieを使用しています。 アクセス解析ツールについて 当サイトは、Googleが提供するアクセス解析ツール「Googleアナリティクス」を利用しています。Googleアナリティクスは、Cookieを使用することでお客様のトラフィックデータを収集しています。 お客様はブラウザの設定でCookieを無効にすることで、トラフィックデータの収集を拒否することができます。なお、トラフィックデータからお客様個人を特定することはできません。詳しくは「Googleアナリティクス利用規約 | Google」をご確認ください。 免責事項 当サイトは、掲載内容によって生じた損害に対する一切の責任を負いません。 各コンテンツでは、できる限り正確な情報提供を心がけておりますが、正確性や安全性を保証するものではありません。 リンク先の他サイトで提供される情報・サービスについても、責任を負いかねますのでご了承ください。 本ポリシーの変更 当サイトは、法令の制定、改正等により、本ポリシーを適宜見直し、予告なく変更する場合があります。 本ポリシーの変更は、変更後の本ポリシーが当サイトに掲載された時点、またはその他の方法により変更後の本ポリシーが閲覧可能となった時点で有効になります。"},{url:"/dimzakki-mainroad/java-random-number/",title:"【Java】Randomクラスで乱数を生成する【数値・真理値】",date:"2021-07-31T00:00:00Z",body:"【Java】Randomクラスで乱数を生成する【数値・真理値】 JavaのRandomクラスで数値（整数・小数）と真理値の乱数を生成する方法をまとめます。 クラスのインスタンス生成について Randomクラスは乱数を生成するためのクラスです。インスタンスの生成の書式は以下になります。 Randomクラスのインスタンス生成\r1Random random = new Random(); 2Random random = new Random(数値); 3 4// Random random = new Random(10); と同じ 5Random random = new Random(); 6random.setSeed(10);\rコンストラクタの引数に数値を指定することで、その数値をseedとして乱数を生成することができます。これはsetSeedメソッドでseedを指定した場合と同じ意味を持ちます。 int型の乱数を生成する int型の乱数を生成したい時にはnextInt()メソッドが便利です。書式は以下になります。 nextIntメソッドの書式例\r1Random random = new Random(); 2random.nextInt(整数); // 0から&#34;整数-1&#34;以下の範囲で乱数を生成する 3random.nextInt(); // int型の範囲で乱数を生成する\r0も範囲に入るので注意しましょう。0を入れたくない時は、戻り値を+1することで1以上の数値を生成できます。また、数字を入れなかった場合はint型が取り得る範囲での乱数を取得します。 実際に整数を生成してみます。 RandomTest1.java\r1import java.util.Random; 2 3public class RandomTest1 { 4 5 public static void main(String[] args) { 6 7 Random random = new Random(); 8 9 // 0から9の範囲で整数が生成される 10 int num = random.nextInt(10); 11 System.out.println(&#34;0から9の範囲:&#34; + num); 12 13 // 1から100の範囲で整数が生成される 14 num = random.nextInt(100) + 1; 15 System.out.println(&#34;1から100の範囲:&#34; + num); 16 17 // int型が取り得る範囲での乱数を取得 18 num = random.nextInt(); 19 System.out.println(&#34;int型の範囲:&#34; + num); 20 } 21}\r実行結果の一例が以下になります。 出力結果（一例）\r10から9の範囲:0 21から100の範囲:38 3int型の範囲:-1021826723\r整数の乱数が生成されました。 double型の乱数を生成する double型の乱数を生成したい時はnextDoubleメソッドが便利です。書式は以下になります。 nextDoubleメソッドの書式例\r1Random random = new Random(); 2random.nextDouble(); // 0から1.0未満の範囲で乱数を生成する 3 4Math.random(); // 同じく、0から1.0未満の範囲で乱数を生成する\rまた、Mathクラスのrandomメソッドも同じ機能を持ちます。 実際に小数を生成してみます。 RandomTest2.java\r1import java.util.Random; 2 3public class RandomTest2 { 4 5 public static void main(String[] args) { 6 7 Random random = new Random(); 8 9 // 0から1.0未満の範囲で乱数を生成される 10 double num = random.nextDouble(); 11 System.out.println(&#34;0から1.0未満の範囲（Randomクラス）:&#34; + num); 12 13 // Mathクラスのrandomメソッドの場合 14 num = Math.random(); 15 System.out.println(&#34;0から1.0未満の範囲（Mathクラス）:&#34; + num); 16 } 17}\r実行結果の一例が以下になります。 出力結果（一例）\r10から1.0未満の範囲（Randomクラス）:0.2127723545518896 20から1.0未満の範囲（Mathクラス）:0.3652517356882634\r小数の乱数が生成されました。 boolean型の乱数を生成する boolean型の乱数を生成したい時はnextBoolean()メソッドが便利です。書式は以下になります。 RandomTest2.java\r1Random random = new Random(); 2random.nextBoolean(); // trueかfalseを生成する\r実際に真理値を生成してみます。 RandomTest2.java\r1import java.util.Random; 2 3public class RandomTest3 { 4 public static void main(String[] args) { 5 6 Random random = new Random(); 7 8 // trueまたはfalseを生成する 9 boolean b = random.nextBoolean(); 10 System.out.println(&#34;boolean型の乱数:&#34; + b); 11 } 12}\r実行結果の一例が以下になります。 出力結果（一例）\r1boolean型の乱数:true\r真偽値の乱数が生成されました。 数値（整数・小数）と真理値の3種類の乱数の生成方法について紹介しました。以上で記事を終わりにします。 参考文献 Random (Java Platform SE 8 ) | Oracle Math (Java Platform SE 8 )| Math"},{url:"/dimzakki-mainroad/qualification-sg-pass/",title:"【情報セキュリティマネジメント試験】合格体験記【約10時間で合格】",date:"2021-07-30T00:00:00Z",body:"【情報セキュリティマネジメント試験】合格体験記【約10時間で合格】 情報セキュリティマネジメント試験を2021年7月に合格しましたので、試験の対策・結果・感想などを合格体験記としてまとめたいと思います。 受験を決めた時の状況 情報セキュリティマネジメント試験の受験を決めたのは2021年4月の応用情報を受けた後になります。受験した応用情報の手応えがあまりなかったので、次回の再挑戦に備え、何かないかと探していたところでした。そんな時、当試験を前哨戦として受けることにしました。 狙いとしては、応用情報の午後では情報セキュリティの問題の選択が必須のため、この試験でセキュリティ分野の知識を深めるという目的です。また、セキュリティ分野に興味があったことも受験理由の1つでした。 その時のITスキルは以下になります。 ITスキル\r4月から新卒でIT企業に入社したITエンジニア セキュリティ分野に興味あり 基本情報は既に合格済み、応用情報を受験して結果待ち 余談ですが、応用情報の受験前にこの試験を受けたのは正直あまり意味がなかったかなと思います。理由は、応用情報のセキュリティ分野の問題内容はあまりこの試験と似ていませんし、難易度も高いので対策にならないからです。 応用情報の対策法については別記事にまとめてあります。参考にしてみてください。 関連記事\r【応用情報技術者試験】合格体験記【約30時間で合格】 試験概要 情報セキュリティマネジメント試験は、情報処理技術者試験の区分ではレベル2に分類されています。これはITパスポート試験の1つ上、基本情報技術者試験と同レベルになります。アルファベットではSGとも略されています。試験で問われる内容は、試験名の通り、情報セキュリティに特化した出題範囲になっています。 試験内容は私が受験した当時は今と若干形式が異なるため詳細は割愛します。今は、科目A・科目Bと試験が分かれていますが、当時は午前試験・午後試験という名称でした。 現行の合格点は1,000点満点中600点で、現在はIRT方式で採点がなされているみたいですね。当時は2つの試験で60点以上が合格点でした。 合格率は、近年だと50～60%程度ですので、ITパスポート試験と同程度と言えます。 試験までの流れと結果 当時は2つの試験を別日に受けることが可能でしたが、あえて同日に受けました。予約できる会場が電車で家から1時間くらい掛かる場所しか無く、わざわざ受験日を別日にして時間と交通費の負担を増やしたくなかったからです。受験を申し込んだ後に、応用情報の合格発表で合格していることが分かったため、この試験はかなり流して受けました。 正直「（めんどいし）受けなくてもいいかな…」と思ってましたが、既に申し込み済（キャンセルはできない）だったのでお金が勿体なく感じ、とりあえず受けにいきました。勉強時間は過去問演習のみ行い約10時間程度やりました。 試験結果（スコアレポート）は試験後すぐに登録したメールアドレスにメールが届くのでそこから確認できました。以下がスコアレポートになります。 情報セキュリティマネジメント試験の結果（午前） 情報セキュリティマネジメント試験の結果（午後） 午前が74点、午後が77点で合格しました。午前はそこそこ勉強したのに午後より得点が低かった…。 おすすめの勉強法 次に、おすすめだと感じる試験の勉強方法について紹介していきます。なるべく合格に向けて効率的な方法になります。 勉強に使ったもの:テキストは必要なの？ 私がこの試験でやった勉強は「情報セキュリティマネジメント試験ドットコム」での過去問演習だけです。 「この試験で参考書は必要か？」という疑問を持っている人はいるかも知れませんが、この試験に受かることが目的という場合には、参考書を買って読むだけお金と時間の無駄だと思います。もちろん、本質的なセキュリティ知識を深めたいという場合は別です。 という訳で、私は参考書は買ってないのでおすすめな参考書などは分かりません。単に合格したい！という人は下を読んで参考にしてください。 午前試験の対策 とりあえず過去問道場で午前問題だけ回しましょう。解く問題は、令和元年秋期試験～平成28年春季試験の8回分（全400問）がおすすめです。同じ問題も出てくるので、覚える必要のある知識量は400問よりかはいくらか少なくなります。過去問道場にある予想問題は全くやってなかったのですが、本番では特に支障は無かったのでやらなくてもいいと思います。スマホ等で暇なときにちょこちょこやるのがおすすめです。 過去問道場で間違えたところをしっかり解けるようになって、最終的に正答率が8割くらい取れれば午前試験は問題無いでしょう。 午後試験の対策 午後についてはほぼ勉強してませんでした。当日の午前試験後の昼休みに大問2つくらいを流して解いただけです。ぶっちゃけ、午後試験は午前が受かる知識があればただの中学レベルの国語の試験なので、臆する必要は全くありません。 午前の知識の量で、午後の回答難易度が決まるといっても過言ではありません。流石に午後ノー勉に不安がある人は、過去問道場で何回分か解いて慣れておきましょう。ちなみに私は午前と午後両方とも1時間以内に途中退出しました。午前対策をやっておけば、それくらいの難易度であるということです。基本情報を持ってる人は、過去問道場を回せば労せずに受かることでしょう。 試験を受けた感想 試験を受けた感想としては、問題はやはり過去問からの流用が多かったので、勉強のツールは過去問道場だけで大丈夫だと感じました。過去問道場をどれだけ回せるかで合否が決まると思います。また、午後より午前を重点的にやることが大事ですね。 難易度としてはITパスポート試験と変わらないレベルだと感じました。出題範囲もiパスと比べると狭いので、対策もしやすいかなと思います。 受かりたい人は過去問道場をやりまくりましょう！以上で記事を終わりにします。 参考文献 情報セキュリティマネジメント試験 出題内容 | 情報処理推進機構 統計情報｜情報セキュリティマネジメント試験.com"},{url:"/dimzakki-mainroad/qualification-ip-fe-ap-pass/",title:"【IT資格】iパス・基本情報・応用情報を4ヶ月で合格した体験談",date:"2021-07-29T00:00:00Z",body:"【IT資格】iパス・基本情報・応用情報を4ヶ月で合格した体験談 iパス・基本情報・応用情報を2021年にITエンジニア1年目で合格しましたので、それぞれ受けた理由や、勉強時間・試験結果などをまとめます。 IT系資格の受験を始めた理由 私は2021年度の新卒のITエンジニアとしてIT系企業に入社しました。その時のITスキルは以下になります。 ITスキル\r大学は理系（工学系）でプログラミング経験（C言語）は1年程あり IT系の資格は何も持っておらず、資格勉強をしたことは無い 出身大学は理系でしたが、在学中からなんとなくIT系を志望してはいた程度なので、ITに関した資格は何も取っていませんでした。正確には、卒業が大変だったので、そんなことを考える余裕が全くありませんでした。 大学の授業も身につかず、ITの知識もほぼ無い（C言語のプログラミング経験が少しあるくらい）ながらも、なんとかIT業界に就職することができました。 そんな中、内定したIT系企業から私たち新卒社員宛てに「入社するまでに基本情報（基本情報技術者試験）を取得して欲しい。最低限ITパスポートは取っておいて欲しい」とお達しがありました。 当然、資格は何も持っていなかったので、まずITパスポート試験から受けて、入社する4月までに基本情報の合格を目指すというプランを立てました。 iパス合格までの流れ それぞれの試験を受けた時の流れと試験結果を、ITパスポート試験（iパス）から順番に書いていきます。まずはiパスからです。 iパスを受けるまで 2020年の基本情報の試験は新型コロナウイルスの影響により延期され、受験日を選べるCBT方式に変更していたため、21年の2月から3月の間に受験することにしました。逆算してITパスポートを1月に受けることにしました。 大学では卒業研究があったため、試験勉強を始めた時期は10月くらいからです。とは言っても基本情報の勉強を少しだけやった程度で、正月からiパスの対策を本格的に行いました。過去問演出をメインに1日1~2時間くらいは勉強したので、勉強期間は2週間で、総勉強時間は20時間くらいでしょうか。 iパスの試験本番 iパスを受験した日は1月16日でした。CBT方式で、まわりの受験生は高校~大学の学生ばかりでしたね。 試験を受けた感想として、受ける前は「**まあ勉強はしたし大丈夫でしょ」といった感じで臨みましたが、問題の最初の方に知らない単語（シラバスの新しい内容）ばかり出てきて少し動揺しました。新シラバスの新出内容はほぼ対策してなかったので仕方ないですね。 試験問題の後ろの方は知っている問題が多かったので少し安心し、時間を30分程残して解き終わりましたが、自信の無い問題の見直しなどで試験時間はフルに使いました。 iパスの試験結果 試験の終了と同時に試験結果が表示されました。試験は無事合格でした。スコアレポートが別に見れるので下に載せます。 ITパスポート試験の試験結果 結果は正答率72％で合格でした。この試験の対策は約2週間だけなので余裕なのかと思えますが、出題範囲が被っている基本情報の勉強をしてた上での正答率70％なので微妙ですね…。 iパス試験の合格におすすめな対策法などは下の記事にまとめてあります。 関連記事\r【ITパスポート試験】合格体験記【約2週間で合格】 基本情報合格までの流れ 次に、基本情報技術者試験（基本情報）について試験までの流れと結果について書いていきます。 基本情報を受けるまで iパスに合格した後から、基本情報の勉強をちゃんとやり始めました。基本情報の受験日は2月17日だったので、勉強期間は丁度1ヶ月ですね。 iパスと比べて期間は倍の長さですね。同じく一日1~2時間くらいは勉強したので、総勉強時間は大目に見積もって50時間くらいだと思います。 基本情報の試験本番 基本情報はCBT方式で、好きな日程に受けられたので平日に受験しました。また、2回受けに行くのは面倒だったので午前試験と午後試験は同日に受けました。試験会場では学生風の受験者に混じってスーツを着たおじさんが何人かいたのが印象的でした。何の資格を受けていたかは分かりませんが…。 午前試験では隣のパソコンで受けてた子が凄い速さでマウスをカチカチクリックしてて、1時間くらいで即退出してたので、私もつられて1時間10分くらいで退出してしまいました。皆さんは早く終わってもちゃんと見直しをしましょう。 午後試験の時間まで1時間程度インターバルが空いていたので、試験会場近くのマックで午後試験の最後の見直しをやってました。（必ず解く予定の情報セキュリティ、アルゴリズム、プログラミング言語（C言語）の内容） 午後試験は100%受かる自信はなかったのでちょっと緊張しましたね。いざ試験が始まると時間に追われるので緊張してたのは試験開始直前まででしたが…。いざ始まってみると、情報セキュリティとアルゴリズムが比較的簡単だったので余裕が持てました。 基本情報の試験結果 実際に受けるまで自信はあまりなかったのですが、なんだかんだ危なげなく合格できました。 結果を下に載せます。 基本情報の結果（午前） 基本情報の結果（午後） 画質が悪くて申し訳ないです。データがスマホのスクショにしかありませんでした…。午後の問2～問5から2問選んで解答するところは、何が出題されたか公表するのは良くないらしいので、念のため伏せておきます。選択したプログラミング言語はC言語です。 午前が86.25点で、後日送られてきた成績通知書のはがきによると午後が78.00点で合格でした。iパスより好成績ですね。基本情報は筆記試験からCBT方式になって合格率がかなり上がったようなので、その影響かも？ 基本情報試験の合格におすすめな対策法などは下の記事にまとめてあります。 関連記事\r【基本情報技術者試験】合格体験記【約50時間で合格】 応用情報合格までの流れ 最後に応用情報技術者試験（応用情報）を受けた時について試験までの流れと結果書いていきます。 応用情報を受けるまで 応用情報については受験を決めたのが基本情報を受けたすぐ後だった記憶があります。 会社からのノルマは達成しましたが、基本情報が筆記試験からCBT方式の試験に変わったことから、どうせ受けられるしと基本情報の上位の試験である応用情報技術者試験（応用情報）を4月に受けました。 「絶対に取ろう！」と思っていた訳では無く、「IT業界なら持っておいた方が得・受験費用も他の2つと同じ5700円である・試験日も4/18と近い」などいった、大したことない理由で受けました。やったことのない記述の筆記試験だったし、秋にもう一回受けようって気持ちの記念受験だったんですね。 上に書いた通りモチベーションはそんなになかったことや、4月から社会人になり前ほど時間が取れなかったこともあり、期間は約2ヶ月と空きましたが勉強量自体は基本情報の時より少なかったと思います。 恐らく総勉強時間は20~30時間くらいですかね。明らかに勉強不足でした。午後の選択問題は事前にある程度分野を絞って決めていました。 応用情報の試験本番 試験日は日曜だったので家族に車で送ってもらいました。試験会場はデカいホールみたいなところでした。 会場は1000人くらい入る大部屋に机がズラッと並んでいて、大学入試の時を思い出しました。私の席は一番後ろの席だったので、後ろから周りが良く見えたんですが、受験者の年齢層は基本情報よりぐっと上がっていて、社会人風の方が多かったですね。左前の方に座っているおじさんが独り言をブツブツ言ったり、一人で笑ったりしていたのが印象的でした…。ただ、欠席してる机もそこそこいました。午後になるとそれより減って結構空きが見えてました。 午前試験は過去問も多く1時間ちょいくらいで解答し終わったので早めに退出しておにぎりを食べたり休憩してました。また午後の試験になるまで持参した参考書でセキュリティの章を見直してました。 午後試験ではセキュリティ・システムアーキテクチャ・組み込みシステム・情報システム・システム監査を選択しました。本当は情報システムではなくプログラミングを選択する予定でしたが、一見して難しそうだったので、アドリブで情報システムに変えたのですが、それが失敗でした。全然分からなかったので適当に回答してしまいました。 後日、自己採点した時では情報システムは殆ど不正解でした。やっぱプログラミングにしとくべきだったかと後悔。合計点もざっくりと採点して55～58点くらいだったので落ちてると思っていました。 応用情報の試験結果 記念受験的に受けたのですが、その応用情報も予想を裏切りギリギリの点数で運よく合格しました。（まぐれに近い）下に試験結果を載せます。 応用情報の結果 午前が75点、午後が60点でした。午後が超ギリギリでした…。正直、受かってると思ってなかったのでビックリしましたね。記述問題の部分点とかがあったのかもしれません。こんなんで受かってもいいのか？と思ったかもしれませんが、合格は合格なので気にしないことにします。 あとから振り返って「もっとこうすれば良かったなあ」と思うことはいくつかあったので、やった方が良かった試験対策やコツなどは詳細を別記事にしたいと思います。 応用情報試験の合格におすすめな対策法などは下の記事にまとめてあります。 関連記事\r【応用情報技術者試験】合格体験記【約30時間で合格】 振り返ると、1月から4月の約4か月でiパス（CBT）→基本情報（CBT）→応用情報（筆記）を連続で一発合格したということになります。こうしてみると受験のスパンが結構短いなという印象です。試験が暗記系で詰め込みしやすいからできる芸当ですね。 大学生だった時は「学生時代に資格を取るって意識高いなあ」といった感じでしたが、時間がある若い時の自己研鑽は結構大事なことですよね。学生の人は在学中に資格取得や勉強等の自己投資をしておくと、後々役立つと思います。 また、余談ですが7月の始めにも別で申し込んでいた情報セキュリティマネジメント試験にも合格しました。情報セキュリティマネジメント試験の合格におすすめな対策法などは下の記事にまとめてあります。 関連記事\r【情報セキュリティマネジメント試験】合格体験記【約10時間で合格】 その他、合格したIT資格は「IT資格一覧」でも一覧にまとめています。良ければ参考にしてください。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/game-trophy-2021-07-25/",title:"【趣味】ゲームとトロフィーについて語る",date:"2021-07-25T00:00:00Z",body:"【趣味】ゲームとトロフィーについて語る 今回は趣味のゲームとPlayStationのトロフィーについて話していきたいと思います。今までに獲得したトロフィー数も紹介します。 趣味のゲームについて 当サイトの「プロフィール」のページにも書いてある通り、私の趣味はゲーム（PS4・PS5が主）になります。好きなゲームジャンルはFPSやアクションなどです。どちらかというと洋ゲーをプレイする割合が多いです。 FPSは中学生くらいからやり始め、大学を出て就職するちょっと前くらいまでは「Call of Duty」シリーズはかなりやりこんでましたね。それ以外では有名所だと「Apex Legends」なども少しやっていました。当時で言うと、バトロワ系である「Call of Duty: Warzone」なんかはかなりプレイしていた思い出があります。 「Call of Duty: Warzone」の通算戦績 ただ、FPSっていうのは毎日やってないと、あっという間にエイムや反応速度が悪くなるんですよね…。そして、加齢に伴って段々反射神経なども落ちていきます。私は対戦ゲームは勝ちたい派なんで、「仕事でゲームの時間が取れなってきて弱体化」→「ゲームをやるモチベーションが低下」という悪循環に陥ってます。社会人で毎日FPSをやり続けてる人達を尊敬してやみません。 そんな訳で、最近はFPSはあまりプレイしていないです。やっぱり対人要素があるゲームは精神衛生上よよろしくないですね。ただでさえ仕事で疲れているのに、プライベートでも消耗してたまるかと思います。 話は逸れますが、FPSをやりこんでいた時代はいわゆるエンジョイ勢（勝てないけど不満は無く楽しくプレイしてる人達）の気持ちが良く理解できていませんでした。しかし、社会人になった今はなんとなく分かります。上手く言葉で説明できませんが、年齢を重ねる毎に熱中する能力が低下しているんじゃないかと思います。 そんな自分でも、ゲーム自体のモチベが完全に無い訳じゃないです。何年か前からFPSとは別にPlayStation Networkのトロフィーを集めることを続けています。ちなみに、トロフィー収集が好きな人のことをトロファーやトロフィー厨と言ったりします。 トロフィー総獲得数 トロフィー総獲得数を紹介していきます。 総獲得数（2021年07月） まず、2021年07月時点のトロフィー画面を紹介します。 2021年07月時点での総獲得トロフィー数 今現在のトロフィー総数が約3500個で、プラチナトロフィーは62個になります。 トロフィー収集では上には上がいるので私なんかはまだまだですね。『PSNProfiles』（PSNP）というトロフィー獲得情報を登録できる海外のサイトでは、トロフィーのポイント順位が国内で6000位くらいです。とりあえず、5000位以内に入ることをこれからの目標にしています。このサイトでは自分のアカウントのトロフィー履歴とかを細かく見れるのでモチベアップに繋がりますね！ 総獲得数（2023年11月） 2023年11月時点のトロフィー画面を紹介します。 2023年11月時点での総獲得トロフィー数 今現在のトロフィー総数が約4500個で、プラチナトロフィーは80個になります。 PSNProfileでは順位が国内で5100位なので、5000位まであと少しですね。 総獲得数（2025年3月） 2025年3月時点のトロフィー画面を紹介します。 2025年3月時点での総獲得トロフィー数 今現在のトロフィー総数が約5000個で、プラチナトロフィーは93個になります。 あまり大きな進捗はありませんでしたが、PSNProfileの国内順位がギリギリ5000位内に入りました。このままコツコツやっていきたいと思います。 トロファーについて 先ほど、トロフィー集めが好きな人達はトロファーと呼ばれていると書きました。しかし彼らの中にも色々とタイプがいます。 やったゲームのトロフィーは全て取るトロフィーコンプ（トロコン）100％縛りだったり、とりあえず取れる奴だけ取って獲得数を稼ぎたいタイプだったり。獲得するのが高難易度のものばかり狙う猛者もいるようです。 私の場合はどれにも当てはまりません。どちらかというとプレイしたゲームは取れるものは取る100％派ですが、常人には出来ないものや完全にやる気が無くなったものは諦めてます。 トロフィーを取るのが簡単なゲーム（ブーストゲーと言われてます）もジャンル問わずちょこちょこやります。いわゆるクソゲーと呼ばれるゲームも結構やります。しかし、ギャルゲーと言われるような美少女系ゲームは全くやりません。何故かは分かりませんが、そういうゲームがあまり好きじゃないからです。 しかし、ギャルゲーというジャンル自体はトロコンが簡単なゲームが多く、トロファーには好まれるので私みたいな人間は珍しいかもしれませんね。 何故トロフィーを集めるようになったのかは良く覚えてないのですが、トロフィーっていうのはそのゲームをやらなくなった後でも残るんですよね。CoDシリーズなんかは、次の作品が出ればみんなそっちに行く訳で、そのゲームでやったことは自分の中でしか残らない。そういう中で、取ったことが証として残るトロフィー収集が楽しくなってしまったのかもしれません。 トロコンしたゲームについて トロコン（トロフィーコンプ）したゲームは結構ありましたね。簡単なものから高難易度まで幅広いです。あまりにも難しすぎたり、時間が掛かるような作品はやっていませんが…。 トロコンがしんどかった作品はいくつかありましたが、覚えてる物でいうと「Call of Duty: Black Ops 4」ですね。これはマルチプレイモード・バトロワモード・ゾンビモードと色々やらないといけなくて大変だった…。特にバトロワモードの「Blackout」関連のトロフィーの難易度が高く、運要素もありました。 「Call of Duty: Black Ops 4」のトロフィー画像 それと、その前作の「Call of Duty: Black Ops 3」も中々大変でしたね。こちらはゾンビ系のトロフィーがDLCも含めると大量かつ複数人プレイが必須だったのと、キャンペーンの作業量が多く面倒でした…。 「Call of Duty: Black Ops 3」のトロフィー画像 どちらも苦労したので思い出の作品です。 最近仕事を始めてからというものの、あまりゲームできてませんね。そんなに頻繁にゲームを買うわけではないですが、セールで安くなったものを買ったり毎月のフリープレイで積みゲーが段々増えてくるので消化したいですね。定期的にこの記事でトロフィー集めの進捗も紹介したいと思います！以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/java-magic-square-4-4/",title:"【Java】ランダムな4×4の魔方陣を出力する",date:"2021-07-23T00:00:00Z",body:"【Java】ランダムな4×4の魔方陣を出力する Javaを使って4行4列の16マスの魔方陣（1～16の数字を1つずつ使ったもの）をランダムで生成するコードを作成してみました。 魔方陣の概要 魔方陣とは、以下のような縦・横・斜めの全ての列の合計が同じになる数表のことをいいます。今回は1～16の数字を一つずつ使ったものを作っていきます。 下に魔方陣の一例を示します。 $$ \\large\\begin{array}{|c|c|c|c|} \\hline 1 &amp; 14 &amp; 15 &amp; 4 \\\\ \\hline 8 &amp; 11 &amp; 10 &amp; 5 \\\\ \\hline 12 &amp; 7 &amp; 6 &amp; 9 \\\\ \\hline 13 &amp; 2 &amp; 3 &amp; 16 \\\\ \\hline \\end{array} $$ 画像の魔方陣では、縦・横・斜めのどの列も合計が34になっていることが分かります。この性質を利用して、段階を踏みながらこのような表を出力してみます。 魔方陣の性質を利用したコード 「４次魔方陣を求めるプログラム | 大同大学」にあるアルゴリズムを参考にして、Javaで実装してみます。 MakeMagicSquare44.java\r1import java.util.ArrayList; 2import java.util.Collections; 3import java.util.List; 4 5public class MakeMagicSquare44 { 6 7 private static final int MAGIC_SUM = 34; 8 private static final int SIZE = 16; 9 private static final int DIM = 4; 10 11 /** 1から16までを格納するArrayList */ 12 private List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 13 14 /** 完成した魔方陣の数表を格納する配列 */ 15 private int[] array = new int[SIZE]; 16 17 public static void main(String[] args) { 18 MakeMagicSquare44 magicSquare = new MakeMagicSquare44(); 19 magicSquare.execute(); 20 magicSquare.showArray(); 21 } 22 23 /** 魔方陣の作成 */ 24 private void execute() { 25 while (true) { 26 generateList(); 27 initializeCorners(); 28 if (attemptFillMagicSquare()) { 29 break; 30 } 31 } 32 } 33 34 /** listに1～16を格納しシャッフルする */ 35 private void generateList() { 36 list.clear(); 37 for (int i = 1; i &lt;= SIZE; i++) { 38 list.add(i); 39 } 40 Collections.shuffle(list); 41 } 42 43 /** 初期のコーナー要素を設定 */ 44 private void initializeCorners() { 45 array[0] = list.remove(0); 46 array[3] = list.remove(0); 47 } 48 49 /** 魔方陣を埋める試みを行う */ 50 private boolean attemptFillMagicSquare() { 51 return checkCombinationAndFill(0, 3, 12, 15) &amp;&amp; 52 checkCombinationAndFill(0, 15, 5, 10) &amp;&amp; 53 checkCombinationAndFill(0, 3, 1, 2) &amp;&amp; 54 checkCombinationAndFill(3, 12, 6, 9) &amp;&amp; 55 fillLastOne(1, 5, 9, 13) &amp;&amp; 56 fillLastOne(2, 6, 10, 14) &amp;&amp; 57 checkCombinationAndFill(5, 6, 4, 7) &amp;&amp; 58 fillLastOne(0, 4, 12, 8) &amp;&amp; 59 fillLastOne(3, 7, 15, 11); 60 } 61 62 /** 2つの数字が埋まっている列に対して、残りの2つの数字をlistから決定する */ 63 private boolean checkCombinationAndFill(int index1, int index2, int index3, int index4) { 64 for (int i = 0; i &lt; list.size() - 1; i++) { 65 for (int j = i + 1; j &lt; list.size(); j++) { 66 if (array[index1] + array[index2] + list.get(i) + list.get(j) == MAGIC_SUM) { 67 array[index3] = list.remove(i); 68 array[index4] = list.remove(j - 1); 69 return true; 70 } 71 } 72 } 73 return false; 74 } 75 76 /** 3つの数字が埋まっている列に対して、残りの1つの数字をlistから決定する */ 77 private boolean fillLastOne(int index1, int index2, int index3, int index4) { 78 for (int i = 0; i &lt; list.size(); i++) { 79 if (array[index1] + array[index2] + array[index3] + list.get(i) == MAGIC_SUM) { 80 array[index4] = list.remove(i); 81 return true; 82 } 83 } 84 return false; 85 } 86 87 /** 配列を数表形式で出力する */ 88 private void showArray() { 89 for (int i = 0; i &lt; SIZE; i++) { 90 System.out.printf(&#34;%3d&#34;, array[i]); 91 if ((i + 1) % DIM == 0) { 92 System.out.println(); 93 } 94 } 95 } 96}\r実行結果の一例が以下になります。 出力結果（一例）\r1 8 13 11 2 2 5 10 16 3 3 12 7 1 14 4 9 4 6 15\rランダム出力なので実行毎に出力結果が変わります。 魔方陣の性質を利用して順に数字を求めていくことで、比較的簡単に生成することができました。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/java-shuffle-method/",title:"【Java】shuffleメソッドでコレクションをシャッフルする",date:"2021-07-22T00:00:00Z",body:"【Java】shuffleメソッドでコレクションをシャッフルする JavaのCollectionsクラスのshuffleメソッドについて使い方などをまとめます。 shuffleメソッドについて shuffleメソッドとは、Listなどのコレクションをシャッフルするためのメソッドです。内部で生成された乱数を使って、コレクションがシャッフルされます。 shuffleメソッドの書式例\r1Collections.shuffle(List&lt;?&gt; list); 2Collections.shuffle(List&lt;?&gt; list, Random rnd);\r引数はシャッフルしたいコレクションの他、Randomクラスのオブジェクトを第2引数に指定することができます。その場合はシャッフルするための乱数を指定することができます。 また、ランダムに数字を出力したい場合にも、Randomクラスを使うことができます。こちらは数字の範囲を指定して、ランダムに出力させることができますが、数字が重複する可能性があります。 関連記事\r【Java】Randomクラスで乱数を生成する【数値・真理値】 対して、shuffleメソッドはListで指定した数字を1つずつ使った重複しないリストを簡単に作ることができます。また、文字列等もシャッフルすることが可能です。 なお、配列にはshuffleメソッドが使えませんので注意してください。既に配列の中に入っている要素をシャッフルするには、一端ArrayListに配列の中身を取り出す必要があるので注意しましょう。 数値をシャッフルする ArrayListを使って、1から10が格納されたコレクションを作りシャッフルしてみます。 ShuffleTest1.java\r1import java.util.ArrayList; 2import java.util.Collections; 3 4public class ShuffleTest1 { 5 6 public static void main(String[] args) { 7 8 // ArrayListであるlistを宣言する 9 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 10 11 // listに1～10を順番に格納し表示 12 for (int i = 1; i &lt;= 10; i++) { 13 list.add(i); 14 } 15 System.out.println(list); 16 17 // listをシャッフルし表示 18 Collections.shuffle(list); 19 System.out.println(list); 20 21 // listをシャッフルし表示 22 Collections.shuffle(list); 23 System.out.println(list); 24 } 25}\r実行結果の一例が以下になります。 出力結果（一例）\r1[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 2[6, 2, 10, 7, 8, 5, 9, 3, 1, 4] 3[6, 3, 8, 1, 9, 5, 10, 2, 7, 4]\r1～10の数字がシャッフルされていることが分かります。 文字列をシャッフルする 先ほどは数値型のリストをシャッフルしてみました。今度は文字列の配列をシャッフルしてみます。 ShuffleTest2.java\r1import java.util.ArrayList; 2import java.util.Collections; 3 4public class ShuffleTest2 { 5 6 public static void main(String[] args) { 7 8 // listにone,two,three,four,fiveの文字列を格納し表示 9 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 10 list.add(&#34;one&#34;); 11 list.add(&#34;two&#34;); 12 list.add(&#34;three&#34;); 13 list.add(&#34;four&#34;); 14 list.add(&#34;five&#34;); 15 System.out.println(list); 16 17 // シャッフルしたlistを表示する 18 Collections.shuffle(list); 19 System.out.println(list); 20 21 // シャッフルしたlistを表示する 22 Collections.shuffle(list); 23 System.out.println(list); 24 } 25}\r実行結果の一例が以下になります。 出力結果（一例）\r1[one, two, three, four, five] 2[one, two, three, five, four] 3[three, two, five, four, one]\r文字列の配列がシャッフルされていることが分かります。 Randomクラスを指定してシャッフルする 次に、Randomクラスのオブジェクトを第2引数に指定してシャッフルしてみます。 ShuffleTest3.java\r1import java.util.ArrayList; 2import java.util.Collections; 3import java.util.Random; 4 5public class ShuffleTest3 { 6 public static void main(String[] args) { 7 8 // listに1～10を順番に格納し表示 9 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 10 for (int i = 1; i &lt;= 10; i++) { 11 list.add(i); 12 } 13 System.out.println(list); 14 // Randomクラスのインスタンスを生成 15 Random random = new Random(0); 16 // listをシャッフルし表示 17 Collections.shuffle(list, random); 18 System.out.println(list); 19 20 System.out.println(); 21 22 // listに1～10を順番に格納し表示 23 ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;(); 24 for (int i = 1; i &lt;= 10; i++) { 25 list2.add(i); 26 } 27 System.out.println(list2); 28 // Randomクラスのインスタンスを生成 29 Random random2 = new Random(0); 30 // listをシャッフルし表示 31 Collections.shuffle(list2, random2); 32 System.out.println(list2); 33 } 34}\r実行結果の一例が以下になります。 出力結果（一例）\r1[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 2[5, 9, 10, 7, 4, 6, 3, 2, 8, 1] 3 4[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 5[5, 9, 10, 7, 4, 6, 3, 2, 8, 1]\rRandomクラスのインスタンス生成時に、引数に同じ数字を指定する（乱数を生成するのに使うseed値を同じにする）とシャッフルの結果も同じになることが分かります。 shuffleメソッドの使い方でした。以上で記事を終わりにします。 参考文献 Collections (Java Platform SE 8 ) | Oracle Random (Java Platform SE 8 ) | Oracle"},{url:"/dimzakki-mainroad/it-qualification/",title:"IT資格一覧",date:"2021-07-22T00:00:00Z",body:"IT資格一覧 このページは取得したIT資格に関する記事をまとめたページです。 取得したIT資格一覧 2021年以降に受験し合格した試験を情報処理技術者試験とベンダー資格に分けて一覧表でまとめました。 表の資格は受験した日付で並べています。資格名のリンクはタグページに遷移します。 こちらのページは資格を取得し次第、随時更新予定になります。 情報処理技術者試験 情報処理推進機構（IPA）が実施する試験一覧になります。 資格名 受験時期 関連記事 ITパスポート試験 2021/01 【ITパスポート試験】合格体験記【約2週間で合格】 基本情報技術者試験 2021/02 【基本情報技術者試験】合格体験記【約50時間で合格】 応用情報技術者試験 2021/04 【応用情報技術者試験】合格体験記【約30時間で合格】 情報セキュリティマネジメント試験 2021/07 【情報セキュリティマネジメント試験】合格体験記【約10時間で合格】 情報処理安全確保支援士試験 2022/04 【情報処理安全確保支援士】合格体験記【約30時間で合格】 データベーススペシャリスト試験 2024/10 【データベーススペシャリスト試験】合格体験記【約1か月で合格】 ベンダー資格 Oracle・AWS等のベンダー資格の一覧になります。 資格名 受験時期 関連記事 Java Silver SE11 2021/10 【Java Silver】合格体験記【約100時間で合格した勉強方法】 Oracle MASTER Silver SQL 2023/03 【Oracle Silver SQL】合格体験記【約3か月で合格した方法】 AWS Certified Cloud Practitioner 2023/06 【AWS CLF】合格体験記【未経験で約1か月で合格】 AWS Solutions Architect Associate 2023/08 【AWS SAA】合格体験記【約1か月で合格した勉強方法】 Java Gold SE11 2024/06 【Java Gold】合格体験記【約3か月で合格した勉強方法】 Oracle MASTER Silver DBA 2024/08 【Oracle Silver DBA】合格体験記【約2か月で合格した勉強方法】 その他 Oracleの試験を受験する際は、割引価格で申し込む方法があります。以下の記事を参考にしてみてください。 関連記事\r【ORACLE MASTER】試験の申し込みを格安で行う方法【OCJ-P】"},{url:"/dimzakki-mainroad/profile/",title:"プロフィール",date:"2021-07-21T00:00:00Z",body:"プロフィール このページは「Dim雑記」管理人のプロフィール（運営者情報）ページになります。 関連記事\r当サイトについて ページのコンテンツに関しては、随時更新していく予定です。 自己紹介 私の名前（ハンドルネーム）はブログ名にもある通り「Dim」といいます。関東生まれ関東育ちの男性です。 ハンドルネームについてですが、特に深い意味はありません。元々ゲームなどのアカウント名に「Dim」という単語を入れることが多かったので、ブログでもそのままハンドルネームとして使うことにしました。学生時代から使用しているので、もう10年くらい経ちますが、このワードを使い始めた理由は良く覚えてないです…。 プログラミング言語だと、例えばVBで「Dim」というフレーズが配列の宣言で使われていますが、こちらとの関係性は全く無いです。（誤解を与えていたらすみません…） 職業・スキルについて 学歴は大卒（理系の学部卒）で、大学では電気・電子工学を専攻していました。プログラミングに関しては、大学時代にC言語を触れたのが初めてです。 2021年からIT系企業にITエンジニアとして勤務しており、主にWebシステムの開発に携わっています。業務では、バックエンドではJavaやC#、フロントエンドではHTMLやJavaScript、データベースでSQLなどバックエンドからフロントエンドまで幅広く経験しています。 転職経験もあり、いわゆるSES（客先常駐）でのシステム開発も経験しました。現在は自社開発系の会社で勤務しています。 これまで取得したIT資格については、Java Goldやデータベーススペシャリストなど色々とありますが、以下のページに詳細をまとめております。 関連記事\rIT資格一覧 趣味について 当サイトでは、技術記事以外にも、趣味に関する記事も書いていきたいと思うので、私の趣味についてもざっと触れていきます。 主な趣味はゲームで、PlayStationがメインにやっています。ジャンルはFPSなどのシューティングゲームやアクション系が中心になります。ソシャゲ系のゲームはあまりやっていませんが、「プロ野球スピリッツA」をやっています（ヤクルトファンです）。 最近はAndroidアプリを個人開発することにも興味があり、マイペースに進めています。 連絡先 当サイトへのお問い合わせにつきましては、以下のページのお問い合わせフォームにて受け付けております。 関連記事\rお問い合わせ"},{url:"/dimzakki-mainroad/about/",title:"当サイトについて",date:"2021-07-21T00:00:00Z",body:"当サイトについて このページでは当サイトについて、内容や目的を紹介したいと思います。 ページのコンテンツに関しては随時更新していく予定です。 当サイトの内容 当サイトはITエンジニアが運営する雑記ブログです。サイトは2021年7月に開設しました。私のプロフィールについては、以下をご覧ください。 関連記事\rプロフィール ブログでは、以下のようなジャンルの記事を書いています。 扱うジャンル\rプログラミングなどのIT技術に関する記事 IT系の資格に関する記事 その他、趣味などの雑記記事 主にプログラミングに関する備忘録的な記事が多いですが、一部ITと関係のない雑記もあります。 ブログを始めたきっかけ 当ブログは「書いてみたプログラミングのコードをアウトプットしてみたい！」という思いから始まりました。 社会人になりITエンジニア職に就職したことで、初めてJavaに触れることになりました。その過程で、色々考えて作ったコードや資格勉強の内容をどこかにアウトプットしてみたく、思い切ってブログを始めてみることにしました。 また、ITエンジニアという職業は仕事を続けている間、日々進化する技術に対して勉強も続けていかなければ取り残されてしまいます。その勉強のモチベーション維持の為に、プログラミングなどを学ぶ中で、ネット等で得た知識等を忘備録として残したいという目的もあります。 個人ブログにした理由 次に、アウトプット先を個人ブログにした理由についても書いていきます。 当初、当サイトは、ドメイン取得サービスで独自ドメインを取得し、レンタルサーバーを借りてWordPressのサイトを運営していました。 今は運営費用・サイト速度・セキュリティの面から方針を変え、静的サイトジェネレーターであるHugoをAWSでホスティングして運営しています。また、ドメインもAWSに移管しました。 確かに、ITに関するアウトプットだけをやりたいなら、わざわざブログを開設しなくてもQiitaやZennなどのコミュニティサービスを使えば手間が掛かりませんが、敢えて個人ブログを選択しました。 何故、わざわざ個人ブログを開設したのかというと、アウトプットを始めるなら趣味を含めた色々な分野についても書いていきたいと思ったからです。それに一番適していたのが、雑記形式の個人ブログでした。また、Webサイトを自分で立ち上げ運営することで、ITへの知見を深めたいという目的もありました。 ブログを運営するメリット 実際に雑記ブログを運営してみて、ITエンジニアにとってブログの開設・運営にはメリットが多いと感じました。そのことについても詳しく書いていきます。 ブログ運営はコスパが良い 趣味というものは、本格的にやるとなると、なんだかんだ費用が掛かるものです。ブログ運営は「サーバー代やドメイン代などでお金が掛かるのでは？」というイメージがあるかもしれません。 しかし、実際にブログを運営してみて気づいたのですが、実はブログ運営ってそんなにお金が掛からないんですよ。要は、個人ブログ程度なら安いサービスを使えばいいのです。 初代のサイトではレンタルサーバーの安いプランでWordPressを使っていました。ドメイン代はキャンペーンでサーバーを維持している間は無料なので費用は0円でした。つまり、運営するに当たっての出費はサーバー代だけでした。年間でも5,000円以下の費用で運営できていました。WordPressのテーマも、無料のものを選べば費用は0円です。 今はAWS上で運用していて、構築するのはWordPressと比べると少し難しいですが、掛かる費用は更に削減できています。詳細は以下の記事にまとめています。 関連記事\r【Hugo】WordPressブログをHugo・AWSに移行した それに、Googleアドセンス等の広告を載せれば、多少の還元はあるので更にコスパが良くなります。当サイトは収益を稼ぐことを第一目的とはしていませんので、広告を多少載せている程度ですが、それでも運営に掛かる費用以上の収入は発生しています。逆に言えば、儲かる副業にはしにくいと思います。 勉強のモチベーションになる ブログに記事を書くこと（アウトプットする）によって、勉強に対してのモチベーションを維持することができました。例えば、私はIT資格をいくつか取っていますが、ブログ記事にすることが、資格の勉強をするモチベーションの1つになっていたと感じています。 また、アウトプットの1つは小さいものでも、少しずつ積み上げていくことによって、コンテンツを育てられるのも、ブログの大きな強みだと思います。 プログラミングは文字媒体の発信と相性が良い 今流行の趣味としてはYouTube等の動画作成・配信があります。それによって、ブログは時代遅れだという風潮もありますね。しかし、プログラミングに関するアウトプットにおいて、動画がブログを駆逐するといった状況は、すぐには来ないと思います。 何故なら、プログラミングを調べる人はコードをコピペしたいからというのが大きいと思います。動画からテキストをコピーしてくるのは大変ですので、どうしてもテキスト形式のWebサイトが優先されやすいです。 つまり、プログラミングに関しては動画を作るよりブログを書いた方が見られやすいと思います。 ここまで、ブログの内容や目的などについてまとめました。これからは少しずつブログを育てていって、趣味にしていきたいと思います。以上で記事を終わりにします。"},{url:"/dimzakki-mainroad/adsense-copycontents/",title:"【Google AdSense】有用性の低いコンテンツ落ちから3回目で合格した話",date:"0001-01-01T00:00:00Z",body:"【Google AdSense】有用性の低いコンテンツ落ちから3回目で合格した話 Google AdSenseの有用性の低いコンテンツ落ちから合格するために行った対処方法と、特に合格するのに重要だと感じたことを書いていきます。 Webサイトにアドセンスを置く目的 Webサイトを運営する人達は、Google AdSenseの合格を目指すことが多いと思います。何故かと考えてみると、結局ブログの運営目的というのは「多くのユーザーに自分のページを見てもらうこと」に帰結するからだと思います。 確かに、Webサイト運営自体は無料でもできます。しかし、ある程度アクセスしてもらうには独自ドメインの取得だったり、有料サーバーを借りたりなどをしないと厳しいところもあります。折角、Webサイトを運営するからには、多少の利益があるとモチベに繋がるものだと思います。 しかし、Google AdSenseに合格するのは結構難しいです。 当ブログのアドセンスの審査期間 当ブログでは、これまでグーグルアドセンスに2回落ち、3回目で合格しました。 アドセンスの合格通知 不合格理由は2回とも「有用性の低いコンテンツ」でした。3回も審査するとなるとトータルでの時間もかかり大変でしたが、その分、審査が通った時の喜びは大きいものでした。 ここで、アドセンス審査に申し込んだ日と結果が返ってきた日を、サイト全体の記事数と併せてそれぞれまとめてみます。 審査回数 結果 審査依頼日 結果通知日 記事数 1回目 不合格 8/18 9/7 40 2回目 不合格 9/8 9/14 50 3回目 合格 9/14 9/20 30 1回目の審査は3週間掛かりましたが、2回目と3回目は1週間くらいでした。3回目の審査では、いくつかの記事を下書きに戻すことでサイト全体の記事数を減らしました。 2回目の審査の時にはあまり対処を行わずに審査の申し込みをしたので、3回目の審査時に行った対策が功を奏したということになります。 「有用性の低いコンテンツ」とは まず、「有用性の低いコンテンツ」とは一体何でしょうか。アドセンスの不合格通知では、具体的にどこが問題かを教えてくれないため、自分で判断しなければなりません。 「有用性の低いコンテンツ」は何を表すかを端的に言うと、「既に似たような記事がネット上に存在するコンテンツ」ということです。 つまり、合格するためには「オリジナリティがある記事を増やす」ことと、「似たような内容の記事を減らす」ことが重要です。基本的に、既にネットにある内容は評価されづらいです。 「有用性の低いコンテンツ」の対処法 具体的な対処法について、実際に当ブログで行ったことを書いていきます。ここから紹介する方法は、基本的な対策を実施済みの方向けになります。 基本的な対策というのは、例えばお問い合わせフォームやプライバシーポリシーの設置などについてです。これらは他サイトの記事でも多く取り上げられているのでここでは割愛します。 1. 有用性が低い記事を非公開にする これが一番重要な対処法だと思います。不合格の心当たりが思いつかない方は、是非やることをお勧めします。やるべき理由は、グーグルアドセンスの審査では「有用性が低い記事が一定以上含まれていたら不合格」になるからです。 実際に当サイトでは、有用性が低いと思われる記事を非公開にしたこと（残った記事本文の加筆修正はほとんどしなかった）で合格したので、「有用性が低い記事」が審査の足を引っ張っていると考えられます。 当サイトでは、3回目の審査直前に公開済みの記事が50記事以上あったので、有用性が低いと思われる記事（オリジナリティが無い記事）を20記事程下書きに戻して30記事まで減らしました。 調べた限り、他サイトでは10記事程度でも合格する例は見受けられたので、オリジナリティに自信があるものだけを残して10記事くらいまで減らしても良いと思います。 ここで一番大切なのは「有用性が低い記事はどうやって判断するのか」ということです。厳密な答えはGoogle AdSense側しか知らないことではありますが、私が実際に行った判断基準を紹介します。 その方法とは、記事タイトルでグーグル検索して、一番上に出てこない記事は下書きに戻すというやり方です。 自分の記事が一番上に出てこないということは、もっと評価されている記事が他にあるということなので、グーグル的に価値が無いコンテンツと判断される可能性が高いです。そのような記事は一旦下書きに戻しましょう。 下書きに戻した後でGoogle Search ConsoleでURLの削除を行いましょう。この工程を行わないと検索エンジン的に記事を消したことになりません。Google Search Consoleの場合だと「削除」から下書きに戻した記事の削除リクエストをしておきます。申請に受かった後は削除リクエストを取り消しましょう。 2. アイキャッチ画像とカテゴリを見直す これについては審査にそれほど関係は無いと思いますが、アイキャッチ画像を記事毎に自作したものを設定しました。アイキャッチは今までカテゴリ毎に共通の画像を使いまわしていて、これだと利便性に欠けるかなと思い、デザインツールの「Canva」で画像を作って差し替えました。また、カテゴリにおいても余分なものがいくつかあったので減らしました。 これらはサイトの見やすさや使いやすさに繋がっていくので、後々のことを考えておくと早めにやっておくと良いと思います。 3. パーマリンクを分かりやすいものへ変更する パーマリンクについても今までは数字を使ったものを使用していましたが、分かりやすさを考慮してカスタムなパーマリンクに変更しました。 これもそれほど審査には影響してないかと思います。 その他のアドセンス審査の疑問点 続いて、上記の対策以外で、審査に関しての疑問点とそれについての考えをまとめます。 アフィリエイトリンクは消す必要があるのか 当サイトでは「もしもアフィリエイト」を使ってAmazonと楽天のアフィリエイトリンクを設置していますが、特に対処せずそのまま申請して合格したのであまり関係無いと思います。 とはいえ貼っていた記事は5記事くらいだったので、多くの記事に大量に貼っている方は消した方が良いでしょう。 審査は間隔を空ける必要はあるのか 私の場合、不合格通知が来た後に直ぐ再審査の申し込みを行っています。それでも合格したので、何日か置かなくても合格はするようです。だだし、余りにも連続して申請すると弾かれる場合があるので気を付けましょう。 今回は「有用性が低いコンテンツ」に対して行った対策をまとめました。やはり、振り返ってみても有用性が低い記事を下書きに戻すことが一番大事なことだと思います。 また、Google AdSenseの審査でお困りの方は「Google AdSense のヘルプ コミュニティ」という公式のコミュニティが存在するのでそこで相談するのも手です。一般ユーザーが回答者として質問に回答してくれる形式で、他人の質問でも参考になることが多いです。 Google AdSenseの審査でお困りの方は上記のことを是非試してみて下さい！以上で記事を終わりにします。 参考文献 Google AdSense のコンテンツとユーザー エクスペリエンス | Google AdSense ヘルプ"}]</script></body></html></div><aside class=sidebar><div class="widget-categories widget content"><h4 class=widget__title>管理人</h4><div><img class=profile-icon src=/images/prof-icon.webp alt=プロフィールアイコン width=100px></div><p class=profile-name><b>Dim</b></p><p class=profile-detail>サイト管理人の<b>Dim</b>です。<br>ITエンジニアをやっています。プログラミングやIT資格についての投稿が多いです。<br>プロフィールは<a href=/profile target=_blank>こちら</a>になります。</p></div><div class="widget-recent widget"><h4 class=widget__title>人気記事（1週間）</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/java-localdate-addition-subtraction/ target=_blank>【Java】LocalDateクラスで日付を加算・減算する方法<span class=ranking-pv>87PV</span></a></li><li class=widget__item><a class=widget__link href=/java-int-string-change/ target=_blank>【Java】int型⇔String型の変換【推奨方法】<span class=ranking-pv>79PV</span></a></li><li class=widget__item><a class=widget__link href=/product-review-monitor-arm-desk/ target=_blank>幕板付きの勉強机にモニターアームを設置する方法【商品レビュー】<span class=ranking-pv>73PV</span></a></li><li class=widget__item><a class=widget__link href=/eclipse-line-problem/ target=_blank>【Eclipse】赤線や緑線が出る問題の原因と解決方法【カバレッジ】<span class=ranking-pv>62PV</span></a></li><li class=widget__item><a class=widget__link href=/java-tochararray/ target=_blank>【Java】toCharArrayメソッドで文字列を配列に分割する<span class=ranking-pv>54PV</span></a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>カテゴリー</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/dimzakki-mainroad/categories/it-qualification/>IT資格</a>&nbsp;
<span class="widget__counter widget__counter--bubble">26</span></li><li class=widget__item><a class=widget__link href=/dimzakki-mainroad/categories/tech/>技術記事</a>&nbsp;
<span class="widget__counter widget__counter--bubble">54</span></li><li class=widget__item><a class=widget__link href=/dimzakki-mainroad/categories/notes/>雑記</a>&nbsp;
<span class="widget__counter widget__counter--bubble">14</span></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>タグ</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/android/ title=Android>Android (3)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/aws/ title=AWS>AWS (4)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/c/ title=C>C (3)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/c-sharp/ title=C#>C# (4)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/closedxml/ title=ClosedXML>ClosedXML (2)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/docker/ title=Docker>Docker (2)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/eclipse/ title=Eclipse>Eclipse (1)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/github/ title=GitHub>GitHub (4)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/hugo/ title=Hugo>Hugo (7)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/java/ title=Java>Java (31)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/javascript/ title=JavaScript>JavaScript (5)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/kintone-api/ title="Kintone API">Kintone API (2)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/kotlin/ title=Kotlin>Kotlin (3)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/node.js/ title=Node.js>Node.js (1)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/php/ title=PHP>PHP (1)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/svn/ title=SVN>SVN (1)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/vb/ title=VB>VB (4)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/vmware/ title=VMware>VMware (1)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/windows-forms/ title="Windows Forms">Windows Forms (1)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/wordpress/ title=WordPress>WordPress (5)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/blog/ title=ブログ運営>ブログ運営 (13)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/review/ title=商品レビュー>商品レビュー (10)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/passing-experience/ title=合格体験記>合格体験記 (13)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/ip/ title=ITパスポート試験>ITパスポート試験 (4)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/fe/ title=基本情報技術者試験>基本情報技術者試験 (8)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/sg/ title=情報セキュリティマネジメント試験>情報セキュリティマネジメント試験 (3)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/ap/ title=応用情報技術者試験>応用情報技術者試験 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/sc/ title=情報処理安全確保支援士試験>情報処理安全確保支援士試験 (2)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/db/ title=データベーススペシャリスト試験>データベーススペシャリスト試験 (2)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/aws-clf/ title="AWS CLF">AWS CLF (3)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/oracle-silver/ title="Oracle Silver">Oracle Silver (5)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/aws-saa/ title="AWS SAA">AWS SAA (3)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/java-silver/ title="Java Silver">Java Silver (4)</a>
<a class="widget-taglist__link widget__link btn" href=/dimzakki-mainroad/tags/java-gold/ title="Java Gold">Java Gold (3)</a></div></div><div class="widget-recent widget"><h4 class=widget__title>最近の投稿</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/dimzakki-mainroad/kintone-api-action-hidden/>【kintone API】アクションボタンを非表示にする方法</a></li><li class=widget__item><a class=widget__link href=/dimzakki-mainroad/assembly-getexecutingassembly/>【Visual Studio】ファイルを埋め込みリソースとして読み込む際の注意点</a></li><li class=widget__item><a class=widget__link href=/dimzakki-mainroad/android-getlaunchintentforpackage/>【Android】インストール済みの起動可能なアプリを取得する</a></li><li class=widget__item><a class=widget__link href=/dimzakki-mainroad/kintone-api-get-set-record/>【kintone API】レコードの値の取得・変更時の注意点</a></li><li class=widget__item><a class=widget__link href=/dimzakki-mainroad/android-room-primary-key/>【Android】Roomの主キーを複数設定する方法</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>アーカイブ</h4><div class=widget__content><select onchange="location.href=value"><option>月を選択</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2025/07>2025/07 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2025/06>2025/06 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2025/05>2025/05 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2025/04>2025/04 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2025/03>2025/03 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2025/02>2025/02 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2025/01>2025/01 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2024/12>2024/12 (2)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2024/11>2024/11 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2024/10>2024/10 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2024/09>2024/09 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2024/08>2024/08 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2024/07>2024/07 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2024/06>2024/06 (2)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2024/05>2024/05 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2024/04>2024/04 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2024/03>2024/03 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2024/02>2024/02 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2024/01>2024/01 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2023/12>2023/12 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2023/11>2023/11 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2023/10>2023/10 (2)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2023/09>2023/09 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2023/08>2023/08 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2023/07>2023/07 (4)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2023/06>2023/06 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2023/05>2023/05 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2023/04>2023/04 (2)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2023/03>2023/03 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2023/02>2023/02 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2023/01>2023/01 (3)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2022/12>2022/12 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2022/11>2022/11 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2022/10>2022/10 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2022/09>2022/09 (2)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2022/08>2022/08 (3)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2022/07>2022/07 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2022/06>2022/06 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2022/05>2022/05 (3)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2022/04>2022/04 (4)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2022/03>2022/03 (2)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2022/02>2022/02 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2022/01>2022/01 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2021/12>2021/12 (1)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2021/11>2021/11 (2)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2021/10>2021/10 (3)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2021/09>2021/09 (8)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2021/08>2021/08 (10)</option><option value=https://dim0000.github.io/dimzakki-mainroad/archives/2021/07>2021/07 (6)</option></select></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__links><a class=footer__link href=/dimzakki-mainroad/privacy-policy>プライバシーポリシー</a></div><div class=footer__copyright>&copy; 2025 Dim雑記.
<span class=footer__copyright-credits>このサイトは <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> と <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> テーマで生成されています。</span></div></div></footer></div><script async defer src=/dimzakki-mainroad/js/menu.js></script></body></html>