---
title: 【Java Silver SE11】試験対策用備忘録メモ【黒本ベース】
description: この記事はJava Silver SE11の受験にあたって、自分用にややこしかった点を備忘録としてまとめたメモです。全ての事項を網羅してる訳では無く、個人的に分かりにくかったところをピックアップしています。
date: 2021-09-23
categories: 
  - IT資格
tags: 
  - Java Silver
  - Java
archives: 
  - 2021/09
thumbnail: /images/java.webp
---

この記事は**Java Silver SE11**の受験にあたって、自分用にややこしかった点を備忘録としてまとめたメモです。全ての事項を網羅してる訳では無く、個人的に分かりにくかったところをピックアップしています。

<!--more-->

なお、内容のカテゴライズは、Java Silverの参考書である「{{< product_link id="4295007625" type="text" >}}」（黒本）の章に準拠しまとめました。内容については、随時更新予定です。

{{< box "関連記事" >}}
<ul>
<li>{{< ref "/qualification-javasilverse11" >}}</li>
<li>{{< ref "/javasilver-se11-application" >}}</li>
</ul>
{{< /box >}}

## 第1章:Javaの特徴とJavaプログラムの作成

### Javaの特徴

* Javaのデータには**参照型**と**基本データ型**がある

### Javaの開発環境

* Java SE11での開発環境の変更点
  * AppletおよびWeb Startが削除された
  * 32ビットWindows版バイナリが提供されなくなった

### クラスのインポート

{{< code lang="java" title="import文" >}}
import パッケージ名.*;
{{< /code >}}

* `import文`を使用してインポートが必要となるクラス
  * 自クラスとは異なるパッケージのクラス
  * `java.langパッケージ`以外のパッケージのクラス

### パッケージ

{{< code lang="java" title="パッケージ" >}}
package パッケージ名;
{{< /code >}}

* パッケージの目的は、**名前空間の提供**・**アクセス制御**・**クラスの分類**の3つ
* 他パッケージのクラスを利用する場合、`import文`を定義し、利用するクラスのインポートを行うこと、利用するクラスが`publicクラス`であることが必要
* パッケージ宣言されていない**無名パッケージ**（デフォルトパッケージ）のクラスは同じ無名パッケージのクラスからしかアクセスできない

### mainメソッド

* 処理を始めるメソッドのことをエントリーポイント（`mainメソッド`）という
  * 引数名以外は変更できない
  * `public`と`static`をつける

{{< code lang="java" title="mainメソッド" >}}
public static void main(String[] args) {// {String... args}も可能
  // 処理
}
{{< /code >}}

### Javaコマンド

* Javaプログラムを実行するには`Javaコマンド`を使う

{{< code lang="bash" title="Javaコマンド" >}}
java Sample
java Sample.java
{{< /code >}}

## 第2章:基本データ型・文字列操作

### 識別子の命名規則

* **識別子**（変数名）は予約語を使えない
  * `default`、`if`など
* 識別子は数字から始められない
* 識別子で記号はアンダースコア`_`と通貨記号`$`のみ使える

### 整数リテラル

* アンダースコア`_`は先頭と末尾と記号の前後にはつけられない

{{< code lang="java" title="整数リテラル" >}}
int a = 123_456; // OK
int b = _123; // NG
{{< /code >}}

### int型

* `int型`での10進数以外は以下の様に表す

|進数|接頭辞|
| :---: | :---: |
|2進数|`0b...`|
|8進数|`0...`|
|16進数|`0x...`|

### var型

* `var型`では、データ型を特定できないものはコンパイルエラーになる
  * 配列の初期化式もエラーになる

{{< code lang="java" title="var型" >}}
var a; // エラー
var b = {1,2}; // エラー
{{< /code >}}

* `var型`はローカル変数のみ使える
  * フィールド変数や引数変数には使えない
* `var型`は変数を同時に宣言できない

{{< code lang="java" title="var型" >}}
var a = 1, b = 2; // エラー
{{< /code >}}

### StringBuilderクラス

* `StringBuilderクラス`のオブジェクトは参照情報になるため、比較しても同一の参照値が参照される

## 第3章:演算子・判定構造

### 型変換

* `byte型`は-128~127の範囲を扱う
* 浮動小数点数は`double型`がデフォルト

{{< code lang="java" title="float型" >}}
float f = 1.0; // floatだとコンパイルエラーになる
{{< /code >}}

### 同値性と同一性

* **同値性**はインスタンスは異なるが同じ値をもっていること
  * `new演算子`を使う時は新しいインスタンスが作られる
* **同一性**は同じインスタンスを参照していること

### switch文

* `case式`の特徴
  * `case`で指定できるのは定数式
  * `long`・`double`・`float`・`boolean型`は`case式`に使えない
  * `case値`は`final宣言`された変数かリテラルを使う
  * `break文`がないとその下の`case`と`default`も実行される

## 第4章:制御構造

### for文

* `for文`の初期化文に複数の変数を宣言するときは、同じ型でなければならない
  * 初期化文内で宣言した変数は`for文`の外では使えない
* 条件文を複数書くときは論理演算子（`&&`・`||`）で記述する
  * カンマ`,`は使えない

### do-while文

* `do-while文`で`do`の中カッコ`{}`を省略した場合、その下には1文しか記述できない

## 第5章:配列の操作

### 配列型変数

* 配列型変数の宣言時の特徴
  * 大かっこ`[]`はデータ型の後ろだけではなく変数の後ろにも記述できる
  * 配列型変数の宣言時には要素数は指定できない

### 配列の初期値

* 値を代入せずに生成すると初期値になる

|変数型|初期値|
| :---: | :---: |
|`byte`/`short`/`int`/`long`|`0`|
|`float`|`0.0f`|
|`double`|`0.0d`|
|`char`|`'\u0000'(空文字)`|
|`String`|`null`|
|`boolean`|`false`|

## 第6章:インスタンスとメソッド

### リテラル

* `null`は変数が何も参照してないことを表す
  * 空文字`""`は文字数0の`Stringクラスの`オブジェクトを表す

### ガベージコレクション

* インスタンスの参照が無くなった時点でガベージコレクションの対象になる

### staticフィールド・staticメソッド

* `staticフィールド`はインスタンスを生成しなくても使える
* `staticフィールド`にアクセスするにはクラス名.メソッド名と書く
* `staticメソッド`は、`staticフィールド`と`staticメソッド`にしかアクセスできない

### オーバーロード

* **オーバーロード**を行うには同一クラス内に引数の数・型・順番が異なるメソッドを定義する必要がある
  * 変数名は関係なし

### 可変長引数

* **可変長引数**は`int... num`の様に記述する
* 可変長引数は最後の引数でなければならない

### return文

* `return文`の後ろの処理は実行できない

### コンストラクタ

* **コンストラクタ**のルール
  * コンストラクタには戻り値の型は記述できない
  * インスタンス生成時（`new演算子`）に呼び出される
  * アクセス修飾子の制限は無い
* 初期化子`{}`を使うことでオーバーロードされた全てのコンストラクタで共通の処理を行える
  * 初期化子の処理が最初に実行される
  * インスタンス生成時（`new演算子`）に呼び出される
* コンストラクタを省略した時はデフォルトコンストラクタが定義される
* コンストラクタから別のコンストラクタを呼び出すときはthisを使う
  * `this`で呼び出す時は最初に記述する

### アクセス制御

* アクセス修飾子は以下の4つ

|修飾子|内容|
| :---: | :---: |
|`public`|全てのクラスからアクセスできる|
|`protected`|同じパッケージか、継承してるサブクラスからアクセス可能|
|なし|同じパッケージのクラスからアクセス可能|
|`private`|クラス内からアクセス可能|

### カプセル化

* カプセル化はフィールドを`private`、アクセスするためのメソッドを`public`にする

## 第7章:クラスの継承、インターフェース、抽象クラス

### 継承

* コンストラクタと`private`なフィールド・メソッドは継承しても引き継がない

### スーパークラス

* コンストラクタを呼び出してオブジェクトを生成する際には、スーパークラスのコンストラクタを呼び出す必要がある
  * コンストラクタ呼び出しが明記されてなくてもコンパイル時に`super();`の呼び出し処理が先頭行に暗追加される

### インターフェース

* インターフェースは自動的に`public`で修飾される
* インターフェースに実装を記述するにはデフォルトメソッドを使う
  * デフォルトメソッドには`default修飾子`を付ける
  * サブインターフェイスなどで、デフォルトメソッドの処理内容を変えたい時にはオーバーライドを使う
* インターフェイスはインスタンス化できない

### 抽象クラス

* 抽象クラスはインスタンス化できない

### オーバーライド

* メソッドの名前と引数（型・数・順番）は同じである必要がある
* 戻り値の型は同じかサブクラス型である
* アクセス修飾子は同じかより緩いもの

### 型変換

* 型が違う時は型変換をする必要がある

{{< code lang="java" title="型変換" >}}
A a = new B();
B b = (B) a;
{{< /code >}}

## 第8章:関数インターフェース、ラムダ式

### ラムダ式

* ラムダ式の引数は関数インターフェースのメソッドの引数と一致させる必要がある
  * データ型の指定は省略できる
  * 引数を受け取らないメソッドの時は引数を省略できる
  * ローカル変数と同名の変数は引数に宣言できない

* `{}`で囲まれている時は複数処理が書けるが`return文`とセミコロン`;`が必要
  * `()`は省略できる

{{< code lang="java" title="ラムダ式" >}}
Algo a = (name) -> { return "ABC"; };
Algo a = (name) -> "ABC"; 
Algo a = name -> "ABC";
{{< /code >}}

* ラムダ式の外のローカル変数にアクセスするときには、変更されない変数（実質的に`final`な変数）である必要がある

### 関数型インターフェース

* 関数型インターフェースの4種類の特徴

|種類|メソッド|説明|
| :---: | :---: | :---: |
|`Consumer<T>`|`void accept(T)`|引数を受け取り処理する、結果は戻さない|
|`Supplier<T>`|`T get()`|引数を受け取らず、結果だけ返す|
|`Predicate<T>`|`boolean test(T)`|引数を受け取って、それを評価する|
|`Function<T,R>`|`R apply(T)`|引数を受け取って、指定された型の結果を返す|

## 第9章:API

### Listコレクションのメソッド

* `List.of()メソッド`で作成されるリストは変更不可能となるため、要素の追加や削除を行うと例外が発生する

### Mathクラスのメソッド

* `floor()メソッド`では、引数が`NaN`・無限大・`0`・`-0`の時、引数と同じ値が返される

### ArrayListクラスのメソッド　

* `ArrayListクラス`の特徴
  * 要素数を自動的に増やすことができる
  * 重複した値を扱える
  * スレッドセーフではない
  * 値に`null`を追加できる
* `removeメソッド`実行後に読み出すと例外になる

### Arraysクラスのメソッド

* `compare()メソッド`は二つの配列を比較し、`0`（同じ時）・負（第1配列の方が小さい）・正（第2が小さい）を返す

## 第10章:例外処理

### try-catch文

* 例外が発生したらすぐに`catchブロック`に移る
* `catch文`が複数ある場合で到達不可能なコードになる時はコンパイルエラーになる

### try-catch-finally文

* `finally処理`は例外の有無にかかわらず実行する
* `try-catch-finally`の順番を変えることはできない（コンパイルエラーになる）

## 第11章:モジュールシステム

### モジュールシステムの概要

* 内部APIの想定してない使用を防げる
* カスタムランタイムを構成できる
* コンパイル時と実行時の両方で必要になるモジュールを認識できる
* 厳密なカプセル化が可能

### モジュール記述子

* `module-info.java`のファイル名で作成する
* `module ファイル名{}`で宣言する
* プログラムコードのルート階層に配置する

### モジュール型プロジェクト

* `jdepsコマンド`はクラスファイルの依存関係をパッケージレベルかクラスレベルで表示することができるアナライザ

{{< code lang="bash" title="jdepsコマンド" >}}
jdeps --check
{{< /code >}}

### モジュール型アプリケーション

* モジュール化されたアプリケーションをコンパイルするには、モジュールの検索パスを指定するオプションが必要

{{< code lang="bash" title="" >}}
-p

--module-path
{{< /code >}}

* 他にもディレクトリ配下のモジュールを一括してコンパイルするオプションがある

{{< code lang="bash" title="" >}}
--module-source-path
{{< /code >}}

### モジュールグラフ

* 各モジュールは`java.baseモジュール`には明示されていなくても暗黙的に依存する

### モジュール型JDK

* 観測可能なモジュールが検索される順番は、ルート→コンパイル→アップグレード→システム→アプリケーション